<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <style>
pre {
  background-color: #eeeeee;
}
sub {
    vertical-align: sub;
    font-size: smaller;
}
sup {
    vertical-align: sup;
    font-size: smaller;
}
    </style>
  </head>
<body>
<p>This is the MQL Programmer’s Guide. It documents Emdros version 3.7.0 and upwards. If you just wish to use Emdros to query your data, then this might not be for you. Instead, you can consult the MQL Query Guide, which is available from the Emdros website, or with any recent distribution of Emdros.</p>
<p>In Chapter 1, we discuss some preliminaries, such as the history of Emdros, as well as giving an overview of the formalism used to define the MQL language, called Backus-Naur Form (or BNF).</p>
<p>In Chapter 2, we give an overview of the EMdF model, from a user’s standpoint.</p>
<p>In Chapter 3, we describe the bulk of the MQL language.</p>
<p>In Chapter 4, we describe the query-subset of MQL. That is, the subset of MQL in which you can express queries that look for objects by object type, features, and structural relationships such as embedding and sequence.</p>
<h1 id="preliminaries">Preliminaries</h1>
<h2 id="introduction">Introduction</h2>
<p>Welcome to the MQL Programmer’s Guide. MQL is the query language associated with the EMdF model. MQL is a “full access language,” which simply means that MQL lets you create, update, delete, and query most of the data domains in the EMdF model – databases, objects, object types, features, etc. MQL is your front-end to the EMdF database engine. This guide helps you formulate MQL queries that do what you need done with your EMdF database.</p>
<p>This guide has four chapters. The first is this chapter on preliminaries. The second is a gentle introduction to the EMdF model, which underlies the MQL language. The third chapter deals with the bulk of the MQL query language, detailing all the different kinds of queries for creating, updating, deleting, and querying an EMdF database. The fourth chapter is a special chapter devoted to explaining those MQL queries that query for objects in the database. Since these queries are so rich, it was deemed necessary to devote a whole chapter to their treatment.</p>
<p>This chapter will proceed as follows. First, we present a short history of MdF, EMdF, and MQL. Second, we give a gentle introduction to Backus-Naur Form, or BNF, which will be used throughout chapters 3 and 4. Lastly, we explain the origin of the support for something called <em>regular expressions</em> in MQL. This is done so as to comply with the license for the library used.</p>
<p>But first, an explanation of where EMdF and MQL come from.</p>
<h2 id="origins-of-mdf-emdf-and-mql">Origins of MdF, EMdF, and MQL</h2>
<p>EMdF and MQL are not original works. They are merely derivative works based on someone else’s hard labors. Most of the ideas underlying the EMdF model and the MQL query language are to be found in the PhD thesis of Crist-Jan Doedens, published in 1994 as . This thesis described, among other things, the MdF database model and the QL query language. As one might guess, EMdF stems from MdF, and MQL stems from QL.</p>
<p>The EMdF model takes over the MdF model in its entirety, but adds a few concepts which are useful when implementing the MdF model in real life. Thus the ‘E’ in ‘EMdF’ stands for “Extended”, yielding the “Extended MdF model”. The EMdF model is the subject of chapter 2.</p>
<p>“MQL” stands for “Mini QL.” Originally, I devised MQL as a subset of the QL query language developed in Dr. Doedens’ PhD thesis, hence the “Mini” modifier. Since then, however, MQL has grown. QL was not a full access language, but specified only how to query an MdF database, i.e., how to ask questions of it. MQL, by contrast, is a full access language, allowing not only querying, but also creation, update, and deletion of the data domains of the EMdF model. The MQL query language is the subject of chapters 3 and 4.</p>
<p>Thus EMdF and MQL are derivatives of the MdF database model and the QL query language developed by Dr. Crist-Jan Doedens in his 1994 PhD thesis.</p>
<h2 id="introduction-to-backus-naur-form">Introduction to Backus-Naur Form</h2>
<h3 id="context-free-grammars">Context-Free Grammars</h3>
<p>BNF is a way of specifying the “syntactic rules” of a language. English also has “syntactic rules,” and some of them can be specified using a “Context-Free Grammar.” BNF is precisely a way of specifying a context-free grammar for a formal language. Thus it is beneficial first to see what a context-free grammar is, before looking at the details of BNF.</p>
<p>In English, the basic clause-pattern is “Subject - Verb - Object”. For example, in the clause “I eat vegetables,” the word “I” is the subject, the word “eat” is the verb, and the word “vegetables” is the object. A clause which exhibits exactly the same “Subject - Verb - Object” structure is “You drink coke.” Here, “You” is the subject, “drink” is the verb, and “coke” is the object.</p>
<p>Consider the following context-free grammar:</p>
<pre><code>Sentence -&gt; NP<sub>subj</sub> VP

NP<sub>subj</sub> -&gt; “I” | “You”

VP -&gt; V NP<sub>obj</sub>

V -&gt; “eat” | “drink”

NP<sub>obj</sub> -&gt; “vegetables” | “coke”
</code></pre>
<p>This little context-free grammar is a toy example of a context-free grammar. However, despite its simplicity, it exemplifies all of the concepts involved in context-free grammars:</p>
<ul>
<li><p>Rule</p></li>
<li><p>Non-terminal</p></li>
<li><p>Terminal</p></li>
<li><p>Choice</p></li>
<li><p>Concatenation</p></li>
<li><p>Start-symbol.</p></li>
</ul>
<p>These will be described in turn below</p>
<h4 id="rule">Rule</h4>
<p>A “Rule” consists of three parts:</p>
<ol>
<li><p>The left-hand side</p></li>
<li><p>The “production arrow” (“-&gt;”).</p></li>
<li><p>The right-hand side</p></li>
</ol>
<p>An example of a rule in the above context-free grammar is:</p>
<pre><code>Sentence -&gt; NP<sub>subj</sub> VP
</code></pre>
<p>It specifies that the left-hand side (“Sentence”) can be <em>replaced with</em> the right-hand side, which in this case is two symbols, “NP<sub>subj</sub>” followed by “VP”. Sometimes, we also say that a left-hand side is <em>expanded to</em> the right-hand side.</p>
<h4 id="non-terminal">Non-terminal</h4>
<p>There are only two kinds of symbols in a context-free grammar: Non-terminals and Terminals. They are a contrasting pair. In this section, we describe what a non-terminal is, and in the next section, what a terminal is.</p>
<p>A “Non-terminal” is a symbol in a rule which can be expanded to other symbols. Thus the symbols “Sentence”, “NP<sub>subj</sub>”, “VP”, “V”, and “NP<sub>obj</sub>” constitute all of the non-terminals of the above context-free grammar.</p>
<p>Only non-terminals can stand on the left-hand side of a rule. A non-terminal is defined as a symbol which can be expanded to or replaced with other symbols, and hence they can stand on the left-hand side of a rule. But as you will notice in the above context-free grammar, a non-terminal can also stand on the right-hand-side of a rule. For example, the non-terminal “V” is present both in the rule for how to expand the non-terminal “VP”, and in the rule for how to expand itself. Thus, in order to expand “VP” fully, you must first expand to the right-hand-side “V NP<sub>obj</sub>”, and then expand both “V” and “NP<sub>obj</sub>”, using the rules for these two.</p>
<h4 id="terminal">Terminal</h4>
<p>A “Terminal” is a symbol in a rule which cannot be expanded to other symbols. Hence, it is “terminal” in the sense that the expansion cannot proceed further from this symbol. In the above context-free grammar, the terminals are: “I”, “You”, “eat”, “drink”, “vegetables”, and “coke”. These are symbols which cannot be expanded further.</p>
<p>Terminals can only stand on the right-hand side of a rule. If they were to stand on the left-hand-side of the rule, that would mean that they could be expanded to or replaced with other symbols. But that would make them non-terminals.</p>
<h4 id="choice">Choice</h4>
<p>In the rule for “V” in the above grammar, we see an example of choice. The choice is indicated by the “|” symbol, which is read as “or”. Thus, this example:</p>
<pre><code>V -&gt; “eat” | “drink”
</code></pre>
<p>is read as ‘V expands to “eat” <em>or</em> “drink”’.</p>
<h4 id="concatenation">Concatenation</h4>
<p>We have already seen an example of concatenation, namely in the rule for “Sentence”:</p>
<p>Sentence -&gt; NP<sub>subj</sub> VP</p>
<p>Here, the symbols “NP<sub>subj</sub>” and “VP” are <em>concatenated</em>, or placed in sequence. Thus “VP” comes immediately after “NP<sub>subj</sub>”.</p>
<p>“Concatenated” is simply a fanciful name for “being in sequence”, but although it is a basic idea, we included it for completeness.</p>
<h4 id="start-symbol">Start-symbol</h4>
<p>The start-symbol is merely the left-hand side non-terminal of the first rule in the grammar. Thus, in the above grammar, “Sentence” is the start-symbol.</p>
<h3 id="context-free-grammars-putting-it-all-together">Context-free grammars: Putting it all together</h3>
<p>It is time to see how all of this theory works in practice. The above grammar can produce 8 sentences, some of which do not make sense:</p>
<ol>
<li><p>I eat vegetables</p></li>
<li><p>I eat coke</p></li>
<li><p>I drink vegetables</p></li>
<li><p>I drink coke</p></li>
<li><p>You eat vegetables</p></li>
<li><p>You eat coke</p></li>
<li><p>You drink vegetables</p></li>
<li><p>You drink coke</p></li>
</ol>
<p>Let us pick one of these sentences and see how it was produced from the above grammar. We will pick number 8, “You drink coke”, and trace all the steps. We start with the start-symbol, “Sentence”:</p>
<ol>
<li><p>Sentence</p>
<p>This is expanded using the rule for “Sentence”:</p></li>
<li><p>NP<sub>subj</sub> VP</p>
<p>The “NP<sub>subj</sub>” non-terminal is then expanded to “You” using one of the choices in the rule for NP<sub>subj</sub>:</p></li>
<li><p>“You” VP</p>
<p>The “VP” is then expanded using the rule for “VP”:</p></li>
<li><p>“You” V NP<sub>obj</sub></p>
<p>The “V” non-terminal is then expanded to the terminal “drink”:</p></li>
<li><p>“You” “drink” NP<sub>obj</sub></p>
<p>The “NP<sub>obj</sub>” non-terminal is then expanded to the terminal “coke”:</p></li>
<li><p>“You” “drink” “coke”</p>
<p>Which yields the final sentence, “You drink coke”. This sentence has no non-terminals, only terminals, and therefore it cannot be expanded further. We are finished.</p></li>
</ol>
<p>If you would like to, try to trace the production of one of the other sentences using pencil and paper, tracing each step as in the above example. When you have done so once or twice, you should understand all there is to understand about context-free grammars.</p>
<p>And BNF is simply a way of specifying a context-free grammar. So let us start looking at the details of BNF.</p>
<h3 id="bnf">BNF</h3>
<h4 id="introduction-1">Introduction</h4>
<p>BNF comes in various variants, and almost everyone defines their usage of BNF a little differently from everyone else. In this document, we shall also deviate slightly from “standard BNF”, but these deviations will only be very slight.</p>
<p>This treatment of BNF will be made from an example of a context-free grammar in “MQL BNF.” This example covers every formalism used in “MQL BNF,” and is a real-life example of the syntax of an actual MQL statement:</p>
<h4 id="example">Example</h4>
<pre><code>create_enumeration_statement : “CREATE” 

            (“ENUMERATION” | “ENUM”) 

            enumeration_name “=” 

            “{” ec_declaration_list “}”
;

enumeration_name : T_IDENTIFIER

   /* The T_IDENTIFIER is a terminal 

      denoting an identifier. */
;

ec_declaration_list : ec_declaration { “,” ec_declaration }
;

ec_declaration : [ “DEFAULT” ]

              ec_name [ ec_initialization ]
;

ec_name : T_IDENTIFIER
;

ec_initialization : “=” T_INTEGER
;
</code></pre>
<h4 id="elements-of-mql-bnf">Elements of “MQL BNF”</h4>
<p>All of the elements of “MQL BNF” can be listed as follows:</p>
<ol>
<li><p>Rule</p>
<p>This is just the same as in the context-free grammars above, except that the “-&gt;” production arrow is replaced by a “:“ colon. Also, a rule ends with a “;” semicolon.</p></li>
<li><p>Non-terminal</p>
<p>Non-terminals always start with a lower-case letter, e.g., “ec_declaration.”</p></li>
<li><p>Terminal</p>
<p>Terminals are either strings in “double quotes” or strings that start with “T_”, e.g., “T_IDENTIFIER”.</p></li>
<li><p>Choice</p>
<p>This is the same as in the context-free grammars. The symbol “|” is used.</p></li>
<li><p>Concatenation</p>
<p>This is the same as in the context-free grammars. A space between two symbols is used.</p></li>
<li><p>Start-symbol</p>
<p>This is the same as in the context-free grammars. The left-hand side non-terminal of the first rule is the start-symbol.</p></li>
<li><p>Comment</p>
<p>A comment is enclosed in /* slashes and stars */. The comments are not part of the grammar, but serve to explain a part of the grammar to the human reader.</p></li>
<li><p>Optional specification</p>
<p>A symbol or sequence of symbols enclosed in [square brackets] is considered optional. For example, the <code>ec_initialization</code> non-terminal is optional in the <code>ec_declaration</code> rule. Both terminals and non-terminals can be optional. Here, the choice is between “ENUM” and “ENUMERATION”, rather than, say, “CREATE ENUMERATION” and the rest of the rule.</p></li>
<li><p>Bracketing</p>
<p>Sometimes, we do not go to the trouble of spelling out a choice with a rule by itself. Instead, (brackets) are used. For example, in the above grammar, there is a choice between “ENUMERATION” and “ENUM”. Only one must be chosen when writing the CREATE ENUMERATION statement. The brackets serve to let you know the scope of the choice, i.e., between exactly which elements the choice stands.</p></li>
<li><p>Bracing (repetition)</p>
<p>The { braces } are used to indicate that the enclosed part can be repeated zero or more times. For example, in the rule for <code>ec_declaration_list</code>, the first <code>ec_declaration</code> can be followed by zero or more occurrences of first a “,” comma and then an <code>ec_declaration</code>. This effectively means that the <code>ec_declaration_list</code> is a comma-separated list of <code>ec_declaration</code>s, with one or more <code>ec_declaration</code>s.</p>
<p>There is no comma after the last <code>ec_declaration</code>. To see why, notice that the part that is repeated starts with a comma and ends with an <code>ec_declaration</code>. Thus, no matter how many times you repeat this sequence, the <code>ec_declaration</code> will always be last, and the comma will never be last.</p>
<p>That it can be repeated <em>zero</em> or more times simply means that it is optional. In the rule for <code>ec_declaration_list</code>, the first <code>ec_declaration</code> can stand alone.</p>
<p>Notice also that, in the rule for <code>create_enumeration_statement</code>, there are braces as well. These braces, however, are enclosed in “double quotes” and are therefore terminals. Thus they do not have the meaning of repetition, but are to be written in the statement when writing a CREATE ENUMERATION statement. The braces without double quotes are repetition-braces and must not be written.</p></li>
</ol>
<h2 id="acknowledgements">Acknowledgements</h2>
<h3 id="thanks">Thanks</h3>
<p>Thanks to all the contributors mentioned in the AUTHORS file. Special thanks go to Dr. Crist-Jan Doedens, without whose PhD work, Emdros would not have existed. Also thanks to Prof. Dr. Eep Talstra, Prof. Dr. Nicolai Winther-Nielsen, and Prof. Dr. Peter Øhrstrøm for encouragement along the way. Thanks to Dr. Kirk E. Lowery for encouragement and other kinds of contributions. Thanks to Claus Tøndering for code contributions and other encouragements. Thanks to Constantijn Sikkel for encouragement and guidance, and for being an avid user of and bug-reporter for Emdros. Thanks to Prof. Dr. Oliver Glanz for being an avid user and requester of features.</p>
<h3 id="regular-expression-supportpcre">Regular expression support<span id="PCRE" label="PCRE">[PCRE]</h3>
<p>MQL has support for regular expressions in queries. Regular expression support is provided by the PCRE library package, which is open source software, written by Philip Hazel, and copyright by the University of Cambridge, England. The PCRE library can be downloaded from:</p>
<p><code>ftp.csx.cam.ac.uk/pub/software/programming/pcre/</code></p>
<p>The PCRE included with Emdros is a modified copy.</p>
<p>We’ll get back to regular expressions in section <a href="#par:Regular-expressions">[par:Regular-expressions]</a> and in section <a href="#sec:PCRE-license">[sec:PCRE-license]</a>. See also the index.</p>
<h1 id="the-emdf-modelchapteremdf-model">The EMdF model<span id="chapter:EMdF-model" label="chapter:EMdF-model">[chapter:EMdF-model]</h1>
<h2 id="introduction-2">Introduction</h2>
<p>This chapter is a gentle introduction to the “EMdF model”. The EMdF model is a “database model.” As such, it provides a solid theoretical foundation for the EMdF database engine and the MQL query language. However, its importance goes beyond being a theoretical foundation. The EMdF model defines the very way we talk about text in an EMdF database, and as such, it provides the “vocabulary” of the language by which you, the user, communicate with the EMdF database engine. Put another way, the EMdF model defines the concepts which you use to talk about text when communicating with the EMdF database engine. Thus it is very important that you understand all of the concepts involved in the EMdF model. However, these concepts are neither many nor difficult to understand. This chapter is designed to help you understand them, whatever your background.</p>
<p>This chapter is built around the concepts in the EMdF model: monads, objects, object types, features, and a few other concepts. These four concepts: monads, objects, object types, and features, form the backbone of the EMdF model. Once you have understood these, the rest are mere extensions which follow fairly easily.</p>
<p>And so, with no further ado, let us jump into the first of the four major concepts, monads.</p>
<h2 id="monads">Monads</h2>
<h3 id="monads-and-textual-sequence">Monads and textual sequence</h3>
<p>Language is linear in nature. We produce language in real-time, with sequences of sounds forming sequences of words. Text, being language, is also linear in nature. In the EMdF model, this linearity is captured by the monads.</p>
<p>A monad is simply an integer – no more, no less. The sequence of integers (1,2,3,4,…) forms the backbone to which the flow of the text is tied. Thus, because a monad is an integer, and because we can order the integers in an unambiguous way, we use the sequence of monads to keep track of the sequence of textual information.</p>
<p>The sequence of monads begins at 1 and extends upwards to some large number, depending on the size of the database.</p>
<h3 id="granularity">Granularity</h3>
<p>What unit of text does a monad correspond to? For example, does a monad correspond to a morpheme, a word, a sentence, or a paragraph?</p>
<p>The answer is that you, the database user, decide the granularity of the EMdF database. You do this before any text is put into the database. If you want each monad to correspond to a morpheme, you simply decide that this is so. A more common choice is for each monad to correspond to a word. However, there is nothing implicit or explicit in the EMdF model that prevents the user from deciding that another unit of text should correspond to a monad. Be aware, however, that once the choice has been made, and the database has been populated with text, it is not easy to revoke the decision, and go from, say, a word-level granularity to a morpheme-granularity.</p>
<h3 id="text-flow">Text flow</h3>
<p>What is the reading-order of an EMdF database? Is it left-to-right, right-to-left, top-to-bottom, or something else?</p>
<p>The answer is that the EMdF model is agnostic with respect to reading-order. In the EMdF model, what matters is the textual sequence, as embodied by the monads. How the text is displayed on the screen is not specified in the EMdF model.</p>
<p>The MQL query language provides for both 7-bit (ASCII) and 8-bit encodings of strings, which means that the database implementor can implement any character-set that can be encoded in an 8-bit encoding, including Unicode UTF-8.</p>
<h3 id="conclusion">Conclusion</h3>
<p>A monad is an integer. The sequence of integers (1,2,3,4,…) dictates the textual sequence. The granularity of an EMdF database is decided by the database-implementor. The EMdF model is agnostic with respect to reading-order (right-to-left, left-to-right, etc.).</p>
<h2 id="objects">Objects</h2>
<h3 id="what-is-an-object">What is an object?</h3>
<p>An object is a set of monads. Thus, for example, an object might consist of the monads {1,2,4}. This object could, for example, be a phrase-object consisting of three words (assuming the monad-granularity is “one monad, one word”).</p>
<p>The EMdF model does not impose any restrictions on the set of monads making up an object. For example, objects can be discontiguous, as in the above example. In addition, objects can have exactly the same monads as other objects, and objects may share monads.</p>
<p>We need the last two concepts, object types and features, before we can understand exactly how an object can encode, say, a word or a phrase.</p>
<h2 id="object-types">Object types</h2>
<h3 id="objects-are-grouped-in-types">Objects are grouped in types</h3>
<p>In any populated EMdF database, there will be at least one object type. Otherwise, no objects can be created, and thus the database cannot store textual information.</p>
<p>Objects are grouped in types, such as “word”, “phrase”, “clause”, “sentence”, but also “chapter”, “part”, “page”, etc. Each of these are potential object types that the user can create. Once an object type has been created, objects of that type can also be created.</p>
<p>Any object is of exactly one object type. Object types are what gives objects their interpretation. For example, an object of type “phrase” is, by itself, just a set of monads, such as {1,2,4}. But seen in conjunction with its object type, it becomes possible to interpret those monads as a number of words that make up a phrase.</p>
<p>An object type is also what determines what <em>features</em> an object has. And thus we turn to the last major concept in the EMdF model, namely features.</p>
<h2 id="features">Features</h2>
<h3 id="what-is-a-feature">What is a feature?</h3>
<p>A feature is a way of assigning data to an object. For example, say we have an object of type “word”. Let us call this object “O”, and let us say that it consists of the singleton monad set {1}. Assume, furthermore, that the object type “word” has a feature called “surface_text”. Then this feature, taken on the object O, might be the string “In”. This is denoted as “O.surface_text”. If we have another object, O<sub>2</sub>, which consists of the singleton monad set {2}, the value O<sub>2</sub>.surface_text might be “the”. Thus we know that the first text in this EMdF database starts with the words “In the”.</p>
<h3 id="object-types-have-features">Object types have features</h3>
<p>An object type has a fixed number of features defined by the database implementor. For example, it might be necessary for a particular application to have these features on the object type “word”:</p>
<ul>
<li><p>surface_text</p></li>
<li><p>lexical_form</p></li>
<li><p>part_of_speech</p></li>
<li><p>preceding_punctuation</p></li>
<li><p>trailing_punctuation</p></li>
<li><p>ancestor</p></li>
</ul>
<p>The “ancestor” feature would be a pointer to another object, allowing the user to create an immediate constituency hierarchy.</p>
<p>The object type “phrase” might have the following list of features:</p>
<ul>
<li><p>phrase_type</p></li>
<li><p>ancestor</p></li>
</ul>
<h3 id="features-have-types">Features have types</h3>
<p>An object type has a number of features. Each feature, in turn, has one type. In the current implementation of the EMdF model, a feature can have one of the following types:</p>
<ul>
<li><p>integer</p></li>
<li><p>string (which is an 8-bit string)</p></li>
<li><p>ascii (which is a 7-bit ASCII string)</p></li>
<li><p>id_d (which is an object id – we will get to this later)</p></li>
<li><p>enumeration (which we will also get to later in this chapter)</p></li>
<li><p>list of integer</p></li>
<li><p>list of id_d</p></li>
<li><p>list of enumeration constants</p></li>
<li><p>sets of monads</p></li>
</ul>
<h2 id="example-1">Example</h2>
<p>We have now defined all of the four major concepts in the EMdF model: monad, object, object type, and feature. It is time to make them more concrete by giving an example of a very small EMdF database. Look at figure <a href="#TheDoor">[TheDoor]</a>.</p>
<p><img src="TheDoor" alt="Exemplifying the four major concepts of the EMdF model: monad, object, object type, and feature." /></p>
<p>At the top of the figure, you see the sequence of monads, 1 to 9. Just below this sequence, you see the object type “Word” with its object ordinals, 1 to 9. In this example, the granularity is “one monad, one word.” Thus <em>Word</em> number 1 corresponds to <em>monad</em> number 1, but they are really separate entities. Word number 1 <em>consists of</em> the set of monads {1}.</p>
<p>This becomes clearer when you notice that Clause number 2 consists of the set of monads {3,4,5,6,7}. Thus there is a fundamental distinction between the number of an object (also called object ordinal), and the set of monads making up that object.</p>
<p>Some of the object types in the figure (Word and Phrase) have a number of <em>features</em>. The object type “Word” has the features “surface” and “part_of_speech”. The “Phrase” object type has only one feature, namely “phrase_type”.</p>
<p>Notice that objects can be discontiguous. The Clause object with object ordinal 1 consists of the monads {1,2,8,9}. Thus there can be gaps in an object.</p>
<p>Notice also that an object type need not have features. The object types Clause_atom, Clause, and Sentence have no features in the figure.</p>
<h2 id="other-concepts">Other concepts</h2>
<h3 id="introduction-3">Introduction</h3>
<p>Having learned the basic concepts of the EMdF model, we now turn to the additional concepts which we use to talk about EMdF databases. These concepts are:</p>
<ol>
<li><p>The special object types pow_m, any_m, and all_m</p></li>
<li><p>object ids (id_d, id_m)</p></li>
<li><p>self</p></li>
<li><p>part_of</p></li>
<li><p>gaps</p></li>
<li><p>borders, first, and last</p></li>
<li><p>enumerations</p></li>
<li><p>min_m and max_m</p></li>
<li><p>arbitrary monad sets</p></li>
<li><p>databases</p></li>
</ol>
<h3 id="pow_m">pow_m</h3>
<p>In each EMdF database, we assume an abstract object type, pow_m. This object type has one object for every possible set of monads. Thus the pow_m object type has objects consisting of the sets {1},{2},{3}, …, {1,2}, {1,3}, {1,4}, …, {2,3},{2,4},{2,5},…,{1,2,3},{1,2,4}, …, etc. Every possible set of monads is represented in the pow_m object type.</p>
<p>The pow_m object type is an <em>abstract</em> object type. That is, no objects of type pow_m actually exist in the EMdF database. However, it is useful to be able to talk about a particular pow_m object. In effect, a pow_m object is simply a set of monads, and sometimes, it is convenient to be able to talk about a particular pow_m object. This is especially true with gaps (see below).</p>
<p>The pow_m object type has no features.</p>
<h3 id="any_m">any_m</h3>
<p>The any_m object type is an abstract object type like pow_m. Each of its objects consist of a single monad. So the any_m objects are: {1}, {2}, {3}, … etc. The any_m object type has no features.</p>
<h3 id="all_msubsecall_m">all_m<span id="subsec:all_m" label="subsec:all_m">[subsec:all_m]</h3>
<p>The all_m object type has only one object, and it consists of all the monads in the database. That is, it consists of the monads from min_m to max_m (see sections <a href="#SELECT_MIN_M">[SELECT_MIN_M]</a> and <a href="#SELECT_MAX_M">[SELECT_MAX_M]</a>), the smallest and the largest monads in use in the database at any given time. This one object is called all_m-1.</p>
<h3 id="object-ids-id_d-id_m">object ids (id_d, id_m)</h3>
<p>Each object in the database (apart from pow_m objects) has an <em>object id_d</em>. An object id_d is a unique ID assigned to the object when the object is created. The id_d is used only for that particular object, and the id_d is never used again when the object is deleted.</p>
<p>A feature can have the type “id_d”, meaning that the values of the feature are taken from the id_ds in the database.</p>
<p>Each object in the database (including pow_m, any_m, and all_m objects) also has an id_m. The id_m is simply the set of monads which makes up the object. This is not strictly an ID, since objects of the same object type may have exactly the same monads. However, for historical reasons, this is called an id_m. See or for details.</p>
<h3 id="selfself">self<span id="self" label="self">[self]</h3>
<p>Each object type in the database (apart from the pow_m, any_m, and all_m object types) has a feature called “self”. This is used to get the object id_d of the object in question.</p>
<p>The “self” feature is a read-only feature, which means that you cannot update an object’s self feature, or write to it when creating the object. The value of the “self” feature is assigned automatically when the object is created.</p>
<p>The type of the “self” feature is “id_d”.</p>
<h3 id="part_ofpart_of">part_of<span id="part_of" label="part_of">[part_of]</h3>
<p>If all of the monads of one object, O<sub>1</sub>, are contained within the set of monads making up another object, O<sub>2</sub>, we say that O<sub>1</sub> is part_of O<sub>2</sub>.</p>
<p>For example, an object with the monads {1,2} would be part_of another object with the monads {1,2,4}.</p>
<p>In mathematical terms, O<sub>1</sub> is part_of O<sub>2</sub> if and only if O<sub>1</sub> (\subseteq) O<sub>2</sub>.</p>
<h3 id="gapsgaps">gaps<span id="gaps" label="gaps">[gaps]</h3>
<p>Objects may have gaps. A gap in an object is a maximal stretch of monads which are not part of the object, but which are nevertheless within the boundaries of the endpoints of the object. For example, an object consisting of the monads {1,3,4,7,8,13} has three gaps: {2}, {5,6}, and {9,10,11,12}.</p>
<p>Note that gaps are always maximal, i.e., extend across the whole of the gap in the object. For example, {6} is not a gap in the above object: instead, {5,6} is.</p>
<h3 id="borders-first-lastborders-first-last">borders, first, last<span id="borders, first, last" label="borders, first, last">[borders, first, last]</h3>
<p>Each non-empty object, being a set of monads, has a left border and a right border. The left border is the lowest monad in the set, while the right border is the highest monad in the set. These are also called the first monad and the last monad in the object. If we have an object O, the notation for these monads is O.first and O.last.</p>
<p>For example, if we have an object O consisting of the monads {2,3,4,5}, then O.first = 2 and O.last = 5.</p>
<h3 id="consecutive-with-respect-to-a-set-of-monadsconsecutive">consecutive with respect to a set of monads<span id="consecutive" label="consecutive">[consecutive]</h3>
<p>The basic idea is that two sets of monads are consecutive if they follow each other without any gaps in between. However, this idea is extended so that the “no gaps in between” is interpreted with respect to a reference set of monads called Su. For example, if Su = {1,2,5,6}, then the sets {2} and {5} are consecutive with respect to Su. However, the sets {2} and {6} are not consecutive with respect to Su, since there is a “gap” consisting of the monad 5 in between the two sets. Likewise, the sets {1} and {5} are not consecutive with respect to Su, because Su has a monad, 2, which is a “gap” between the two sets.</p>
<h3 id="enumerations">enumerations</h3>
<h4 id="definition">Definition</h4>
<p>Each feature, it will be remembered, is of a certain type. These can be integers, strings, and id_ds, but they can also be enumerations. An enumeration is a set of pairs, where each pair consists of a constant-identifier and an integer value.</p>
<h4 id="example-2">Example</h4>
<p>For example, the enumeration “phrase_type_t” might have the pairs of constants and values as in table <a href="#phrase_type_t">[phrase_type_t]</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">constant</th>
<th style="text-align: center;">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">phrase_type_unknown</td>
<td style="text-align: center;">-1</td>
</tr>
<tr class="even">
<td style="text-align: left;">VP</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NP</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">AP</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PP</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">AdvP</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ParticleP</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>phrase_type_t enumeration</p>
<p><span id="phrase_type_t" label="phrase_type_t">[phrase_type_t]</p>
<h4 id="default-constant">Default constant</h4>
<p>Each enumeration has exactly one default constant which is used when the user does not give a value for a feature with that enumeration type. In this example, “phrase_type_unknown” might be the default.</p>
<h4 id="terminology">Terminology</h4>
<p>The constants are called <em>enumeration constants</em>, while the type gathering the enumeration constants into one whole is called an <em>enumeration</em>.</p>
<h4 id="names-are-identifiers">Names are identifiers</h4>
<p>The names of both enumerations and enumeration constants must be <em>identifiers</em>.</p>
<h4 id="each-enumeration-is-a-name-space">Each enumeration is a name-space</h4>
<p>Each enumeration forms its own namespace. All name-spaces in the MQL language are orthogonal to each other. This means that two enumeration constants within the same enumeration cannot be called by the same constant-identifier, but two enumeration constants in two different enumerations may be the same. For more information, see section <a href="#subsec:Namespaces">[subsec:Namespaces]</a> for more information.</p>
<h4 id="enumeration-constants-must-be-unique">Enumeration constants must be unique</h4>
<p>Enumeration constants must be unique within each enumeration, both in their values and in their names. For example, you cannot have two labels with the same name in the same enumeration. Nor can you have two labels with the same value in the same enumeration, even if the labels have different names.</p>
<p>This is different from C or C++ enumerations, where the same value can be assigned to different labels.</p>
<p>Thus an enumeration is effectively a one-to-one correspondence (also called a bijective function) between a set of label names and a set of values.</p>
<h3 id="min_m-max_mmin_mmax_m">min_m, max_m<span id="min_m,max_m" label="min_m,max_m">[min_m,max_m]</h3>
<p>An EMdF database has a knowledge of which is the smallest monad in use (min_m) and which is the largest monad in use (max_m). Normally, you don’t need to worry about these; the database maintains its knowledge of these monads without your intervention. You can, however, query the database for the minimum and maximum monads (see sections <a href="#SELECT_MIN_M">[SELECT_MIN_M]</a> and <a href="#SELECT_MAX_M">[SELECT_MAX_M]</a>), and when you query the database for objects, this is done within the confines of the minimum and maximum monads. Thus it is useful to know of their existence, but you needn’t worry too much about them.</p>
<p>The associated statements are SELECT MIN_M (section <a href="#SELECT_MIN_M">[SELECT_MIN_M]</a>) and SELECT MAX_M (section <a href="#SELECT_MAX_M">[SELECT_MAX_M]</a>).</p>
<h3 id="arbitrary-monad-setssubsecarbitrary-monad-sets">Arbitrary monad sets<span id="subsec:Arbitrary-monad-sets" label="subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</h3>
<p>Each database has a central repository of monad sets which are not associated with any objects. That is, they are not objects, have no object type, and no features. They are just plain monad sets.</p>
<p>These monad sets can be used as the basis for searches. That is, when doing a SELECT ALL OBJECTS query (or SELECT FOCUS OBJECTS), one can specify within which arbitrary monad set the search should be conducted.</p>
<p>The associated statements are SELECT MONAD SETS (section <a href="#subsec:SELECT-MONAD-SETS">[subsec:SELECT-MONAD-SETS]</a>), GET MONAD SETS (section <a href="#subsec:GET-MONAD-SETS">[subsec:GET-MONAD-SETS]</a>), CREATE MONAD SET (section <a href="#CREATE-MONAD-SET">[CREATE-MONAD-SET]</a>), UPDATE MONAD SET (section <a href="#UPDATE-MONAD-SET">[UPDATE-MONAD-SET]</a>), and DROP MONAD SET (section <a href="#DROP-MONAD-SET">[DROP-MONAD-SET]</a>).</p>
<h3 id="computed-features-monad_set_length-monad_count-first_monad-last_monad">Computed features (monad_set_length, monad_count, first_monad, last_monad)</h3>
<p>The following computed features can always be used on any object type, even though they are never declared:</p>
<ul>
<li><p>first_monad(&lt;monad_set_name&gt;)</p></li>
<li><p>last_monad(&lt;monad_set_name&gt;)</p></li>
<li><p>monad_count(&lt;monad_set_name&gt;)</p></li>
<li><p>monad_set_length(&lt;monad_set_name&gt;)</p></li>
</ul>
<p>The “&lt;monad_set_name&gt;” inside the parentheses must be a valid monad set name, such as the name of a feature of type “SET OF MONADS”, or the privileged monad set feature, “monads”.</p>
<p>If the &lt;monad_set_name&gt; to be used is the privileged “monads” monad set feature, the parenteses and the name “monads” can be omitted, as a short-cut.</p>
<p>The features mean the folllowing:</p>
<ul>
<li><p>first_monad(&lt;monad_set_name&gt;):<br />
Retrieve the &lt;monad_set_name&gt; monad set, and yield its smallest (first) monad. For example, the monad set “{1-3}” has first_monad = 1.</p></li>
<li><p>last_monad(&lt;monad_set_name&gt;):<br />
Retrieve the &lt;monad_set_name&gt; monad set, and yield its largest (last) monad. For example, the monad set “{1-3}” has first_monad = 3.</p></li>
<li><p>monad_count(&lt;monad_set_name&gt;):<br />
Retrieve the &lt;monad_set_name&gt; monad set, and yields the number of monads in it, i.e., its cardinality. For example, the monad set “{1-3, 5}” has a monad_count of 4, since it has 4 monads in it (“1, 2, 3, 5”). Also, the monad set “{3}” has a monad_count of 1, while the monad set “{2-4}” has a monad_count of 3 (“2, 3, 4”).</p></li>
<li><p>monad_set_length(&lt;monad_set_name&gt;):<br />
Retrieve the &lt;monad_set_name&gt; feature, and yield the number</p>
<p>last_monad(&lt;monad_set_name&gt;) - first_monad(&lt;monad_set_name&gt;) + 1</p>
<p>For example, the set “{1-3, 5}” has a monad_set_length of 5 - 1 + 1 = 5.<br />
Note that if the monad set has no gaps, then this will be the same as monad_count(&lt;monad_set_name&gt;). If, on the other hand, the monad set has gaps, the monad_set_length(&lt;monad_set_name&gt;) will be strictly greater than monad_count(&lt;monad_set_name&gt;).</p></li>
</ul>
<h3 id="databases">Databases</h3>
<p>The EMdF model has a concept of “database.” It is an organizational concept which generally corresponds to what the back-end database system calls a “database.” Within a database, there is one string of monads starting at 1 and extending upwards to some very large number. Within this stretch of monads, the user is free to create objects.</p>
<p>You may need to issue the USE DATABASE statement as the first thing you do before doing anything else, in order to tell Emdros which database you want to deal with. Ask the implementor of your Emdros application whether this is what you should do.</p>
<p>A database can be created with the CREATE DATABASE statement.</p>
<h2 id="encryptionsecencryption">Encryption<span id="sec:Encryption" label="sec:Encryption">[sec:Encryption]</h2>
<p>Dr. D. Richard Hipp, the author of SQLite, makes an encryption-enabled version available for a fee. There is skeleton support for SQLite encryption in Emdros, meaning one should be able to use Dr. Hipp’s encryption-enabled version of SQLite with Emdros and get encryption-support in Emdros on SQLite. This has not been tested, however; only the skeleton is there. See &lt;<a href="http://www.hwaci.com\&gt;" class="uri">http://www.hwaci.com\&gt;</a>, the website of Dr. Hipp’s consulting company, for more information about Dr. Hipp’s encryption.</p>
<p>In this manual, when we speak of “encryption” on SQLite, please be aware that the actual encryption is not a part of Emdros, and you will achieve the exact same results and generate the exact same Emdros databases whether you use a key or not, unless you obtain an encryption-enabled SQLite from somewhere.</p>
<h1 id="mql-database-manipulationchaptermql-query-language">MQL database manipulation<span id="chapter:MQL Query Language" label="chapter:MQL Query Language">[chapter:MQL Query Language]</h1>
<h2 id="preliminaries-1">Preliminaries</h2>
<h3 id="introduction-4">Introduction</h3>
<p>In this section on preliminaries, we will talk about four things. First, we describe what terminals are used in the grammar-fragments in this manual. Second, we describe the lexical conventions of MQL. Third, we describe the name-spaces available in MQL. And finally, we describe some top-level constraints in MQL syntax.</p>
<h3 id="terminals">Terminals</h3>
<p>The following terminals are used in this grammar:</p>
<ul>
<li><p>T_IDENTIFIER</p></li>
<li><p>T_INTEGER</p></li>
<li><p>T_STRING</p></li>
<li><p>T_MARKS</p></li>
<li><p><code>“strings”</code>, e.g., <code>“OBJECT”.</code></p></li>
</ul>
<p>The fifth kind, e.g., <code>“OBJECT”</code> represent keywords in MQL. They are parsed as case-insensitive strings without the quotes.</p>
<h3 id="lexical-conventionssubseclexical-conventions">Lexical conventions<span id="subsec:Lexical-conventions" label="subsec:Lexical-conventions">[subsec:Lexical-conventions]</h3>
<p>The lexical conventions for MQL are as follows:</p>
<ol>
<li><p>There are two kinds of comments:</p>
<ol>
<li><p>Enclosed in “/<em>” (opening) and “</em>/” (closing). This kind of comment can span multiple lines. This is the same as C-style comments.</p></li>
<li><p>Starting with “//” and ending at the end of the line. This is the style used in C++.</p></li>
</ol></li>
<li><p>All keywords (such as <code>“CREATE”</code>, <code>“SELECT”</code>, <code>“&lt;=”</code>, etc.) are case-<em>in</em>sensitive insofar as they are made up of letters. Keywords are enclosed in <code>“double quotes”</code> in the syntax-sections below.</p></li>
<li><p>A T_IDENTIFIER begins with any letter (a-z,A-Z) or an underscore (<em>), followed by zero or more letters (a-z,A-Z), numbers (0-9), or underscores (</em>). For example, “Word”, “_delimiter”, “i18n”, and “phrase_type_t” are all identifiers. However, “8bf” is not an identifier because it does not start with a letter or an underscore. Neither is <a href="mailto:bf@foo.com">bf@foo.com</a> an identifier, because it does not consist solely of letters, underscores, and numbers.</p>
<p>Whether a T_IDENTIFIER is case-sensitive depends on what it stands for (i.e., what its “referent” is). See table <a href="#cap:Case-sensitivity-of-T_IDENTIFIERs">[cap:Case-sensitivity-of-T_IDENTIFIERs]</a> for a description.</p></li>
<li><p>A T_INTEGER is any sequence of one or more digits (0-9). For example, “0”, “42”, and “747” are all integers.</p></li>
<li><p>A T_STRING is one of two kinds:</p>
<ol>
<li><p>A T_STRING can start with a single quote (’), followed by zero or more characters which are not single quotes, and ending with another single quote (’). Such a string can contain newlines.</p></li>
<li><p>A T_STRING can also start with a double quote (), followed by zero or more characters, escape-sequences (see table <a href="#Escape-sequences">[Escape-sequences]</a>), or newlines, and ending with a double quote ().</p></li>
</ol></li>
<li><p><span id="T_MARKS-definition" label="T_MARKS-definition">[T_MARKS-definition]A T_MARKS is a sequence of one or more identifiers, each prefixed by a backping (‘). For example, the following are all T_MARKS: “‘yellow’’, “‘red‘context’’, “‘marks‘are‘useful’’, “‘Flash_Gordon‘was‘a‘Hero’’. More precisely, a T_MARKS conforms to the regular expression (‘[a-zA-Z_][a-zA-Z_0-9]*)+.</p></li>
<li><p>White-space (spaces, newlines, and tabs) is ignored except in T_STRINGs.</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">T_IDENTIFIER referent</th>
<th style="text-align: left;">Case-sensitivity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Database name</td>
<td style="text-align: left;">insensitive</td>
</tr>
<tr class="even">
<td style="text-align: left;">Object type name</td>
<td style="text-align: left;">insensitive</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Enumeration name</td>
<td style="text-align: left;">insensitive</td>
</tr>
<tr class="even">
<td style="text-align: left;">Enumeration constant name</td>
<td style="text-align: left;">sensitive</td>
</tr>
</tbody>
</table>
<p>Case-sensitivity of T_IDENTIFIERs<span id="cap:Case-sensitivity-of-T_IDENTIFIERs" label="cap:Case-sensitivity-of-T_IDENTIFIERs">[cap:Case-sensitivity-of-T_IDENTIFIERs]</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Escape sequences</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">\n</td>
<td style="text-align: left;">newline (ASCII 10)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\t</td>
<td style="text-align: left;">horizontal tab (ASCII 9)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\v</td>
<td style="text-align: left;">vertical tab (ASCII 11)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\b</td>
<td style="text-align: left;">backspace (ASCII 8)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\a</td>
<td style="text-align: left;">bell (ASCII 7)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\r</td>
<td style="text-align: left;">carriage-return (ASCII 13)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\f</td>
<td style="text-align: left;">form-feed (ASCII 12)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\\</td>
<td style="text-align: left;">slash (\) (ASCII 92)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\?</td>
<td style="text-align: left;">question-mark (?) (ASCII 63)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\’</td>
<td style="text-align: left;">single quote (’) (ASCII 39)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\</td>
<td style="text-align: left;">double quote () (ASCII 34)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\ooo</td>
<td style="text-align: left;">Octal number (e.g., \377 is 255)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\xXX</td>
<td style="text-align: left;">Hexadecimal number (e.g., \xFF is 255)</td>
</tr>
</tbody>
</table>
<p>Escape sequences in strings enclosed in double quotes.<span label="Escape-sequences"></p>
<h3 id="name-spacessubsecnamespaces">Name-spaces<span id="subsec:Namespaces" label="subsec:Namespaces">[subsec:Namespaces]</h3>
<p>A name-space, in computer-terminology, is a language-domain with fixed borders within which names must be unique. <em>Within</em> a name-space, two different entities <em>cannot</em> be called by the same name without causing a name-clash. In other words, within a name-space, names must be unique. However, if two name-spaces are <em>orthogonal</em> to each other, then a name from one name-space <em>can</em> be the same as a name from the other name-space <em>without</em> causing a name-clash.</p>
<p>In MQL, the following name-spaces exist. They are all orthogonal to each other:</p>
<ul>
<li><p>Each object type forms a name-space with respect to its features. That is, a single object type cannot have two features with the same name, but different object types can have features with the same name. The two features with the same name need not even have the same feature type. This is because all name-spaces are orthogonal to each other.</p></li>
<li><p>Each enumeration forms a name-space with respect to its constants. That is, a single enumeration cannot have two enumeration constants with the same name, but different enumerations can have enumeration constants with the same name. Since all name-spaces are orthogonal to each other, the two enumeration constants with the same name need not have the same integer value.</p></li>
<li><p>Each database forms a global name-space with respect to object type names. That is, object type names must be globally unique within a database. However, since all name-spaces are orthogonal to each other, you can have features or enumeration constants which have the same name as an object type.</p></li>
</ul>
<h3 id="top-level-constraints-on-mql-syntax">Top-level constraints on MQL syntax</h3>
<p>The MQL engine can receive any number (greater than or equal to 1) of MQL statements. The only requirement is that each statement must end with the keyword <code>“GO”</code>. This keyword acts as a delimiter between each statement. The last statement may also be terminated with <code>“GO”</code>, but need not be. Single statements on their own need not be terminated with <code>“GO”</code> either.</p>
<p>If you connect to the MQL engine in daemon-mode, you must append the meta-level statement “QUIT” after the “GO” of the last statement.</p>
<h2 id="return-types">Return types</h2>
<h3 id="introduction-5">Introduction</h3>
<p>MQL is made up of statements, each of which either returns something or doesn’t. If it returns something, there are two possibilities for what the return-type can be. It can be:</p>
<ol>
<li><p>A table, or</p></li>
<li><p>A sheaf</p></li>
</ol>
<h3 id="output-formats">Output-formats</h3>
<p>The MQL engine gives you three options for using the results of an MQL query:</p>
<ol>
<li><p>You can specify that you want XML output.</p></li>
<li><p>You can specify that you want output for displaying on a console.</p></li>
<li><p>You can use the datatype provided if your program is in the same process as the mql library.</p></li>
</ol>
<p>If you use the mql(1) program for output, please see the manual page for how to choose the output kind.</p>
<h3 id="tablesreturn_typestables">Tables<span id="Return_types:Tables" label="Return_types:Tables">[Return_types:Tables]</h3>
<p>The tables will look differently, depending on whether you choose XML-output or console-output. In the descriptions below, we will give abstract schemas for the tables, such as the following:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_type_name : string</th>
<th style="text-align: center;">monad : monad_m</th>
<th style="text-align: center;">id_d : id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>This means that, in each row in the table, the first piece of data will be a string (called object_type_name), the second piece of data will be a monad_m (called monad), and the last piece of data will be an id_d (called id_d). And then the row stops. There will always be the same number of columns in each row.</p>
<p>A table of values may be empty, meaning it has no rows. In this case, there will still be a table heading with type-specifications.</p>
<p>Some MQL statements do not return a value. In this case, there will be no result, not even an empty table.</p>
<h3 id="atomic-output-types-in-tables">Atomic output-types in tables</h3>
<p>The following types can get into a table and will be announced in the header of the table:</p>
<ol>
<li><p>string</p></li>
<li><p>integer</p></li>
<li><p>boolean (true or false)</p></li>
<li><p>id_d</p></li>
</ol>
<h3 id="other-return-values">Other return values</h3>
<p>A number of other values are also returned from each query:</p>
<ol>
<li><p>A boolean indicating whether there were any compiler-errors.</p></li>
<li><p>A boolean indicating whether there were any database-errors.</p></li>
<li><p>An integer showing which stage of the compilation/interpretation we had come to when we exited the function (see table <a href="#Table:Compiler-stages">[Table:Compiler-stages]</a>). In XML, this is a string as shown in the table, of the attribute “stage” attribute of the “error_stage” element.</p></li>
<li><p>A string carrying any error messages.</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Stage</th>
<th style="text-align: center;">Value</th>
<th style="text-align: left;">XML string</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">None</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">none</td>
</tr>
<tr class="even">
<td style="text-align: left;">Parsing</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">parse</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Weeding</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">weed</td>
</tr>
<tr class="even">
<td style="text-align: left;">Symbol-checking</td>
<td style="text-align: center;">3</td>
<td style="text-align: left;">symbol</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Type-checking</td>
<td style="text-align: center;">4</td>
<td style="text-align: left;">type</td>
</tr>
<tr class="even">
<td style="text-align: left;">Monads-checking</td>
<td style="text-align: center;">5</td>
<td style="text-align: left;">monads</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Execution</td>
<td style="text-align: center;">6</td>
<td style="text-align: left;">exec</td>
</tr>
</tbody>
</table>
<p>Compiler stages<span id="Table:Compiler-stages" label="Table:Compiler-stages">[Table:Compiler-stages].<br />
See include/mql_execution_environment.h for ready-made #define macros.</p>
<h2 id="database-manipulation">Database manipulation</h2>
<h3 id="create-databasecreate_database">CREATE DATABASE<span id="CREATE_DATABASE" label="CREATE_DATABASE">[CREATE_DATABASE]</h3>
<h4 id="syntax">Syntax</h4>
<pre><code>create_database_statement : “CREATE”  “DATABASE”

    database_name opt_WITH_KEY opt_USING_ENCODING
;

database_name : T_IDENTIFIER

              | T_STRING
;

opt_WITH_KEY : /* Empty: No key is used. */

             | “WITH”  “KEY”  T_STRING
;

opt_USING_ENCODING : /* Empty: Default encoding is used. */

                  | “USING”  “ENCODING”  T_STRING
;
</code></pre>
<h4 id="example-3">Example</h4>
<pre><code>CREATE DATABASE book_test

GO

CREATE DATABASE book_test_utf8 

USING ENCODING ’utf-8’

GO

CREATE DATABASE book_test_latin1

USING ENCODING ’iso-8859-1’

GO
</code></pre>
<h4 id="explanation">Explanation</h4>
<p>The CREATE DATABASE statement creates and initializes a database. No text data is put into the database, and no object types are created, but the structures necessary for the EMdF engine to function are set in place. The user need not worry about these structures. Interested users are referred to .</p>
<p>You must CREATE a database before you can USE it (see section <a href="#USE%20DATABASE">[USE DATABASE]</a>). Alternatively, if you have a database that is already created but not initialized, you can use the INITIALIZE DATABASE statememt (see Section <a href="#INITIALIZE_DATABASE">[INITIALIZE_DATABASE]</a>).</p>
<p>If a transaction was in progress (see BEGIN TRANSACTION statement, section <a href="#subsec:BEGIN-TRANSACTION">[subsec:BEGIN-TRANSACTION]</a>), the transaction is automatically committed before the CREATE DATABASE statement is executed. Thus the user need not, cannot, and should not commit it or abort it.</p>
<p>The database name can be either a T_IDENTIFIER or a T_STRING. For MySQL and PostgreSQL, it must be a T_IDENTIFIER. For SQLite, it can be a T_STRING giving the filename (optionally including the full path) of the file in which the database is to be created. If no path is given, the file is created in the current working directory.</p>
<p>The optional “WITH KEY” syntax can be used on SQLite to send a key to SQLite’s sqlite_open_encrypted API when opening the database. Note that this will not actually perform any encryption at all unless you obtain an encryption-enabled SQLite from somewhere, e.g., Dr. Hipp himself, the author of SQLite. See Section <a href="#sec:Encryption">[sec:Encryption]</a> for more information.</p>
<p>The optional “WITH ENCODING” syntax can be used to specify the default encoding to be used for the database when creating it in the backend database. Currently, the following values are supported:</p>
<ul>
<li><p>utf-8</p></li>
<li><p>iso-8859-1</p></li>
</ul>
<p>If the WITH ENCODING clause is not supplied, then the default encoding is used. The default encoding for each database is given in the following list:</p>
<ul>
<li><p>PostgreSQL: iso-8859-1</p></li>
<li><p>MySQL: iso-8859-1</p></li>
<li><p>SQLite 2: iso-8859-1</p></li>
<li><p>SQLite 3: utf-8</p></li>
</ul>
<p>For SQLite 3, the only encoding available is utf-8. To specify any other encoding would be an error.</p>
<p>Note that the encoding specified only has a bearing on how the database backend interprets the data, not on how Emdros interprets the data. In fact, Emdros most likely will not interpret the data at all, but rather will pass whatever is stored in the database on to the application using Emdros, which must the interpret the data according to domain-specific knowledge of which encoding has been used.</p>
<h4 id="return-type">Return type</h4>
<p>There is no return value.</p>
<h3 id="initialize-databaseinitialize_database">INITIALIZE DATABASE<span id="INITIALIZE_DATABASE" label="INITIALIZE_DATABASE">[INITIALIZE_DATABASE]</h3>
<h4 id="syntax-1">Syntax</h4>
<pre><code>initialize_database_statement : “INITIALIZE”  “DATABASE”

    database_name opt_WITH_KEY
;

database_name : T_IDENTIFIER

              | T_STRING
;

opt_WITH_KEY : /* Empty: No key is used. */

             | “WITH”  “KEY”  T_STRING
;
</code></pre>
<h4 id="example-4">Example</h4>
<pre><code>INITIALIZE DATABASE book_test

GO
</code></pre>
<h4 id="explanation-1">Explanation</h4>
<p>The INITIALIZE DATABASE statement initializes a database without creating it first. That is, the database must exist before issuing this statement. It simple creates all the meta-data necessary for having an Emdros database. This is useful on MySQL and PostgreSQL if you don’t have privileges to create databases, but you do have privileges to create tables in an already-provided database. On SQLite, it is also useful, if you want to add Emdros information to an already-existing SQLite database. Other than not creating the database, this statement accomplishes the same things as the CREATE DATABASE statement (see Section <a href="#CREATE_DATABASE">[CREATE_DATABASE]</a>).</p>
<p>For the optional “WITH KEY” syntax, please see the CREATE DATABASE statement.</p>
<p>There is no “WITH ENCODING” syntax for the INITIALIZE DATABASE statement. This is because the encoding is only used when CREATEing the database. However, the internal metadata of the database is set to the default given under the explanation for CREATE DATABASE (see Section <a href="#CREATE_DATABASE">[CREATE_DATABASE]</a>).</p>
<h4 id="return-type-1">Return type</h4>
<p>There is no return value.</p>
<h3 id="use-databaseuse-database">USE DATABASE<span id="USE DATABASE" label="USE DATABASE">[USE DATABASE]</h3>
<h4 id="syntax-2">Syntax</h4>
<pre><code>use_database_statement : “USE”  [ “DATABASE” ] 

    database_name  opt_WITH_KEY
;

database_name : T_IDENTIFIER

              | T_STRING
;

opt_WITH_KEY : /* Empty: No key is used. */

             | “WITH”  “KEY”  T_STRING
;
</code></pre>
<h4 id="example-5">Example</h4>
<pre><code>USE book_test

GO
</code></pre>
<p>This is equivalent to</p>
<pre><code>USE DATABASE book_test

GO
</code></pre>
<p>On SQLite:</p>
<pre><code>USE DATABASE c:\\\\EmdrosDBs\\\\mydb.db /* On SQLite you can do this. */

GO
</code></pre>
<p>With a key:</p>
<pre><code>/* On SQLite you can get encryption ****IF**** you have an 

   encryption-enabled SQLite. */

USE DATABASE c:\\\\Emdros\\\\MySecretDB.db 

/* The format and length of the key depends on your SQLite

   encryption implementation. This is just an example. */

WITH KEY \\x45\\x98\\xbf\\x12\\xfa\\xc6 

GO
</code></pre>
<h4 id="explanation-2">Explanation</h4>
<p>Before you can start using a database you have CREATEd (see section <a href="#CREATE_DATABASE">[CREATE_DATABASE]</a>) or INITIALIZEd (see section <a href="#INITIALIZE_DATABASE">[INITIALIZE_DATABASE]</a>), you must connect to it using the USE DATABASE statement. The keyword “DATABASE” is optional and can be left out.</p>
<p>If a transaction was in progress (see BEGIN TRANSACTION statement, section <a href="#subsec:BEGIN-TRANSACTION">[subsec:BEGIN-TRANSACTION]</a>), the transaction is automatically committed before the USE DATABASE statement is executed. Thus the user need not, cannot, and should not commit it or abort it.</p>
<p>The database name can be either a T_IDENTIFIER or a T_STRING. For MySQL and PostgreSQL, it must be a T_IDENTIFIER. For SQLite, it can be a T_STRING giving the filename (optionally including the full path) of the file holding the database to be used. If no path is given, the file must be in the current working directory.</p>
<h4 id="return-type-2">Return type</h4>
<p>There is no return value.</p>
<h3 id="drop-database">DROP DATABASE</h3>
<h4 id="syntax-3">Syntax</h4>
<pre><code>drop_database_statement : “DROP” “DATABASE”

    database_name
;

database_name : T_IDENTIFIER

              | T_STRING
;
</code></pre>
<h4 id="example-6">Example</h4>
<pre><code>DROP DATABASE book_test

GO
</code></pre>
<h4 id="explanation-3">Explanation</h4>
<p>A previously CREATEd database (see section <a href="#CREATE_DATABASE">[CREATE_DATABASE]</a>) can be completely removed from the system using this statement. All data in the database is irretrievably lost, including all objects, all object types, and all enumerations.</p>
<p>If a transaction was in progress (see BEGIN TRANSACTION statement, section <a href="#subsec:BEGIN-TRANSACTION">[subsec:BEGIN-TRANSACTION]</a>), the transaction is automatically committed before the DROP DATABASE statement is executed. Thus the user need not, cannot, and should not commit it or abort it.</p>
<p>The database name can be either a T_IDENTIFIER or a T_STRING. For MySQL and PostgreSQL, it must be a T_IDENTIFIER. For SQLite, it can be a T_STRING giving the filename (optionally including the full path) of the file holding the database to be dropped. If no path is given, the file must be in the current working directory.</p>
<h4 id="return-type-3">Return type</h4>
<p>There is no return value.</p>
<h3 id="vacuum-database">VACUUM DATABASE</h3>
<h4 id="syntax-4">Syntax</h4>
<pre><code>vacuum_database_statement : “VACUUM” [ “DATABASE” ]

                            [ “ANALYZE” ]
;
</code></pre>
<h4 id="example-7">Example</h4>
<pre><code>1. VACUUM DATABASE

   GO   
   
2. VACUUM DATABASE ANALYZE

   GO
</code></pre>
<h4 id="explanation-4">Explanation</h4>
<p>On PostgreSQL, this statement vacuums the database using the “VACUUM” SQL statement. If the optional keyword “ANALYZE” is given, the statement issues a “VACUUM ANALYZE” statement. See the PostgreSQL documentation for what this does.</p>
<p>On MySQL, this statement issues OPTIMIZE TABLE queries for all object types. If the ANALYZE keyword is given, ANALYZE TABLE queries are issued as well.</p>
<p>On SQLite, this statement first deletes all redundant sequence info (compacting the sequence tables), then issues a VACUUM statement to SQLite.</p>
<p>The significance of this statement to Emdros development is that, when populating a database, things will speed up dramatically if the database is VACUUM’ed after every 1000 objects created, or so.</p>
<h4 id="return-type-4">Return type</h4>
<p>There is no return value.</p>
<h3 id="drop-indexesdrop-indexes">DROP INDEXES<span id="DROP-INDEXES" label="DROP-INDEXES">[DROP-INDEXES]</h3>
<h4 id="syntax-5">Syntax</h4>
<pre><code>drop_indexes_statement : “DROP” “INDEXES”

                         “ON” “OBJECT” (“TYPE” | “TYPES”)

                         “[” object_type_to_drop_indexes_on “]”
;

object_type_to_drop_indexes_on : object_type_name | “ALL”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-8">Example</h4>
<pre><code>1. DROP INDEXES

   ON OBJECT TYPES

   [ALL]

   GO   
   
2. DROP INDEXES

   ON OBJECT TYPE

   [Word]

   GO
</code></pre>
<h4 id="explanation-5">Explanation</h4>
<p>Emdros creates indexes on the tables associated with object types when they are created. These indexes speed up retrieval, but slow down insertion. Therefore, if you are going to insert a large amount of objects, it is best to drop indexes on the object types you are going to modify (possible all object types), then create the indexes again after you have inserted all objects.</p>
<p>This statement drop indexes that have previously been create. It has no effect if the indexes have been dropped already. If “ALL” is specified as the object type, then all object types in the current database will have their indexes dropped (if not dropped already).</p>
<p>The manage_indices program that comes with the Emdros distribution can be used to achieve the same effect.</p>
<p>Note that the choice between “TYPE” and “TYPES” is just syntactic sugar. It doesn’t matter which you use.</p>
<p>If a feature has been declared WITH INDEX, this index is dropped. However, the feature will have its index recreated upon a CREATE INDEXES statement affecting that object type.</p>
<h4 id="return-type-5">Return type</h4>
<p>There is no return value.</p>
<h3 id="create-indexescreate-indexes">CREATE INDEXES<span id="CREATE-INDEXES" label="CREATE-INDEXES">[CREATE-INDEXES]</h3>
<h4 id="syntax-6">Syntax</h4>
<pre><code>create_indexes_statement : “CREATE” “INDEXES”

                         “ON” “OBJECT” (“TYPE” | “TYPES”)

                         “[” object_type_to_create_indexes_on “]”
;

object_type_to_create_indexes_on : object_type_name | “ALL”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-9">Example</h4>
<pre><code>1. CREATE INDEXES

   ON OBJECT TYPES

   [ALL]

   GO   
   
2. CREATE INDEXES

   ON OBJECT TYPE

   [Word]

   GO
</code></pre>
<h4 id="explanation-6">Explanation</h4>
<p>Emdros creates indexes on the tables associated with object types when they are created. These indexes speed up retrieval, but slow down insertion. Therefore, if you are going to insert a large amount of objects, it is best to drop indexes on the object types you are going to modify (possible all object types), then create the indexes again after you have inserted all objects.</p>
<p>This statement creates indexes that have previously been dropped. It has no effect if the indexes are there already. If “ALL” is specified as the object type, then all object types in the current database will have their indexes created (if not there already).</p>
<p>The manage_indices program that comes with the Emdros distribution can be used to achieve the same effect.</p>
<p>Note that the choice between “TYPE” and “TYPES” is just syntactic sugar. It doesn’t matter which you use.</p>
<h4 id="return-type-6">Return type</h4>
<p>There is no return value.</p>
<h2 id="transactions">Transactions</h2>
<h3 id="begin-transactionsubsecbegin-transaction">BEGIN TRANSACTION<span id="subsec:BEGIN-TRANSACTION" label="subsec:BEGIN-TRANSACTION">[subsec:BEGIN-TRANSACTION]</h3>
<h4 id="syntax-7">Syntax</h4>
<pre><code>begin_transaction_statement : “BEGIN”  “TRANSACTION”
;
</code></pre>
<h4 id="example-10">Example</h4>
<pre><code>BEGIN TRANSACTION

GO
</code></pre>
<h4 id="explanation-7">Explanation</h4>
<p>On PostgreSQL, this statement begins a transaction if no transaction is in progress already. The return value is a boolean saying whether the transaction was started (true) or not (false). If this value is false, the user should not subsequently issue a COMMIT TRANSACTION or ABORT TRANSACTION statement. If this value is true, the user should issue either a COMMIT TRANSACTION or an ABORT TRANSACTION later.</p>
<p>On MySQL, this has no effect, and always returns false.</p>
<p>On SQLite, the behavior is the same as on PostgreSQL.</p>
<p>The transaction, if started, is automatically committed if a CREATE DATABASE, USE DATABASE, DROP DATABASE or QUIT statement is issued before a COMMIT TRANSACTION or ABORT TRANSACTION statement has been issued.</p>
<p>Also, the transaction is automatically committed if the connection to the database is lost, e.g., if the mql(1) program reaches the end of the MQL stream (e.g., an MQL script) and thus has to close down. Transactions are not maintained across invocations of the mql(1) program. The transaction is also committed if the EMdFDB, CMQL_execution_environment, or CEmdrosEnv object is destroyed.</p>
<h4 id="return-type-7">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">transaction_started : boolean</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>This table is empty if and only if there was a compiler error, i.e., if the syntax was not obeyed. The statement cannot fail with a database error. If no transaction was started, false is returned. If a transaction was started, true is returned.</p>
<h3 id="commit-transactioncommit-transaction">COMMIT TRANSACTION<span id="COMMIT-TRANSACTION" label="COMMIT-TRANSACTION">[COMMIT-TRANSACTION]</h3>
<h4 id="syntax-8">Syntax</h4>
<pre><code>commit_transaction_statement : “COMMIT”  “TRANSACTION”
;
</code></pre>
<h4 id="example-11">Example</h4>
<pre><code>COMMIT TRANSACTION

GO
</code></pre>
<h4 id="explanation-8">Explanation</h4>
<p>Commits the current transaction, if one is in progress. Has no effect if a transaction was not in progress. In such cases, false is returned.</p>
<p>If the commit failed, false is returned. If the commit succeeded, true is returned.</p>
<p>NOTE that this is slightly different from other statements which flag a DB error if unsuccessful. Here, no DB error is flagged, but false is returned in the table.</p>
<h4 id="return-type-8">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">transaction_committed : boolean</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>This table is empty if and only if there was a compiler error, i.e., if the syntax was not obeyed. The statement cannot fail with a database error. If no transaction was started when the COMMIT TRANSACTION statement was invocated, false is returned. If a transaction was started, and it was committed successfully, true is returned. If a transaction was started, but it was not committed successfully, false is returned.</p>
<h3 id="abort-transactionabort-transaction">ABORT TRANSACTION<span id="ABORT-TRANSACTION" label="ABORT-TRANSACTION">[ABORT-TRANSACTION]</h3>
<h4 id="syntax-9">Syntax</h4>
<pre><code>abort_transaction_statement : “ABORT”  “TRANSACTION”
;
</code></pre>
<h4 id="example-12">Example</h4>
<pre><code>ABORT TRANSACTION

GO
</code></pre>
<h4 id="explanation-9">Explanation</h4>
<p>Aborts the current transaction, if one is in progress. Has no effect if a transaction was not in progress. In such cases, false is returned.</p>
<p>If the abort failed, false is returned. If the abort succeeded, true is returned.</p>
<p>NOTE that this is slightly different from other statements which flag a DB error if unsuccessful. Here, no DB error is flagged, but false is returned in the table.</p>
<h4 id="return-type-9">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">transaction_aborted : boolean</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>This table is empty if and only if there was a compiler error, i.e., if the syntax was not obeyed. The statement cannot fail with a database error. If no transaction was started when the ABORT TRANSACTION statement was invocated, false is returned. If a transaction was started, and it was aborted successfully, true is returned. If a transaction was started, but it was not aborted successfully, false is returned.</p>
<h2 id="object-type-manipulation">Object type manipulation</h2>
<h3 id="create-object-typecreate_object_type">CREATE OBJECT TYPE<span id="CREATE_OBJECT_TYPE" label="CREATE_OBJECT_TYPE">[CREATE_OBJECT_TYPE]</h3>
<h4 id="syntax-10">Syntax</h4>
<pre><code>create_object_type_statement : “CREATE” 

    [ “OBJECT” ] “TYPE”

    opt_if_not_exists

    opt_range_type

    opt_monad_uniqueness_type

    “[”  object_type_name   

           [ feature_declaration_list ]

    “]”
;

opt_if_not_exists:

   /* empty: Throw an error if object type exists already */

  | “IF”  “NOT”  “EXISTS”
;

opt_range_type:

    /* empty: Same as WITH MULTIPLE RANGE OBJECTS */

  | “WITH”  “SINGLE”  “MONAD”  “OBJECTS”

  | “WITH”  “SINGLE”  “RANGE”  “OBJECTS”

  | “WITH”  “MULTIPLE” “RANGE”  “OBJECTS”
;

opt_monad_uniqueness_type :

    /* empty: same as WITHOUT UNIQUE MONADS */

  | “HAVING”  “UNIQUE”  “FIRST”  “MONADS”

  | “HAVING”  “UNIQUE”  “FIRST”  “AND”  “LAST”  “MONADS”

  | “WITHOUT”  “UNIQUE”   “MONADS”
;

object_type_name : T_IDENTIFIER
;

feature_declaration_list : feature_declaration  

    { feature_declaration }
;

feature_declaration :  feature_name  “:”  feature_type 

    [ default_specification ]   “;”

    | feature_name “:” list_feature_type “;”
;

feature_type : 

       “INTEGER”  [with_index_specification]

    |  “ID_D”     [with_index_specification]

    | “STRING”    [from_set_specification]  [with_index_specification] 

    | “ASCII”     [from_set_specification]  [with_index_specification]

    | set_of_monads_specification

    | T_IDENTIFIER /* For enumerations. */
;

list_feature_type :

      “LIST”  “OF”  “INTEGER”  

    | “LIST”  “OF”  “ID_D”  

    | “LIST”  “OF”  T_IDENTIFIER  /* For enumerations */
;

with_index_specification :  

    | “WITH”  “INDEX”

    | “WITHOUT”  “INDEX”
;

from_set_specification : “FROM”  “SET”
;

set_of_monads_specification : 

    | “SINGLE” “MONAD” “SET” “OF” “MONADS”

    | “SINGLE” “RANGE” “SET” “OF” “MONADS”

    | “MULTIPLE” “RANGE” “SET” “OF” “MONADS”

    | “SET” “OF” “MONADS” /* Same as MULTIPLE RANGE SET OF MONADS */
;

default_specification : “DEFAULT” expression 
;

expression : signed_integer /* integer and id_d */

    | T_STRING

    | T_IDENTIFIER /* enumeration constant */

    | monad_set
;

signed_integer : T_INTEGER

    | “-” T_INTEGER

    | “NIL”
;
</code></pre>
<h4 id="examples">Examples</h4>
<pre><code>CREATE OBJECT WITH

WITH SINGLE MONAD OBJECTS

[Word

  surface: STRING WITHOUT INDEX;

  lemma : STRING WITH INDEX;

  parsing_tag : STRING FROM SET WITH INDEX;

  psp : part_of_speech_t;

  parents : LIST OF id_d;

]

GO

CREATE OBJECT TYPE

IF NOT EXISTS

[Clause

   parent : id_d;

   clause_type : clause_type_t default NC;

   functions : LIST OF clause_function_t; // An enumeration

   descendants : LIST OF ID_D;

   parallel_monads : SET OF MONADS;

]

GO
</code></pre>
<p>The latter creates an object type called “Clause” with four features: parent (Immediate Constituent of), whose type is id_d, and clause_type, which has the enumeration-type clause_type_t and the default value NC (which must be an enumeration constant in the clause_type_t enumeration). In addition, the two features “functions” and “descendants” are created, both of which are lists. “functions” is a list of enumeration constants drawn from the enumeration clause_function_t, whereas the “descendants” feature is a list of id_ds, which should then point to the descendants in the tree. In addition, if the object type “Clause” exists already, no error is thrown, and the object type is left untouched.</p>
<h4 id="explanation-10">Explanation</h4>
<p>This statement <em>creates an object type</em> in the meta-data repository of the current database. It starts out with the keywords “CREATE OBJECT TYPE”, followed by an optional clause which states whether the objects will be single-range or multiple-range (see below). After that comes a specification of the object type name and its features enclosed in square brackets. The <code>feature_declaration_list</code> is optional, so it is possible for an object type to have no features.[1]</p>
<p>Each feature_declaration consists of a feature name, followed by a colon, followed by a feature type, followed by an optional specification of the default value.</p>
<p>An INTEGER, ID_D, STRING, or ASCII feature can be declared “WITH INDEX”. This will put an index on the feature’s column. The default is not to add an index. This index will be dropped if a DROP INDEXES statement is issued for the object type (see Section <a href="#DROP-INDEXES">[DROP-INDEXES]</a>), but it will be recreated if a CREATE INDEXES statement is issued for the object type (see Section <a href="#CREATE-INDEXES">[CREATE-INDEXES]</a>). If a feature is an enumeration, it is usually not a good idea to create an index on the feature. This is because enumeration constants are usually few in number, and it is generally not a good idea to index columns that draw their values from a small pool of values, since this can lead to speed decreases (O(NlogN) instead of O(N)). Therefore, the MQL language does not allow creating indexes on enumeration features. You can add them yourself, of course, if you like, with the backend’s corresponding SQL interface.</p>
<p>A STRING or ASCII feature can be declared “FROM SET”. The default is for it not to be from a set. This does <em>not</em> mean that the value of the feature <em>is</em> a set, but rather that the values are drawn FROM a set. Whenever an object is created or updated, and a feature is assigned which is declared “FROM SET”, the string value is first looked up in a special table that maps strings to unique integers. Then this unique integer is used in lieu of the string in the feature column. If the string does not exist in the separate table, it is added, with a unique integer to go with it, and that integer is used. If the string is there, then the integer already associated with the string is used. This gives a space savings (on MySQL and PostgreSQL), and sometimes also a speed advantage, especially if used on the string features of a Word object type which do no have high cardinality (number of unique instances), and the words number many millions. SQLite and SQLite 3 may not see any speed or space savings advantage. Note that using FROM SET on a string may actually impede performance (especially database loading times), especially on MySQL, if the cardinality of the string data is high. This will likely be the case for strings like “surface” and “lemma”, which generally should not be declared FROM SET. However, features like “part_of_speech”, “case”, “number”, “gender”, which all most likely have low cardinality, might be good candidates for using a STRING FROM SET. Thus STRING FROM SET is a performance-enhanced way of using general strings instead of enumerations, and should be just as fast as enumerations for most queries, provided it is not used with high-cardinality data.</p>
<p>The specification of the default value <code>(default_specification</code>) consists of the keyword “DEFAULT”, followed by an expression. An expression is either a <code>signed_integer</code>, a string, or an identifier. The identifier must be an enumeration constant belonging to the enumeration which is also the type of the feature. The <code>signed_integer</code> is either a signed integer (positive or negative), or the keyword “NIL”, meaning the id_d that points to no object.</p>
<p>The feature “self” is implicitly created. It is an error if it is declared. The “self” feature is a computed feature which holds the unique object id_d of the object. See also <a href="#self">[self]</a>.</p>
<p>The difference between “ASCII” and “STRING” is that the user promises only to store 7-bit data in an ASCII string, whereas a STRING string may contain 8-bit data.[2]</p>
<p>In previous versions, you could specify a string length in parentheses after the STRING or ASCII keyword. As of version 1.2.0, all strings can have arbitrary length, with no maximum.[3] The old syntax is still available, but is ignored.</p>
<p>If a feature is declared as a LIST OF <em>something</em>, that something has to be either INTEGER, ID_D, or an enumeration constant. Lists of strings are not supported. Also, you cannot declare a default value for a list – the default value is always the empty list.</p>
<p>This statement can be “hedged” with the “IF NOT EXISTS” clause. If this clause is included, the statement does not throw an error if the object type exists already. Instead, the object type is left as it is (no changes are made to what is in the database already), and the statement returns success. If the “IF NOT EXISTS” clause is omitted, the statement throws an error if the object type exists already.</p>
<p>An object type can be declared “WITH SINGLE MONAD OBJECTS”, “WITH SINGLE RANGE OBJECTS” or “WITH MULTIPLE RANGE OBJECTS”. The difference is that:</p>
<ul>
<li><p>An object type which has been declared “WITH SINGLE MONAD OBJECTS” can only hold objects which consist of a single monad (i.e., the first monad is the same as the last monad).</p></li>
<li><p>An object type which has been declared “WITH SINGLE RANGE OBJECTS” can only hold objects which consist of a <em>single monad range</em>, i.e., there are no gaps in the monad set, but it consists of a single contiguous stretch of monads (possibly only 1 monad long).</p></li>
<li><p>An object type which has been declared “WITH MULTIPLE RANGE OBJECTS” (the default) can hold objects which have arbitrary monad sets.</p></li>
</ul>
<p>A single-monad object must consist of only 1 monad, e.g., {1}, {2}, {3}. A single-range object can consist of a single monad (e.g., { 1 }, { 2 }, { 3 }, etc.), or it can consist of a single interval (e.g., { 6-7 }, { 9-13 }, { 100-121 }, etc.). However, as soon as an object type needs to hold objects which can consist of more than one range (e.g., { 6-7, 9-13 }), then it must be declared WITH MULTIPLE RANGE OBJECTS. If neither is specified, then WITH MULTIPLE RANGE OBJECTS is assumed.</p>
<p>There is a speed advantage of using WITH SINGLE MONAD OBJECTS over WITH SINGLE RANGE OBJECTS, and again a speed advantage of using WITH SINGLE RANGE OBJECTS over WITH MULTIPLE RANGE OBJECTS. The latter is the slowest, but is also the most flexible in terms of monad sets.</p>
<p>In addition, and orthogonally to the range type, an object type can be declared “HAVING UNIQUE FIRST MONADS”, “HAVING UNIQUE FIRST AND LAST MONADS”, or “WITHOUT UNIQUE MONADS”. The difference is:</p>
<ul>
<li><p>An object type which has been declared “HAVING UNIQUE FIRST MONADS” can only hold objects which are unique in their first monad within the object type. That is, within this object type, no two objects may start at the same monad.</p></li>
<li><p>An object type which has been declared “HAVING UNIQUE FIRST AND LAST MONADS” can only hold objects which are unique in their first monad and in their last monad (as a pair: You are allowed to have two objects with the same starting monad but different ending monads, or vice versa). That is, no two objects within this object type start at the same monad while also ending at the same monad. Note that for object types declared WITH SINGLE MONAD OBJECTS, a “HAVING UNIQUE FIRST AND LAST MONADS” restriction is upgraded to a “HAVING UNIQUE FIRST MONADS” restriction, since they are equivalent for this range type.</p></li>
<li><p>An object type which has been declared “WITHOUT UNIQUE MONADS” (or which omits any of the “monad uniqueness constraints”) has no restrictions on the monads, other than those implied by the range type.</p></li>
</ul>
<h4 id="return-type-10">Return type</h4>
<p>There is no return value.</p>
<h3 id="update-object-typeupdate_object_type">UPDATE OBJECT TYPE<span id="UPDATE_OBJECT_TYPE" label="UPDATE_OBJECT_TYPE">[UPDATE_OBJECT_TYPE]</h3>
<h4 id="syntax-11">Syntax</h4>
<pre><code>update_object_type_statement : “UPDATE”   

    [ “OBJECT” ]   “TYPE”

    “[” object_type_name

          feature_update_list

    “]”
;

object_type_name : T_IDENTIFIER
;

feature_update_list : feature_update   { feature_update }
;

feature_update : [ “ADD” ]  feature_declaration

    | “REMOVE”   feature_name   “;”
;

feature_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-13">Example</h4>
<pre><code>UPDATE OBJECT TYPE

[Word

    ADD no_of_morphemes : integer;

    REMOVE surface_without_accents;

]

GO
</code></pre>
<p>This example ADDs the feature no_of_morphemes (being an integer), and REMOVEs the feature surface_without_accents.</p>
<h4 id="explanation-11">Explanation</h4>
<p>This statement <em>updates an object type</em>. It can either add a feature or remove an already-existing feature. When adding a new feature, the ADD keyword is optional. Other than that, it has exactly the same notation as for feature declarations under the CREATE OBJECT TYPE statement.</p>
<p>Removing a feature requires the REMOVE keyword, the feature name, and a semicolon.</p>
<p>Both additions and removals must be terminated with semicolon, even if the <code>feature_update</code> is the only <code>feature_update</code> in the list of <code>feature_update</code>s.</p>
<p>Note that the statement does not allow for <em>changing</em> the type of an already existing feature, only for adding or removing features.</p>
<h4 id="return-type-11">Return type</h4>
<p>There is no return value.</p>
<h3 id="drop-object-type">DROP OBJECT TYPE</h3>
<h4 id="syntax-12">Syntax</h4>
<pre><code>drop_object_type_statement : “DROP”

    [ “OBJECT” ]   “TYPE”

    “[“   object_type_name   “]”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-14">Example</h4>
<pre><code>DROP OBJECT TYPE

[Sploinks]

GO
</code></pre>
<p>This example drops the object type “Sploinks” from the database.</p>
<h4 id="explanation-12">Explanation</h4>
<p>This statement drops an object type entirely from the database. This deletes not only the object type, but also all the objects of that object type, as well as the object type’s features. Enumerations which are used as a feature type are not dropped, however.</p>
<h4 id="return-type-12">Return type</h4>
<p>There is no return value.</p>
<h2 id="enumeration-manipulation">Enumeration manipulation</h2>
<h3 id="create-enumerationcreate_enumeration">CREATE ENUMERATION<span id="CREATE_ENUMERATION" label="CREATE_ENUMERATION">[CREATE_ENUMERATION]</h3>
<h4 id="syntax-13">Syntax</h4>
<pre><code>create_enumeration_statement : “CREATE”   

    (“ENUM” | “ENUMERATION”) 

    enumeration_name   “=” 

    “{”  ec_declaration_list  “}”
;

enumeration_name : T_IDENTIFIER
;

ec_declaration_list : ec_declaration    { “,”   ec_declaration }
;

ec_declaration : [ “DEFAULT” ]   

                 ec_name   

                 [ ec_initialization ]
;

ec_name : T_IDENTIFIER
;

ec_initialization : “=” signed_integer
;
</code></pre>
<h4 id="example-15">Example</h4>
<pre><code>CREATE ENUMERATION

phrase_type_t = { VP = 1, NP, AP, 

   PP, default NotApplicable = -1 }

GO
</code></pre>
<p>This particular statement creates an enumeration called “phrase_type_t” with the following constants and values:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NotApplicable</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">VP</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NP</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">AP</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PP</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">No</td>
</tr>
</tbody>
</table>
<h4 id="explanation-13">Explanation</h4>
<p>This statement creates a new enumeration and populates it with enumeration constants.</p>
<p>If there is no declaration that has the “default” keyword, then the first one in the list becomes the default.</p>
<p>If the first declaration does not have an initialization, its value becomes 1. This is different from C and C++ <code>enum</code>s, which get 0 as the first value by default.</p>
<p>If a declaration does not have an initialization, its values becomes that of the previous declaration, plus 1. This mimics C and C++ <code>enum</code>s.</p>
<p>Label names must be unique within the enumeration. That is, you cannot have two constants with the same name in the same enumeration.</p>
<p>Values must also be unique within the enumeration. That is, you cannot have two different labels with the same value in the same enumeration. This is different from C/C++ <code>enum</code>s, where two labels may have the same value.</p>
<h4 id="return-type-13">Return type</h4>
<p>There is no return value.</p>
<h3 id="update-enumeration">UPDATE ENUMERATION</h3>
<h4 id="syntax-14">Syntax</h4>
<pre><code>update_enumeration_statement : “UPDATE”

    (“ENUM” | “ENUMERATION”)

    enumeration_name   “=”

    “{”   ec_update_list   “}”
;

enumeration_name : T_IDENTIFIER
;

ec_update_list : ec_update   { “,”   ec_update }
;

ec_update : [ “ADD” ] [ “DEFAULT” ]

    ec_name ec_initialization 

  | “UPDATE”    [ “DEFAULT” ]   ec_name   ec_initialization 

  | “REMOVE” ec_name 
;

ec_name : T_IDENTIFIER
;

ec_initialization : “=” signed_integer
;
</code></pre>
<h4 id="example-16">Example</h4>
<pre><code>UPDATE ENUMERATION

phrase_type_t = {

    ADD default Unknown = -99,

    REMOVE NotApplicable,

    UPDATE PP = 5,

    AdvP = 4

}

GO
</code></pre>
<p>This alters the table made in the example in section <a href="#CREATE_ENUMERATION">[CREATE_ENUMERATION]</a> to be like this:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Value</th>
<th style="text-align: center;">Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Unknown</td>
<td style="text-align: center;">-99</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">VP</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NP</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">AP</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">AdvP</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">PP</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">No</td>
</tr>
</tbody>
</table>
<h4 id="explanation-14">Explanation</h4>
<p>This statement updates the enumeration constants of an already existing enumeration. The user can specify whether to add, remove, or update an enumeration constant.</p>
<p>It is an error (and none of the updates will be executed) if the user REMOVEs the default enumeration constant without specifying a new default.</p>
<p>Note that you are forced to specify values for all of the constants updated or added.</p>
<p>It is an error (and none of the updates will be executed) if the update would lave the enumeration in a state where two labels would have the same value. This is because an enumeration is effectively a one-to-one correspondence between a set of labels and a set of values.</p>
<p>It is the user’s responsibility that the update leaves the database in a consistent state. For example, Emdros will not complain if you remove a constant with a given value without specifying a different constant with the same value, even if there are features that use this enumeration and have this value. This would mean that those feature-values could not be searched for, since there would be no label to look for. Neither would it be possible to get the feature values with GET FEATURES, since there would be no label to return.</p>
<h4 id="return-type-14">Return type</h4>
<p>There is no return value.</p>
<h3 id="drop-enumeration">DROP ENUMERATION</h3>
<h4 id="syntax-15">Syntax</h4>
<pre><code>drop_enumeration_statement : “DROP” 

    (“ENUM” | “ENUMERATION”)

    enumeration_name
;

enumeration_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-17">Example</h4>
<pre><code>DROP ENUMERATION phrase_type_t

GO
</code></pre>
<h4 id="explanation-15">Explanation</h4>
<p>This statement removes an enumeration altogether from the database, including all its enumeration constants.</p>
<p>It is an error (and impossible) to drop an enumeration which is in use by some object type.</p>
<h4 id="return-type-15">Return type</h4>
<p>There is no return value.</p>
<h2 id="segment-manipulation">Segment manipulation</h2>
<h3 id="introduction-6">Introduction</h3>
<p>Segments were present in Emdros up to and including version 1.1.12. After that, support for segments was removed.</p>
<p>A segment used to be an arbitrary, contiguous stretch of monads which was given a name. Objects could not be created which crossed the boundaries of a segment. You could restrict your search to within a single segment with SELECT ALL OBJECTS.</p>
<p>However, segments were found to be ugly baggage, cumbersome and not useful. Therefore, they were removed.</p>
<p>The CREATE SEGMENT statement is retained for backward compatibility.</p>
<h3 id="create-segmentcreate_segment">CREATE SEGMENT<span id="CREATE_SEGMENT" label="CREATE_SEGMENT">[CREATE_SEGMENT]</h3>
<h4 id="syntax-16">Syntax</h4>
<pre><code>create_segment_statement : “CREATE”   “SEGMENT”

    segment_name

    “RANGE”   “=”   segment_range
;

segment_name : T_IDENTIFIER
;

segment_range : T_INTEGER “-” T_INTEGER
;
</code></pre>
<h4 id="example-18">Example</h4>
<pre><code>CREATE SEGMENT Old_Testament

RANGE = 1 - 500000

GO
</code></pre>
<p>This example used to create a segment named “Old_Testament” starting at monad 1 and ending at monad 500000.</p>
<p>Now it does nothing.</p>
<h4 id="explanation-16">Explanation</h4>
<p>This statement currently does nothing. It will fail with a database error.</p>
<h4 id="return-type-16">Return type</h4>
<p>There is no return value.</p>
<h2 id="querying-the-data">Querying the data</h2>
<p>This section describes statements which can be used to query the <em>data</em> in an Emdros database, as opposed to querying the <em>schema</em>.</p>
<h3 id="select-focusall-objectsselect_objects">SELECT (FOCUS|ALL) OBJECTS<span id="SELECT_OBJECTS" label="SELECT_OBJECTS">[SELECT_OBJECTS]</h3>
<h4 id="syntax-17">Syntax</h4>
<pre><code>select_objects_statement : select_clause 

    opt_in_clause

    opt_with_max_range_clause

    opt_returning_clause

    where_clause
;

/*

 * select-clause

 */

select_clause : “SELECT”   focus_specification   [ “OBJECTS” ]
;

focus_specification : “FOCUS” | “ALL”
;

/*

 * in-clause

 */

opt_in_clause : “IN”   in_specification

  | /* empty = all_m-1 */
;

in_specification : monad_set 

  | “ALL” /* = all_m-1 */

  | monad_set 

  | T_IDENTIFIER /* Named arbitrary monad set */
;

monad_set : “{”   monad_set_element_list   “}”
;

monad_set_element_list : monad_set_element   

    { “,”   monad_set_element }
;

monad_set_element : T_INTEGER

  | T_INTEGER   “-”   T_INTEGER

  | T_INTEGER   “-”   /* From T_INTEGER to “practical infinity”

                           (i.e., MAX_MONAD). */
;

 

/*

 *opt_with_max_range_clause

 */

opt_with_max_range_clause : “WITH” “MAX” “RANGE” “MAX_M” “MONADS”

   | /* empty; same as WITH MAX RANGE MAX_M MONADS. */

   | “WITH” “MAX” “RANGE” T_INTEGER “MONADS”

   | “WITH” “MAX” “RANGE” “FEATURE” “MONADS” “FROM” “[“ object_type_name “]”

   | “WITH” “MAX” “RANGE” “FEATURE” feature_name “FROM” “[“ object_type_name “]”
;

/*

 * returning-clause

 */

opt_returning_clause : /* Empty: Return full sheaf */

  | “RETURNING” “FULL” “SHEAF”

  | “RETURNING” “FLAT” “SHEAF”

  | “RETURNING” “FLAT” “SHEAF”  “ON” 

    object_type_name_list 
;

object_type_name_list : 

  object_type_name { “,” object_type_name }
;

/*

 * where-clause

 */

where_clause : “WHERE” mql_query
;
</code></pre>
<h4 id="example-19">Example</h4>
<pre><code>SELECT ALL OBJECTS

IN { 1-4, 5, 7-9 }

WITH MAX RANGE 5 MONADS

RETURNING FULL SHEAF

WHERE

[Word lexeme = ”\&gt;RY/”]

GO
</code></pre>
<h4 id="explanationselect-objects-explanation">Explanation<span id="SELECT OBJECTS: Explanation" label="SELECT OBJECTS: Explanation">[SELECT OBJECTS: Explanation]</h4>
<p>This statement is a front-end to the MQL Query-subset (see chapter 4 starting on page ).</p>
<p>The parameters to an MQL query are:</p>
<ol>
<li><p>A universe U,</p></li>
<li><p>A substrate Su, and</p></li>
<li><p>A topograph.</p></li>
</ol>
<p>The universe U is a contiguous stretch of monads. The search is restricted only to include objects which are wholly contained within this universe (i.e., which are part_of[4] the universe).</p>
<p>The substrate is used to further restrict the search. For there is the additional requirement that all objects found must be wholly contained within (i.e., part_of) the substrate as well. The substrate must be part_of the universe. Mathematically speaking, the substrate is the set intersection of whatever was in the IN clause and all_m-1 (i.e., the set of all monads in the database).</p>
<p>The topograph is what is specified as <code>mql_query</code> in the above grammar.</p>
<p>The IN-specification tells the query-engine what the substrate Su should be. There are three choices:</p>
<ol>
<li><p>Specify an explicit monad set like “{ 1-3000, 7000-10000 }”</p></li>
<li><p>Specify a named arbitrary monad set (see section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>).</p></li>
<li><p>Leave it blank. This means that the substrate is calculated as all_m-1 (i.e., all of the monads in the database; see or or page in this Programmer’s Guide.)</p></li>
</ol>
<p>The universe U is then calculated as all the monads between the first and last monads of the substrate.</p>
<p>The “max range” specifies the maximum number of monads to take as a context for any power block at the outermost level. The significance of this is that it helps users not to get query results which are correct but useless because the query returns too many straws in the sheaf. This is done by putting an upper limit on the number of monads a power block may extend over. This limit can be “MAX_M” monads, meaning that there is in practice no limit to the stretch of monads which can be matched by a power block. It can also be empty, which is the same as “MAX_M” monads, i.e., no limit. It can also be an explicit number of monads, say, 5 or 100. The max range can also be taken as the length of the largest object of any object type. The set of monads to use can be either the privileged “monads” feature, or any feature whose type is SET OF MONADS. Note that the limit is NOT taken as the length of any actual object of the given object type which happens to be part_of the current stretch of monads under investigation. Rather, the cap is set before query execution time by inspecting the largest length of any monad set of the given monad set feature in the object type.</p>
<p>The difference between the RETURNING FULL SHEAF and the RETURNING FLAT SHEAF clause is that the latter applies the “flatten” operator to the sheaf before returning it, whereas the former does not. If the returning_clause clause is empty, it means the same thing as RETURNING FULL SHEAF. If the RETURNING FLAT SHEAF has an ON appendix with a list of object type names, then the two-argument flatten operator is applied using this list of object type names. See section <a href="#subsec:Flat-sheaf">[subsec:Flat-sheaf]</a> for an explanation of flat sheaves and the “flatten” operator.</p>
<h4 id="monad-set">Monad set</h4>
<p>The explicit monad set in the IN clause, if given, must consist of a comma-separated list of monad-set-elements enclosed in curly braces. A monad-set-element is either a single integer (referring to a single monad) or a range consisting of two integers (referring to a range of monads). The monad-set-elements need not occur in any specific order, and are allowed to overlap. The result is calculated by adding all the monads together into one big set. The ranges of monads must, however, be monotonic, i.e., the second integer must be greater than or equal to the first.</p>
<h4 id="return-type-17">Return type</h4>
<p>A sheaf, either full or flat: All retrieved objects are included, but those objects that had the <code>focus</code> modifier in the query are flagged as such. Please see <a href="#sheaf">[sheaf]</a> for an explanation of the sheaf. Appendix <a href="#Appendix:Console-sheaf-grammar">[Appendix:Console-sheaf-grammar]</a> gives the grammar for the console-sheaf. Please see section <a href="#subsec:Flat-sheaf">[subsec:Flat-sheaf]</a> for an explanation of the flat sheaf.</p>
<h3 id="select-objects-at">SELECT OBJECTS AT</h3>
<h4 id="syntax-18">Syntax</h4>
<pre><code>select_objects_at_statement : “SELECT”   [ “OBJECTS” ]

    “AT”   single_monad_specification

    “[”  object_type_to_find   “]”
;

single_monad_specification : “MONAD”   “=”   T_INTEGER
;

object_type_to_find : object_type_name
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-20">Example</h4>
<pre><code>SELECT OBJECTS

AT MONAD = 3406

[Clause]

GO
</code></pre>
<p>This example selects all those objects of type Clause which start at monad 3406.</p>
<h4 id="explanation-17">Explanation</h4>
<p>This statement returns a table containing the object id_ds of all the objects of the given type which start at the monad specified, i.e., whose first monad is the given monad.</p>
<p>The result is a table with one column, namely “id_d”. Each row represents one object, where the id_d is its object id_d.</p>
<h4 id="return-type-18">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">id_d: id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty. Note, however, that the table can also be empty because there were no objects of the given type having the given monad as their first monad. This is not an error.</p>
<h3 id="select-objects-having-monads-in">SELECT OBJECTS HAVING MONADS IN</h3>
<h4 id="syntax-19">Syntax</h4>
<pre><code>select_objects_having_monads_in_statement :

   “SELECT” “OBJECTS”

   “HAVING” “MONADS” “IN”

   monad_set

   “[”  object_type_to_find   “]”
;

object_type_to_find : object_type_name | “ALL”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-21">Example</h4>
<pre><code>SELECT OBJECTS

HAVING MONADS IN { 23-45, 68, 70, 87-93 }

[Clause]

GO   
   
SELECT OBJECTS

HAVING MONADS IN { 1, 5-7, 103-109 }

[ALL]

GO   
   
SELECT OBJECTS

HAVING MONADS IN { 23 }

[Word]

GO
</code></pre>
<h4 id="explanation-18">Explanation</h4>
<p>This statement returns the object types and object id_ds of the objects that have at least one monad in the monad set specified. If “ALL” is specified as the object type, then this is done for all object types in the database. If a specific object type is specified, then that object type is used.</p>
<p>The returned table has one row for each object. Each object is represented only once. The monad in each row is guaranteed to be from the set of monads specified, and is guaranteed to be from the object in the row.</p>
<p>This statement is useful in much the same way that the SELECT OBJECTS AT statement is useful. It can be used, e.g., for getting id_ds of objects that must be displayed as part of the results of a query, but which are not in the query results. This statement can also be used like the SELECT OBJECTS AT statement by simply making the monad set a singleton set with only one monad. Note, however, that this statement does something a different from SELECT OBJECTS AT. Whereas SELECT OBJECTS AT will only retrieve an object if that object <em>starts on</em> the given monad, this present statement will retrieve the object if only the object <em>has at least one monad</em> from the monad set given. This statement also has the advantage that one can ask for all object types. This enables one to access objects which one knows might be there, but of which one does not know the object types. It also has the advantage of being much faster than a series of SELECT OBJECTS AT statements if one is looking for objects in more than one monad.</p>
<p>This statement was typically used in a series of SELECT OBJECTS HAVING MONADS IN, GET MONADS, and GET FEATURES statements, in order to obtain all information necessary for display of data. This sequence has been wrapped neatly into the GET OBJECTS HAVING MONADS IN statement, which is now the preferred method of doing this sequence.</p>
<p>Note to programmers: If you want to get objects not from all object types but from only a subset of all object types, the easiest thing is to issue the required number of copies of the statement with GO in between, varying only the object type. That way, if you are using the mql program as a proxy for the MQL engine, you don’t incur the overhead of starting and stopping the mql program.</p>
<h4 id="return-type-19">Return type</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_type_name : string</th>
<th style="text-align: center;">monad : monad_m</th>
<th style="text-align: center;">id_d : id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty. Note, however, that the table can also be empty if the command were successful, if there were no objects that had at least one monad in the monad set specified.</p>
<h3 id="get-objects-having-monads-in">GET OBJECTS HAVING MONADS IN</h3>
<h4 id="syntax-20">Syntax</h4>
<pre><code>get_objects_having_monads_in_statement :

   “GET” “OBJECTS”

   “HAVING” “MONADS” “IN”

   gohmi_monad_set

   using_monad_set_feature

   “[”  object_type_name   

          [gohmi_feature_retrieval]

   “]”
;

gohmi_monad_set : “ALL” /* all_m-1 on the “monads” feature,

                           regardless of which monad set is actually used\! 

                        */

                | monad_set
;

using_monad_set_feature : /* empty: Use the object’s monad set */

    | “USING” “MONAD” “FEATURE” feature_name

    | “USING” “MONAD” “FEATURE” “MONADS”
;

feature_name : T_IDENTIFIER
;

gohmi_feature_retrieval : “GET” feature_list

                        | “GET” “ALL”
;

feature_list : feature_name { “,” feature_name }*
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-22">Example</h4>
<pre><code>GET OBJECTS

HAVING MONADS IN { 23-45, 68, 70, 87-93 }

[Clause]

GO   
   
GET OBJECTS

HAVING MONADS IN { 1, 5-7, 103-109 }

USING MONAD FEATURE parallel_monads

[Phrase GET phrase_type, function]

GO   
   
GET OBJECTS

HAVING MONADS IN { 23 }

[Word GET ALL]

GO
</code></pre>
<h4 id="explanation-19">Explanation</h4>
<p>This statement returns the objects of the given object type that have at least one monad in the monad set specified. A flat sheaf is returned with one straw containing all the objects to be retrieved.</p>
<p>The monad set to use is the object’s monad set by default. If the “using_monad_set_feature” variant is used, the monad sets used are the ones stored in this feature. The feature must be a set of monads.</p>
<p>This statement is useful in much the same way that the SELECT OBJECTS AT statement is useful. It can be used, e.g., for getting id_ds of objects that must be displayed as part of the results of a query, but which are not in the query results.</p>
<p>This is the preferred method for getting objects from the engine, rather than a sequence of SELECT OBJECTS HAVING MONADS IN, GET MONADS, and GET FEATURES. It is much faster than the combination of the three.</p>
<h4 id="return-type-20">Return type</h4>
<p>A flat sheaf is returned which contains the objects in question. See Section <a href="#subsec:Flat-sheaf">[subsec:Flat-sheaf]</a> for more information.</p>
<h3 id="get-aggregate-features">GET AGGREGATE FEATURES</h3>
<h4 id="syntax-21">Syntax</h4>
<pre><code>get_aggregate_features_statement : “GET” “AGGREGATE” (“FEATURE” | “FEATURES”)

    aggregate_feature_list

    “FROM” “OBJECTS” opt_in_clause

    “WHERE” 

    “[“ object_type_name 

       feature_constraints

    “]”
;

aggregate_feature_list : aggregate_feature 

                       | aggregate_feature_list “,” aggregate_feature
;

aggregate_feature : aggregate_function “(“ feature_name “)”

                  | “COUNT” “(“ “*” “)”

                  | “COUNT” “(“ feature_name “=” feature_value “)”
;

aggregate_function : “MIN” | “MAX” | “SUM”
;

feature_name : T_IDENTIFIER
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="examples-1">Examples</h4>
<pre><code>/*

 * Create the enumerations and object types of an 

 * example database.

 *

 */

CREATE ENUMERATION boolean_t = {

    false = 0,

    true

}

GO

CREATE ENUMERATION part_of_speech_t = {

    Verb,

    Noun,

    ProperNoun,

    Pronoun,

    Adjective,

    Adverb,

    Preposition,

    Conjunction,

    Particle

}

GO

CREATE OBJECT TYPE

WITH SINGLE MONAD OBJECTS

[Token

    has_space_before : boolean_t;  // Any space before the surface?

    surface : STRING;              // The surface itself

    has_space_after : boolean_t;   // Any space after the surface?

    part_of_speech : part_of_speech_t;

    is_punctuation : boolean_t;     // true iff the surface is punctuation.

]

GO

CREATE OBJECT TYPE

WITH SINGLE RANGE OBJECTS

[Line

    actant_name : STRING FROM SET;

    gender : gender_t;

    words_spoken : INTEGER; 

    line_number_in_act : INTEGER;

]

GO

/*

 * Example 1:

 *

 * Founds all Token objects in the entire database whose 

 * is_punctuation feature equals false.

 *

 * Then retrieve one aggregate function, namely a count of 

 * all Token objects whose part_of_speech is equal to Verb.

 */

GET AGGREGATE FEATURES

COUNT(part_of_speech=Verb)

FROM OBJECTS

WHERE

[Token is_punctuation=false]

GO

/* 

 * Example 2:

 *

 * Finds all Line objects in the database (no monad restriction), and

 * does three aggregate functions:

 * - Find the sum of all words spoken by all actants.

 * - Find a count of all Line objects. (Note that this, together with the

 *   sum of all words spoken, can be used to calculate the average

 *   number of words spoken by any actant. This has to be done outside of 

 *   Emdros, as Emdros does not yet support floating point return values.)

 * - Find a count of all Line objects whose gender feature is Man, i.e., the

 *   number of Line spoken by a Man.

 */

GET AGGREGATE FEATURES

SUM(words_spoken), COUNT(*), COUNT(gender=Man)

FROM OBJECTS

WHERE

[Line]

GO

/*

 * Example 3:

 *

 * Finds all Line objects where actant_name is equal to Hamlet in

 * the monad set { 1-12478 } (an arbitrarily chosen example).

 * Does three aggregate functions:

 * - Finds the maximum number of words spoken in any of Hamlet’s 

 *   lines.

 * - Finds the minimum line number in any act (i.e., the first line

 *   in which Hamlet speaks.

 * - Finds the total count of Lines spoken by Hamlet.

 */

GET AGGREGATE FEATURES

MAX(words_spoken), MIN(line_number_in_act), COUNT(*)

FROM OBJECTS

IN { 1-12478 }

WHERE

[Line actant_name=Hamlet

GO

/*

 * Example 4:

 *

 * Finds all Line objects in all monads,

 * where actant_name is equal to Hamlet 

 * OR is equal to “Ophelia”.

 * Does three aggregate functions:

 * - Finds the total sum of words spoken by either Hamlet or Ophelia.

 * - Finds the count of all Lines in which the actant_name is “Hamlet”.

 * - Finds the count of all Lines in which the actant_name is “Ophelia”.

 */

GET AGGREGATE FEATURES

SUM(words_spoken), COUNT(actant_name=Hamlet), COUNT(actant_name=Ophelia)

FROM OBJECTS

IN ALL

WHERE

[Line actant_name=Hamlet OR actant_name=Ophelia

GO
</code></pre>
<h4 id="explanation-20">Explanation</h4>
<p>This statement returns a table giving the desired aggregate functions over the objects specified in the WHERE clause.</p>
<p>In essence, five aggregate functions are available:</p>
<ul>
<li><p>MIN(feature_name):<br />
Retrieves the minimum value of the given feature. The feature must be of type integer. The result is also an integer.</p></li>
<li><p>MAX(feature_name):<br />
Retrieves the maximum value of the given feature. The feature must be of type integer. The result is also an integer.</p></li>
<li><p>SUM(feature_name):<br />
Retrieves the sum of all values of the given feature. The feature must be of type integer. The result is also an integer.</p></li>
<li><p>COUNT(*):<br />
Retrieves a count of all objects retrieved by the WHERE clause. The result is an integer.</p></li>
<li><p>COUNT(feature_name=feature_value):<br />
Retrieves a count of all objects retrieves, with the added restriction that the given feature name must have the given feature value. The result is an integer.</p></li>
</ul>
<p>The standard SQL aggregate function “AVG” is missing. This is because Emdros does not (yet) support return values with type “floating point”. Note that the same result as AVG can be achieved by retrieving two aggregate functions: SUM(feature_name) and COUNT(*), and then doing the appropriate division outside of Emdros.</p>
<p>The <code>opt_in_clause</code> can be used to limit the monad set within which to retrieve the objects. If omitted, it means that the entire database is searched, without monad restriction.</p>
<p>The object type name given after the “WHERE” and “[“ tokens is also the object type on which any features in the aggregate feature list are found. Hence, the features mentioned in the aggregate feature list must exist on the object type.</p>
<p>It is possible to use an arbitrary Boolean expression after the object type name, just as in the topographic MQL queries explained in Chapter .</p>
<h4 id="return-type-21">Return type</h4>
<p>Upon failure, an empty table.</p>
<p>Upon success, a table with one row, and as many columns as there are aggregate functions in the query. The column types are all “integer”, and the column names are given as “Column1”, “Column2”, ..., “Column<em>N</em>”, where the number given is the index (1-based) of the aggregate functions in the input query.</p>
<h3 id="get-monadssectionget-monads">GET MONADS<span id="Section:GET MONADS" label="Section:GET MONADS">[Section:GET MONADS]</h3>
<h4 id="syntax-22">Syntax</h4>
<pre><code>get_monads_statement : “GET” “MONADS” 

    “FROM”   (“OBJECT” | “OBJECTS”)

    “WITH” id_ds_specification

    “[” object_type_name “]”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-23">Example</h4>
<pre><code>GET MONADS 

FROM OBJECTS

WITH ID_DS = 10342, 10344, 10383

[Clause]

GO
</code></pre>
<h4 id="explanationget_monadsexplanation">Explanation<span id="GET_MONADS:Explanation" label="GET_MONADS:Explanation">[GET_MONADS:Explanation]</h4>
<p>This statement returns, for each object in the list of id_ds, a representation of its set of monads. The set is represented by maximal stretches of monads. For example, if an object consists of the monads { 1, 2, 4, 5, 6, 9, 11, 12 }, and its id_d is 10342, then the following will be in the results of the above example:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d : id_d</th>
<th style="text-align: center;">mse_first : monad_m</th>
<th style="text-align: center;">mse_last : monad_m</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">10342</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">10342</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10342</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;">10342</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">12</td>
</tr>
</tbody>
</table>
<p>The “mse” in “mse_first” and “mse_last” stands for “Monad Set Element.” A monad set element consists of a starting monad and an ending monad (always greater than or equal to the starting monad). It represents all of the monads between the two borders, including the borders. An mse’s last monad is always greater than or equal to its first monad.</p>
<p>The mses in the list are always maximal. That is, there is a gap of at least one monad in between each of the MSEs.</p>
<p>In mathematical terms, suppose we have an MSE A. Then for all other MSEs B for the same object, it is the case that either A.last + 1 &lt; B.first or B.last &lt; A.first - 1</p>
<p>The MSEs will come in no particular order.</p>
<p>See for more information on monad sets and the way Emdros treats them.</p>
<p>It does not matter whether you write “OBJECT” or “OBJECTS”: The choice is merely syntactic sugar.</p>
<p>There is no limit on how many id_ds can be specified. The algorithm will not balk at even many thousand id_ds, but it will, of course, take more time to get the monads of more objects.</p>
<p>This statement was typically used in a series of SELECT OBJECTS HAVING MONADS IN, GET MONADS, and GET FEATURES statements, in order to obtain all information necessary for display of data. This sequence has been wrapped neatly into the GET OBJECTS HAVING MONADS IN statement, which is now the preferred method of doing this sequence.</p>
<h4 id="return-type-22">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d : id_d</th>
<th style="text-align: center;">mse_first : monad_m</th>
<th style="text-align: center;">mse_last : monad_m</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="get-featuressubsecget-features">GET FEATURES<span id="subsec:GET-FEATURES" label="subsec:GET-FEATURES">[subsec:GET-FEATURES]</h3>
<h4 id="syntax-23">Syntax</h4>
<pre><code>get_features_statement : “GET”   

    (“FEATURE” | “FEATURES”)

    feature_list

    “FROM”   (“OBJECT” | “OBJECTS”)

    “WITH” id_ds_specification

    “[”  object_type_name   “]”
;

/*

 * feature_list

 */

feature_list : feature_name   { “,”  feature_name }
;

feature_name : T_IDENTIFIER
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-24">Example</h4>
<pre><code>GET FEATURES surface, psp

FROM OBJECTS WITH ID_DS = 12513,12514

[Word]

GO
</code></pre>
<h4 id="explanation-21">Explanation</h4>
<p>This statement returns a table containing feature-values of certain objects in the database.</p>
<p>Note how this is different from the “SELECT FEATURES” command. The “SELECT FEATURES” command queries an <em>object type</em> for a list of its <em>features</em>. The “GET FEATURES” command queries <em>objects</em> for the <em>values</em> of some of their features.</p>
<p>This statement was typically used in a series of SELECT OBJECTS HAVING MONADS IN, GET MONADS, and GET FEATURES statements, in order to obtain all information necessary for display of data. This sequence has been wrapped neatly into the GET OBJECTS HAVING MONADS IN statement, which is now the preferred method of doing this sequence.</p>
<h4 id="return-type-23">Return type</h4>
<p>The return type is a table with a schema containing one string for each feature in the list of features. The order of the columns is that in the list of features. The first column in the table contains the object id_d involved in the row. Thus for (n) features, the number of columns will be (n+1).</p>
<p>The return type of each feature is the same as the type of the feature. The exact representation depends on whether the output is console output or XML output. For XML, see the DTD. For console output, see the examples below. Enumeration constants are shown as the enumeration constant label, not the integer value.</p>
<p>For list features, the value is a space-surrounded, space-delimited list of values. Integers and ID_Ds are given as integers; enumeration constant values as their constant names (e.g., “first_person”).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d: id_d</th>
<th style="text-align: center;">surface: string</th>
<th style="text-align: center;">psp: enum(psp_t)</th>
<th style="text-align: center;">number_in_corpus : integer</th>
<th style="text-align: center;">parent: id_d</th>
<th style="text-align: center;">parents: list_of_id_d</th>
<th style="text-align: center;">functions : list_of_enum(function_t)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>The table contains the objects in no particular order.</p>
<h3 id="get-set-from-feature">GET SET FROM FEATURE</h3>
<h4 id="syntax-24">Syntax</h4>
<pre><code>get_set_from_feature_statement : “GET”   “SET”

    “FROM”   “FEATURE”

    feature_name

    “[”  object_type_name   “]”
;

feature_name : T_IDENTIFIER
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-25">Example</h4>
<pre><code>GET SET 

FROM FEATURE lexeme

[Word]

GO
</code></pre>
<h4 id="explanation-22">Explanation</h4>
<p>This statement returns a table containing the set of existing feature-values for a feature declared FROM SET. See the CREATE OBJECT TYPE and UPDATE OBJECT TYPE statements on page and respectively for the syntax of the FROM SET declaration.</p>
<p>Note how this is different from GET FEATURES: The “GET FEATURES” command queries <em>objects</em> for the <em>values</em> of some of their features. The GET SET FROM FEATURE queries the <em>set</em> of existing values for a given feature, regardless of which objects have these values for this feature.</p>
<h4 id="return-type-24">Return type</h4>
<p>The return type is a table with a schema containing one string for each value in the set.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">value: string</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>The order of the strings in the table is undefined.</p>
<h3 id="select-min_mselect_min_m">SELECT MIN_M<span id="SELECT_MIN_M" label="SELECT_MIN_M">[SELECT_MIN_M]</h3>
<h4 id="syntax-25">Syntax</h4>
<pre><code>select_min_m_statement : “SELECT”   “MIN_M”
;
</code></pre>
<h4 id="example-26">Example</h4>
<pre><code>SELECT MIN_M

GO
</code></pre>
<h4 id="explanation-23">Explanation</h4>
<p>Returns the minimum monad in use in the database. The table returned has only one data row, namely the minimum monad. See section <a href="#min_m,max_m">[min_m,max_m]</a> for more information.</p>
<h4 id="return-type-25">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">min_m : monad_m</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty.</p>
<h3 id="select-max_mselect_max_m">SELECT MAX_M<span id="SELECT_MAX_M" label="SELECT_MAX_M">[SELECT_MAX_M]</h3>
<h4 id="syntax-26">Syntax</h4>
<pre><code>select_max_m_statement : “SELECT”   “MAX_M”
;
</code></pre>
<h4 id="example-27">Example</h4>
<pre><code>SELECT MAX_M

GO
</code></pre>
<h4 id="explanation-24">Explanation</h4>
<p>Returns the maximum monad in use in the database. The table returned has only one data row, namely the maximum monad. See section <a href="#min_m,max_m">[min_m,max_m]</a> for more information.</p>
<h4 id="return-type-26">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">max_m : monad_m</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty.</p>
<h3 id="select-monad-setssubsecselect-monad-sets">SELECT MONAD SETS<span id="subsec:SELECT-MONAD-SETS" label="subsec:SELECT-MONAD-SETS">[subsec:SELECT-MONAD-SETS]</h3>
<h4 id="syntax-27">Syntax</h4>
<pre><code>select_monad_sets_statement : “SELECT” “MONAD” “SETS”
;
</code></pre>
<h4 id="example-28">Example</h4>
<pre><code>SELECT MONAD SETS GO
</code></pre>
<h4 id="explanation-25">Explanation</h4>
<p>This statement returns a table listing the names of the monad sets stored in the database. These are the monad sets referred to in section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>.</p>
<p>The monad set names come in no particular order.</p>
<h4 id="return-type-27">Return type</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">monad_set_name : string</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="get-monad-setssubsecget-monad-sets">GET MONAD SETS<span id="subsec:GET-MONAD-SETS" label="subsec:GET-MONAD-SETS">[subsec:GET-MONAD-SETS]</h3>
<h4 id="syntax-28">Syntax</h4>
<pre><code>get_monad_sets_statement : “GET” “MONAD” (“SET” | “SETS”)

                          monad_sets_specification
;

monad_sets_specification : “ALL”

  | monad_set_list
;

monad_set_list : monad_set_name { “,” monad_set_name }
;

monad_set_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-29">Example</h4>
<pre><code>GET MONAD SET My_research_collection

GO

GET MONAD SETS Historical_books, Former_prophets

GO

GET MONAD SETS ALL

GO
</code></pre>
<h4 id="explanation-26">Explanation</h4>
<p>This statement returns a table listing the monads of each of the monad sets named in the query. These monad sets are the arbitrary monad sets described in section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>.</p>
<p>It doesn’t matter whether you say “SET” or “SETS”. This is purely syntactic sugar.</p>
<p>If “ALL” is given as the monad_sets_specification, then all monad sets are listed, in no particular order.</p>
<p>In the output, each monad set is represented in the same way as described in section <a href="#GET_MONADS:Explanation">[GET_MONADS:Explanation]</a>. Each monad set is guaranteed to appear in the table in one contiguous stretch, that is, monad sets are not interleaved. Moreover, the monad set elements of each monad set is sorted on mse_first, in ascending order.</p>
<h4 id="return-type-28">Return type</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">monad_set_name : string</th>
<th style="text-align: center;">mse_first : monad_m</th>
<th style="text-align: center;">mse_last : monad_m</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="schema-reflection">Schema reflection</h2>
<p>This section describes those query statements which can be used to retrieve information about the schema.</p>
<h3 id="select-object-types">SELECT OBJECT TYPES</h3>
<h4 id="syntax-29">Syntax</h4>
<pre><code>select_object_types_statement : “SELECT”

    [ “OBJECT” ]    “TYPES”
;
</code></pre>
<h4 id="example-30">Example</h4>
<pre><code>SELECT OBJECT TYPES

GO
</code></pre>
<h4 id="explanation-27">Explanation</h4>
<p>This statement returns a list of the names of all the object types available in the database.</p>
<h4 id="return-type-29">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_type_name: string</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty.</p>
<h3 id="select-features">SELECT FEATURES</h3>
<h4 id="syntax-30">Syntax</h4>
<pre><code>select_features_statement : “SELECT”   “FEATURES”

    “FROM”   [ [ “OBJECT” ]   “TYPE” ]

    “[”   object_type_name   “]”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-31">Example</h4>
<pre><code>SELECT FEATURES

FROM OBJECT TYPE

[Phrase]

GO
</code></pre>
<h4 id="explanation-28">Explanation</h4>
<p>This statement returns a table with the features belonging to the given object type.</p>
<p>The type_name string in the result gives the type of the feature. It has the values as in table <a href="#cap:Possible-type-names">[cap:Possible-type-names]</a>.</p>
<p>The default_value string in the result is a string representation of the default value. It must be interpreted according to the feature type.</p>
<p>The computed boolean in the result shows whether the feature is computed or not. Currently, the only computed features are: “self”, “first_monad”, “last_monad”, “monad_count”, and “monad_set_length”.</p>
<p>For lists, what is shown in the “default value” field is always “()” meaning “the empty list”.</p>
<p>For sets of monads, a string giving the canonical form of an empty set of monads is used: “ {  } ”.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type name</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">integer</td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;">id_d</td>
<td style="text-align: left;">id_d</td>
</tr>
<tr class="odd">
<td style="text-align: left;">list of integer</td>
<td style="text-align: left;">list of integer</td>
</tr>
<tr class="even">
<td style="text-align: left;">list of id_d</td>
<td style="text-align: left;">list of id_d</td>
</tr>
<tr class="odd">
<td style="text-align: left;">list of <em>something else</em></td>
<td style="text-align: left;">list of enumeration constants from the enumeration given</td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">8-bit string of arbitrary length</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ascii</td>
<td style="text-align: left;">7-bit (ASCII) string of arbitrary length</td>
</tr>
<tr class="even">
<td style="text-align: left;">set of monads</td>
<td style="text-align: left;">set of monads</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>everything else</em></td>
<td style="text-align: left;">enumeration by the name given</td>
</tr>
</tbody>
</table>
<p>Possible type names in SELECT FEATURES<span id="cap:Possible-type-names" label="cap:Possible-type-names">[cap:Possible-type-names]</p>
<h4 id="return-type-30">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">feature_name: string</th>
<th style="text-align: center;">type_name: string</th>
<th style="text-align: center;">default_value: string</th>
<th style="text-align: center;">computed: boolean</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty. On success, the table cannot be empty, since every object type has the feature “self”.</p>
<h3 id="select-enumerations">SELECT ENUMERATIONS</h3>
<h4 id="syntax-31">Syntax</h4>
<pre><code>select_enumerations_statement : “SELECT”

    “ENUMERATIONS”
;
</code></pre>
<h4 id="example-32">Example</h4>
<pre><code>SELECT ENUMERATIONS

GO
</code></pre>
<h4 id="explanation-29">Explanation</h4>
<p>This statement returns a table with the names of all the enumerations available in the database.</p>
<h4 id="return-type-31">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">enumeration_name: string</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty. Note, however, that it can also be empty because there are no enumerations in the database yet.</p>
<h3 id="select-enumeration-constants">SELECT ENUMERATION CONSTANTS</h3>
<h4 id="syntax-32">Syntax</h4>
<pre><code>select_enumeration_constants_statement : “SELECT”

    (“ENUM” | “ENUMERATION”)   “CONSTANTS”

    “FROM”    [ (“ENUM” | “ENUMERATION” ) ]

    enumeration_name
;

enumeration_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-33">Example</h4>
<pre><code>SELECT ENUMERATION CONSTANTS

FROM ENUMERATION phrase_types

GO
</code></pre>
<h4 id="explanation-30">Explanation</h4>
<p>This statement returns a table with the enumeration constants in a given enumeration.</p>
<p>Note that the syntax is made so that the query need not be as verbose as in the example just given. There is quite a lot of syntactic sugar[5] in this statement.</p>
<h4 id="return-type-32">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">enum_constant_name: string</th>
<th style="text-align: center;">value : integer</th>
<th style="text-align: center;">is_default : boolean</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty.</p>
<h3 id="select-object-types-using-enumeration">SELECT OBJECT TYPES USING ENUMERATION</h3>
<h4 id="syntax-33">Syntax</h4>
<pre><code>select_object_types_which_use_enum_statement : “SELECT” 

    [ “OBJECT” ]    “TYPES”

    “USING”

    (“ENUM” | “ENUMERATION”) enumeration_name
;

enumeration_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-34">Example</h4>
<pre><code>SELECT OBJECT TYPES

USING ENUMERATION phrase_types_t

GO
</code></pre>
<h4 id="explanation-31">Explanation</h4>
<p>This statement returns a table with the names of the object types which use a given enumeration. The rows of the table are not ordered. An object type uses an enumeration if at least one of its features is of the enumeration type.</p>
<h4 id="return-type-33">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_type_name: string</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On failure, this table is empty. Note, however, that it can also be empty because there are no object types using the enumeration.</p>
<h2 id="object-manipulation">Object manipulation</h2>
<h3 id="create-object-from-monadscreate_object_from_monads">CREATE OBJECT FROM MONADS<span id="CREATE_OBJECT_FROM_MONADS" label="CREATE_OBJECT_FROM_MONADS">[CREATE_OBJECT_FROM_MONADS]</h3>
<h4 id="syntax-34">Syntax</h4>
<pre><code>create_object_from_monads_statement : “CREATE”   “OBJECT”

    “FROM”   monad_specification

    [ with_id_d_specification ]

    object_creation_specification
;

/*

 * monad-specification

 */

monad_specification : “MONADS”   “=”   monad_set
;

/*

 * with-id_d-specification

 */

with_id_d_specification : “WITH”   “ID_D” 

    “=”  id_d_const
;

id_d_const : T_INTEGER

  | “NIL”
;

/*

 * object-creation-specification

 */

object_creation_specification : “[”

    object_type_name

    [ list_of_feature_assignments ]

    “]”
;

object_type_name : T_IDENTIFIER
;

list_of_feature_assignments : feature_assignment    
                              { feature_assignment }
;

feature_assignment : feature_name  “:=”  expression  “;”

    | feature_name  “:=”  list_expression  “;”
;

feature_name : T_IDENTIFIER
;

expression : signed_integer /* integer and id_d */

  | T_STRING

  | T_IDENTIFIER /* enumeration constant */

  | monad_set
;

list_expression : “(“ [list_values] “)”
;

list_values : list_value { “,” list_value }
;

list_value : signed_integer

  | T_IDENTIFIER /* enumeration constant */
;
</code></pre>
<h4 id="example-35">Example</h4>
<pre><code>CREATE OBJECT FROM MONADS = { 1-2, 4-7 }

[Clause

   clause_type := NC;

   parent := 10033;

   descendants := (104546, 104547, 104549);

]

GO   
   
CREATE OBJECTS FROM MONADS = { 35-37 }

WITH ID_D = 104546

[Phrase

   phrase_type := NP;

   parents := (104212, 104215, 104219);

]

GO
</code></pre>
<h4 id="explanation-32">Explanation</h4>
<p>This statement creates a new object from a specified set of monads.</p>
<p>In creating an object, four items of information are necessary:</p>
<ol>
<li><p>The new id_d,</p></li>
<li><p>The object type,</p></li>
<li><p>The set of monads,</p></li>
<li><p>Any features that need non-default values.</p></li>
</ol>
<p>This statement creates an object of type “<code>object_type_name</code>” using the monads and features, and optional id_d, given. All features not specified will be given default values.</p>
<p>If you specify an id_d with the “WITH ID_D” specification, the system first checks whether that object id_d is already in use. If it is, the creation fails. If it is not, that id_d is used. If you do not specify an id_d, a unique id_d is auto-generated.</p>
<p>Note that when using WITH ID_D, it is not recommended to run several concurrent processes against the same database which issue CREATE OBJECT or CREATE OBJECTS statements. Doing so may cause the auto-generated object id_d sequence to become invalid. However, several concurrent processes may safely issue CREATE OBJECT(S) statements if none of them use WITH ID_D.</p>
<p>Note that objects of the special object types all_m, any_m, and pow_m cannot be created.</p>
<h4 id="return-type-34">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d: id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On success, there is always only one row in the table, namely the row containing the object id_d of the newly created object.</p>
<p>On failure, the table is empty.</p>
<h3 id="create-object-from-id_dscreate_obejct_from_id_ds">CREATE OBJECT FROM ID_DS<span id="CREATE_OBEJCT_FROM_ID_DS" label="CREATE_OBEJCT_FROM_ID_DS">[CREATE_OBEJCT_FROM_ID_DS]</h3>
<h4 id="syntax-35">Syntax</h4>
<pre><code>create_object_from_id_ds_statement : “CREATE”   “OBJECT”

    “FROM”   id_ds_specification

    [ with_id_d_specification ]

    object_creation_specification
;

/*

 * id_ds-specification

 */

id_ds_specification : (“ID_D” | “ID_DS”) 

    “=”   id_d_list
;

id_d_list : id_d   { “,”  id_d }
;

id_d : id_d_const
;

id_d_const : T_INTEGER

  | “NIL”
;
</code></pre>
<h4 id="example-36">Example</h4>
<pre><code>CREATE OBJECT FROM ID_DS = 10028, 10029

[Clause

   clause_type := NC;

   parent := 10033;

]

GO
</code></pre>
<h4 id="explanation-33">Explanation</h4>
<p>This statement creates a new object with the monads contained in the objects specified by their id_ds.</p>
<p>The id_ds specified are used only to calculate the set of monads to be used. This is calculated as the union of the set of monads of the objects with the id_ds specified. These id_ds can point to objects of any type, and it need not be the same type for all id_ds.</p>
<p>Note that there is a syntactic sugar-choice of whether to say “ID_DS” or “ID_D”.</p>
<p>Note that objects of the special object types all_m, any_m, and pow_m cannot be created.</p>
<p>See the “CREATE OBJECT FROM MONADS” (section <a href="#CREATE_OBJECT_FROM_MONADS">[CREATE_OBJECT_FROM_MONADS]</a> on page ) for further explanation and warnings. Especially about concurrent use of WITH ID_D.</p>
<h4 id="return-type-35">Return type</h4>
<p>The return type is the same as for CREATE OBJECT FROM MONADS (section <a href="#CREATE_OBJECT_FROM_MONADS">[CREATE_OBJECT_FROM_MONADS]</a>).</p>
<h3 id="create-objects-with-object-type">CREATE OBJECTS WITH OBJECT TYPE</h3>
<h4 id="syntax-36">Syntax</h4>
<pre><code>create_objects_statement : “CREATE”  “OBJECTS”

                           “WITH”  “OBJECT” “TYPE”

                           “[”  object_type_name  “]”

                           object_creation_list 
;   
   
object_creation_list : object_creation { object_creation }
;   
   
object_creation : “CREATE”  “OBJECT”

                  “FROM”  monad_specification

                  [ with_id_d_specification ]

                  “[” 

                  [ list_of_feature_assignments ] 

                  “]” 
; 
</code></pre>
<h4 id="example-37">Example</h4>
<pre><code>CREATE OBJECTS

WITH OBJECT TYPE [Phrase]

CREATE OBJECT

FROM MONADS = { 1-2 }

[ 

  phrase_type := NP; 

  function := Subj;

]

CREATE OBJECT

FROM MONADS = { 3-7 }

[

  // Use default values for phrase_type and function

  // (probably VP/Pred in this fictive example)

] 

CREATE OBJECT

FROM MONADS = { 4-7 }

WITH ID_D = 1000000 // Assign specific ID_D

[

  phrase_type := NP;

  function := Objc;

]

GO
</code></pre>
<h4 id="explanation-34">Explanation</h4>
<p>This statement is for batch importing of objects. It is useful when populating databases, either from scratch or by adding large numbers of objects to an existing database. This statement is much faster than individual CREATE OBJECT statements.</p>
<p>The object type is specified only once, at the top. Note that no features can be assigned where the object type is specified: That comes later in the query, when each object is created.</p>
<p>Each object to be created must be given a monad set. The monad set follows the syntax specified in section <a href="#SELECT_OBJECTS">[SELECT_OBJECTS]</a>.</p>
<p>Optionally, an id_d can be specified. If an id_d is specified, it is the user’s responsibility to ensure that the id_d assigned does not clash with another id_d in the database. This is mainly useful when dumping/restoring databases.</p>
<p>If no id_d is specified, a unique id_d is generated. This id_d is only guaranteed to be unique if no other objects are created with specific id_ds.</p>
<p>Note that when using WITH ID_D, it is not recommended to run several concurrent processes against the same database which issue CREATE OBJECT or CREATE OBJECTS statements. Doing so may cause the auto-generated object id_d sequence to become invalid. However, several concurrent processes may safely issue CREATE OBJECT(S) statements if none of them use WITH ID_D.</p>
<p>The feature-value assignments follow the same rules as for CREATE OBJECT FROM MONADS (see section <a href="#CREATE_OBJECT_FROM_MONADS">[CREATE_OBJECT_FROM_MONADS]</a>). If an object has a feature which is not assigned a value, the default value is used. The default value of a given feature can be specified when creating the object type, or when updating the object type (see section <a href="#CREATE_OBJECT_TYPE">[CREATE_OBJECT_TYPE]</a> and section <a href="#UPDATE_OBJECT_TYPE">[UPDATE_OBJECT_TYPE]</a>).</p>
<p>A table is returned showing the number of objects created successfully. This number is valid even if the process failed half way through. In other words, if the process did not run to completion due to a DB error, the value in the return type will show how many objects, if any, were created successfully. This means that there is no way of knowing which object got which object id_d, a difference from the regular CREATE OBJECT statement.</p>
<h4 id="return-type-36">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_count: integer</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On both success and failure, the table contains one row showing the number of objects created successfully.</p>
<h3 id="update-objects-by-monadsupdate_objects_by_monads">UPDATE OBJECTS BY MONADS<span id="UPDATE_OBJECTS_BY_MONADS" label="UPDATE_OBJECTS_BY_MONADS">[UPDATE_OBJECTS_BY_MONADS]</h3>
<h4 id="syntax-37">Syntax</h4>
<pre><code>update_objects_by_monads_statement : “UPDATE” 

    (“OBJECT” | “OBJECTS”)

    “BY”   monad_specification 

    object_update_specification
;

/*

 * object-update-specification

 */

object_update_specification : “[“   object_type_name 

    list_of_feature_assignments

    “]”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-38">Example</h4>
<pre><code>UPDATE OBJECTS BY MONADS = { 1-2, 4-7, 8-20 }

[Clause

    clause_type := VC;

]

GO
</code></pre>
<h4 id="explanation-35">Explanation</h4>
<p>This statement finds all the objects of type <code>object_type_name</code> which are part_of the monads specified (i.e., they must be wholly contained within the monads specified), and updates their features according to the list of feature assignments.</p>
<p>Note that there is a syntactic sugar-choice of whether to say “OBJECTS” or “OBJECT”. This is because the user may know that only one object is to be found within the monads, in which case having to write “OBJECTS” would be intellectually irritating.</p>
<p>Note that objects of the special object types all_m, any_m, and pow_m cannot be updated.</p>
<p>The feature “self” cannot be updated.</p>
<h4 id="return-type-37">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d: id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On success, the table contains one row for each updated object.</p>
<p>On failure, the table is empty.</p>
<h3 id="update-objects-by-id_ds">UPDATE OBJECTS BY ID_DS</h3>
<h4 id="syntax-38">Syntax</h4>
<pre><code>update_objects_by_id_ds_statement : “UPDATE” 

    (“OBJECT” | “OBJECTS”)

    “BY”   id_ds_specification 

    object_update_specification
;
</code></pre>
<h4 id="example-39">Example</h4>
<pre><code>UPDATE OBJECTS BY ID_DS = 10028, 10029

[Phrase

    parent := 10034;

]

GO
</code></pre>
<h4 id="explanation-36">Explanation</h4>
<p>This statement updates all the objects of the given type with the given id_ds.</p>
<p>The id_ds should point to objects which are really of the given type. Otherwise, an error is issued.</p>
<p>Note that there is a syntactic sugar-choice between “OBJECTS” and “OBJECT.”</p>
<p>Note that objects of the special object types all_m, any_m, and pow_m cannot be updated.</p>
<p>The feature “self” cannot be updated.</p>
<h4 id="return-type-38">Return type</h4>
<p>The return type is the same as for UPDATE OBJECTS BY MONADS (section <a href="#UPDATE_OBJECTS_BY_MONADS">[UPDATE_OBJECTS_BY_MONADS]</a>).</p>
<h3 id="delete-objects-by-monadsdelete_objects_with_monads">DELETE OBJECTS BY MONADS<span id="DELETE_OBJECTS_WITH_MONADS" label="DELETE_OBJECTS_WITH_MONADS">[DELETE_OBJECTS_WITH_MONADS]</h3>
<h4 id="syntax-39">Syntax</h4>
<pre><code>delete_objects_by_monads_statement : “DELETE”

    (“OBJECT” | “OBJECTS”)

    “BY”   monad_specification

    object_deletion_specification
;

/*

 * object-deletion-specification

 */

object_deletion_specification : “[”

    object_type_name_to_delete

    “]”
;

object_type_name_to_delete : object_type_name 

  | “ALL”
;

object_type_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-40">Example</h4>
<pre><code>DELETE OBJECTS BY MONADS = { 1-20 }

[Clause]

GO
</code></pre>
<p>If “<code>object_name_to_delete</code>” is “ALL”, then all objects of all types which are at these monads are deleted:</p>
<pre><code>DELETE OBJECTS BY MONADS = { 28901-52650 }

[ALL]

GO
</code></pre>
<h4 id="explanation-37">Explanation</h4>
<p>This command deletes all the objects of type <code>object_type_name</code> which are part_of the set of monads specified.</p>
<h4 id="return-type-39">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">object_id_d: id_d</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>On success, the table contains one row for each deleted object.</p>
<p>On failure, the table is empty.</p>
<h3 id="delete-objects-by-id_ds">DELETE OBJECTS BY ID_DS</h3>
<h4 id="syntax-40">Syntax</h4>
<pre><code>delete_objects_by_id_ds_statement : “DELETE”

    (“OBJECT” | “OBJECTS”)

    “BY”   id_ds_specification

    object_deletion_specification
;
</code></pre>
<h4 id="example-41">Example</h4>
<pre><code>DELETE OBJECTS BY ID_DS 10028, 10029

[Phrase]

GO
</code></pre>
<h4 id="explanation-38">Explanation</h4>
<p>This statement deletes objects by their id_ds. Note that you cannot write “ALL” for <code>object_deletion_specification</code>. The id_ds given should point to objects of the type given.</p>
<h4 id="return-type-40">Return type</h4>
<p>The return type is the same as for DELETE OBJECTS BY MONADS (section <a href="#DELETE_OBJECTS_WITH_MONADS">[DELETE_OBJECTS_WITH_MONADS]</a>).</p>
<h2 id="monad-manipulation">Monad manipulation</h2>
<h3 id="monad-set-calculationmonad-set-calculation">MONAD SET CALCULATION<span id="MONAD-SET-CALCULATION" label="MONAD-SET-CALCULATION">[MONAD-SET-CALCULATION]</h3>
<h4 id="syntax-41">Syntax</h4>
<pre><code>monad_set_calculation_statement : “MONAD”  “SET”

    “CALCULATION”

    monad_set_chain
;

monad_set_chain : monad_set    
                  { monad_set_operator  monad_set }
;

monad_set_operator : “UNION”

  | “DIFFERENCE”

  | “INTERSECT”
;
</code></pre>
<h4 id="example-42">Example</h4>
<pre><code>// Produces { 1-10 }

MONAD SET CALCULATION

{ 1-5, 7-8 }

UNION

{ 5-10 }

GO   
   
// Produces { 2-5, 22-24 }

MONAD SET CALCULATION

{ 1-10, 20-30, 50-60 }

INTERSECT

{ 2-5, 22-24 }

GO   
   
// Produces { 1-4, 8-10 }

MONAD SET CALCULATION

{ 1-10 }

DIFFERENCE

{ 5-7 }

GO   
   
// Produces { 2-3, 5-6, 10-12 }

MONAD SET CALCULATION

{ 1-3, 5-9 }

INTERSECT

{ 2-6 }

UNION

{ 10-12 }

GO
</code></pre>
<h4 id="explanation-39">Explanation</h4>
<p>This statement is for performing set-operations on sets of monads. The three standard set operations “union,” “intersect,” and “difference” are provided.</p>
<p>The return value is a representation of the resulting set of monads along the same lines as for the GET MONADS statement (see section <a href="#Section:GET%20MONADS">[Section:GET MONADS]</a>).</p>
<p>The MSEs (see section <a href="#Section:GET%20MONADS">[Section:GET MONADS]</a>) are listed in ascending order.</p>
<p>You can specify as many sets of monads as you want. The operations are done in succession from the first to the last set of monads. For example, in the last example above, the intersection is done first, and the union is done on the result of the intersection.</p>
<p>You can also specify only one set of monads, with no set operator. This is useful for creating a sorted, normalized set of monads from a number of different MSEs.</p>
<p>Note that this statement does not manipulate the stored arbitrary monad sets described in section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>.</p>
<h4 id="return-type-41">Return type</h4>
<p>A table with the following schema:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">mse_first : monad_m</th>
<th style="text-align: center;">mse_last : monad_m</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="create-monad-setcreate-monad-set">CREATE MONAD SET<span id="CREATE-MONAD-SET" label="CREATE-MONAD-SET">[CREATE-MONAD-SET]</h3>
<h4 id="syntax-42">Syntax</h4>
<pre><code>create_monad_set_statement : “CREATE” “MONAD” “SET”

            monad_set_name

            “WITH” “MONADS” “=” monad_set
;

monad_set_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-43">Example</h4>
<pre><code>CREATE MONAD SET

My_research_collection

WITH MONADS = { 1-10394, 14524-29342, 309240-311925 }

GO
</code></pre>
<h4 id="explanation-40">Explanation</h4>
<p>This statement creates an arbitrary monad set in the database. These monad sets are the ones described in section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>.</p>
<h4 id="return-type-42">Return type</h4>
<p>There is no return value.</p>
<h3 id="update-monad-setupdate-monad-set">UPDATE MONAD SET<span id="UPDATE-MONAD-SET" label="UPDATE-MONAD-SET">[UPDATE-MONAD-SET]</h3>
<h4 id="syntax-43">Syntax</h4>
<pre><code>update_monad_set_statement : “UPDATE” “MONAD” “SET”

     monad_set_name

     (“UNION” | “INTERSECT” | “DIFFERENCE” | “REPLACE”)

     (monad_set | monad_set_name)
;

monad_set_name : T_IDENTIFIER
;
</code></pre>
<h4 id="examples-2">Examples</h4>
<pre><code>// Adds the specified monad set to “Historical_books”

UPDATE MONAD SET

Historical_books

UNION

{ 310320-329457 }

GO

// Remove the specified monad set from “Historical_books”

UPDATE MONAD SET

Historical_books

DIFFERENCE

{ 310320-329457 }

GO

// Intersects the monad set “My_research_collection”

// with the monad set “My_experimental_collection”

UPDATE MONAD SET

My_research_collection

INTERSECT

My_experimental_collection

GO

// Replaces the monad set “Lamentations” with 

// the specified monad set

UPDATE MONAD SET

Lamentations

REPLACE

{ 380300-383840 }

GO
</code></pre>
<h4 id="explanation-41">Explanation</h4>
<p>This statement is used to update an already-existing arbitrary monad set (see section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>). Four operations are provided: set union, set intersection, set difference, and replacement. In all cases, the operation is done using two monad sets. The first set is the named set that is updated. The second set is either a set described in terms of monads, or the name of another arbitrary monad set.</p>
<p>The replacement operator effectively deletes the old set, replacing it with the new. Note, however, that this does not imply that the new is deleted – if you update one named monad set, replacing it with another named monad set, that other monad set is not deleted, but simply copied into the old monad set.</p>
<p>The other three operators are standard set-theoretic operators.</p>
<h4 id="return-type-43">Return type</h4>
<p>There is no return value.</p>
<h3 id="drop-monad-setdrop-monad-set">DROP MONAD SET<span id="DROP-MONAD-SET" label="DROP-MONAD-SET">[DROP-MONAD-SET]</h3>
<h4 id="syntax-44">Syntax</h4>
<pre><code>drop_monad_set_statement : “DROP” “MONAD” “SET”

                           monad_set_name
;

monad_set_name : T_IDENTIFIER
;
</code></pre>
<h4 id="example-44">Example</h4>
<pre><code>DROP MONAD SET Historical_books

GO
</code></pre>
<h4 id="explanation-42">Explanation</h4>
<p>This statement drops an arbitrary monad set (i.e., deletes it) from the database. These are the arbitrary monad sets described in section <a href="#subsec:Arbitrary-monad-sets">[subsec:Arbitrary-monad-sets]</a>.</p>
<h4 id="return-type-44">Return type</h4>
<p>There is no return value.</p>
<h2 id="meta-statements">Meta-statements</h2>
<h3 id="quit">QUIT</h3>
<h4 id="syntax-45">Syntax</h4>
<pre><code>quit_statement : “QUIT”
;
</code></pre>
<h4 id="example-45">Example</h4>
<pre><code>QUIT
</code></pre>
<h4 id="explanation-43">Explanation</h4>
<p>This causes the rest of the MQL stream not to be interpreted. It also causes the mql(1) program to quit after having executed this statement.</p>
<p>The QUIT statement can be used, e.g., if running the mql(1) program as a daemon through xinetd(8) or inetd(8), to end the connection.</p>
<p>The QUIT statement is special in that it does not need a “GO” keyword after it. You may supply the “GO” keyword if you wish, but it is not required.</p>
<p>If a transaction was in progress (see BEGIN TRANSACTION statement, section <a href="#subsec:BEGIN-TRANSACTION">[subsec:BEGIN-TRANSACTION]</a>), the transaction is automatically committed before the QUIT statement is executed.</p>
<h4 id="return-type-45">Return type</h4>
<p>There is no return value.</p>
<h1 id="mql-query-subsetchaptermql-query-subset">MQL Query subset<span id="chapter:MQL Query Subset" label="chapter:MQL Query Subset">[chapter:MQL Query Subset]</h1>
<h2 id="introduction-7">Introduction</h2>
<p>This chapter is an introduction to the query-subset of MQL for programmers. That is, it introduces the important subset of MQL in which you can express queries that find objects and gaps in interesting environments, with specified interrelations, and with specified feature-values.</p>
<p>An easier-to-read MQL Query Guide is available from the Emdros website, or with the Emdros sourcecode in the doc/ directory (see ).</p>
<p>First, we give an informal introduction to MQL by means of some examples (<a href="#sec:Informal-introduction-to">[sec:Informal-introduction-to]</a>). Then we give a complete overview of the syntax of the MQL query-subset (<a href="#mql_query:Syntax">3</a>). Then we explain the sheaf, which is the data-structure that an MQL query-query returns (<a href="#sheaf">[sheaf]</a>). Then we explain what a Universe and a Substrate are, since they are important in understanding how a query works (<a href="#sec:Universe-and-substrate">[sec:Universe-and-substrate]</a>). After that, we explain two important properties of mql queries, namely consecutiveness and embedding (<a href="#mql-query:Consecutiveness-and-embedding">[mql-query:Consecutiveness-and-embedding]</a>). After that, we give detailed explanations of the blocks of the MQL query-subset, which are the “building blocks” out of which a query is made (<a href="#Blocks">[Blocks]</a>). Finally, we explain how strings of blocks are written, and what they mean (<a href="#sec:Strings-of-blocks">[sec:Strings-of-blocks]</a>).</p>
<h2 id="informal-introduction-to-mql-by-means-of-some-examplessecinformal-introduction-to">Informal introduction to MQL by means of some examples<span id="sec:Informal-introduction-to" label="sec:Informal-introduction-to">[sec:Informal-introduction-to]</h2>
<h3 id="introduction-8">Introduction</h3>
<p>This section informally introduces the query-part of MQL by way of a number of examples. The example database which we will use is the same as in Doedens’ book, namely part of Melville’s “Moby Dick”:</p>
<blockquote>
<p>“CALL me Ishmael. Some years ago - never mind how long precisely - having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world. It is a way I have of driving off the spleen, and regulating the circulation. Whenever I find myself growing grim about the mouth; whenever it is damp, drizzly November in my soul; whenever I find myself involuntarily pausing before coffin warehouses, and bringing up the rear of every funeral I meet; and especially whenever my hypos get such an upper hand of me, that it requires a strong moral principle to prevent me from deliberately stepping into the street, and methodically knocking people’s hats off</p>
<ul>
<li>then, I account it high time to get to sea as soon as I can. [...]</li>
</ul>
<p>“[...] By reason of these things, then, the whaling voyage was welcome; the great flood-gates of the wonder-world swung open, and in the wild conceits that swayed me to my purpose, two and two there floated into my inmost soul, endless processions of the whale, and, mid most of them all, one grand hoofed phantom, like a snow hill in the air.”</p>
</blockquote>
<p>Suppose that we have in this EMdF database the domain-dependent object types “paragraph”, “sentence”, and “word”, which correspond to paragraphs, sentences, and words of the text. And suppose that we add to the object type “sentence” the feature “mood,” which draws its values from the enumeration type { imperative, declarative }. And suppose that we add to the object type “word” the features “surface” (which gives the surface text of the word) and “part_of_speech” (which gives the part of speech of the word). The codomain of the feature “part_of_speech” on the object type “word” draws its values from the enumeration type { adjective, adverb, conjunction, determiner, noun, numeral, particle, preposition, pronoun, verb }. This hypothetical database will give the background for most of the examples in our informal introduction to MQL.</p>
<p>In the following, when we refer to an “MQL query”, we will mean the query-subset of MQL. That is, we abstract away from the database-manipulation-part of MQL and concentrate on the query-queries. In addition, we will abstract away from the required “SELECT (FOCUS|ALL) OBJECTS” syntax that must precede an MQL query-query.</p>
<h3 id="topograph">topograph</h3>
<p>An MQL query is called a topograph. Consider the following topograph:</p>
<pre><code>[sentence]
</code></pre>
<p>This topograph retrieves a list of all sentence objects in the database.</p>
<h3 id="features-1">features</h3>
<p>A query can specify which features an object must have for it to be retrieved. For example, consider the following topograph:</p>
<pre><code>[word

   surface = Ishmael or part_of_speech = verb;

]
</code></pre>
<p>This topograph retrieves a list of all words which either have the surface “Ishmael”, or whose part of speech is “verb.”</p>
<h3 id="object_block-object_block_first">object_block, object_block_first</h3>
<p>There are several types of blocks. They are meant to come in a string of blocks, where each block in the string must match some part of the database in order for the whole string to match. Two such blocks are the <code>object_block</code> and the <code>object_block_first</code>.</p>
<p>Object blocks are the heart and soul of MQL queries. They are used to match objects and objects nested in other objects. An object block (be it an <code>object_block</code> or an <code>object_block_first</code>) consists of the following parts:</p>
<ol>
<li><p>The opening square bracket, ‘<code>[</code>’.</p></li>
<li><p>An identifier indicating the object type of the objects which we wish to match (e.g., “phrase”).</p></li>
<li><p>An optional T_MARKS (e.g., “‘yellow’’ or “‘red‘context’’). This will be put into the result set (i.e., sheaf) unchanged, and can be used to pass information back into the application from the user. The meaning of the T_MARKS is wholly application-dependent, since Emdros does nothing special with it — it just passes the T_MARKS on into the sheaf. See page for the formal definition of T_MARKS.</p></li>
<li><p>An optional “object reference declaration.” A reference to this object can be declared with the “<code>as</code>” keyword, like “<code>[word as w</code> (\ldots)”. Subsequent blocks can then refer to features of this object as “<code>w</code>.<em>featurename</em>” (see section <a href="#Object%20references">[Object references]</a>).</p></li>
<li><p>An optional keyword which can be either of “<code>noretrieve</code>”, “<code>retrieve</code>” or “<code>focus</code>”. The default, when it is not specified, is “<code>retrieve</code>”. The keyword “<code>noretrieve</code>” says as much as “I do not wish to retrieve this object, even if matched”. It is useful for specifying the context of what we really wish to retrieve. The keyword “<code>focus</code>” specifies that this object is to be retrieved (it implies “<code>retrieve</code>”), and also that, when sifting the sheaf for focus objects, this object must go into the result (see section <a href="#Retrieval">[Retrieval]</a>).</p></li>
<li><p>An optional keyword, “<code>first</code>” or “<code>last</code>”, which says as much as “this object must be first/last in the universe against which we are matching (see section <a href="#First%20and%20last">[First and last]</a>).</p></li>
<li><p>An optional Boolean expression giving what features need to hold true for this object for it to be retrieved (see section <a href="#Feature%20specifications">[Feature specifications]</a>). This boolean expression must be prefixed by one of the words “<code>feature</code>” or “<code>features</code>”. It makes no difference which is used – it is merely syntactic sugar.</p></li>
<li><p>An optional inner <code>blocks</code> which matches objects inside the object (see section <a href="#Block%20strings:%20blocks">[Block strings: blocks]</a>).</p></li>
<li><p>The closing square bracket, ‘<code>]</code>’.</p></li>
</ol>
<p>Note that only the first object block in a string of blocks can have the “<code>first</code>” keyword, and only the last <code>object_block</code> in a string of <code>block</code>s can have the “<code>last</code>” keyword.</p>
<p>Consider the following <code>topograph</code>:</p>
<pre><code>[sentence‘yellow

    mood = imperative;

    [word noretrieve first

         surface = CALL;

    ]

    [word‘red]

]
</code></pre>
<p>This <code>topograph</code> retrieves the set of sentences which are imperative, and whose first word is “CALL”. Within each sentence in that set, we retrieve the second word, but not the first. The only sentence in our example database which qualifies is the first sentence.</p>
<h3 id="power">power</h3>
<p>The power construct is used to indicate that we allow some distance in between two blocks. A power construct must always stand between two other blocks, and can thus never be first or last in a query. It comes in three varieties:</p>
<ul>
<li><p>A “plain vanilla” power construct, syntactically denoted by two dots, “<code>..</code>”, and</p></li>
<li><p>A power construct with a single, upper limit. The limit specifies the maximum monads that can intervene between the two surrounding blocks. It is denoted as e.g., “<code>.. &lt; 5</code>”, or “<code>.. &lt;= 5</code>”.</p></li>
<li><p>A power construct with a compound min/max limit. The limit specifies the minimum and maximum monads that can intervene. It is denoted as, e.g., “<code>.. BETWEEN 1 AND 5</code>”.</p></li>
</ul>
<p>Consider the following topograph:</p>
<pre><code>[sentence

    [word

        part_of_speech = preposition]

    .. \&lt; 4

    [word

        part_of_speech = noun]

    ..

    [word last

        surface = world

]
</code></pre>
<p>This topograph retrieves a list of sentences which have a word that has part of speech preposition, followed by a word which has part of speech noun, and which is within 4 monads of the preposition, followed by the last word of the sentence, which must be “world”. Within that sentence, retrieve all the three words. The only sentence which qualifies is the second.</p>
<h3 id="opt_gap_block">opt_gap_block</h3>
<p>An <code>opt_gap_block</code> is used to match an optional gap in the text. It consists of:</p>
<ol>
<li><p>The opening square bracket, ‘<code>[</code>’.</p></li>
<li><p>The keyword “<code>gap?</code>”.</p></li>
<li><p>An optional T_MARKS (e.g., “‘yellow’’ or “‘red‘context’’). This will be put into the result set (i.e., sheaf) unchanged, and can be used to pass information back into the application from the user. The meaning of the T_MARKS is wholly application-dependent, since Emdros does nothing special with it — it just passes the T_MARKS on into the sheaf. See page for the formal definition of T_MARKS.</p></li>
<li><p>An optional “<code>noretrieve</code>,” “<code>retrieve</code>” or “<code>focus</code>.” The default is “<code>noretrieve</code>”. (See section <a href="#Retrieval">[Retrieval]</a>)</p></li>
<li><p>An optional <code>blocks</code> (see section <a href="#Block%20strings:%20blocks">[Block strings: blocks]</a>).</p></li>
<li><p>The closing square bracket, ‘<code>]</code>’.</p></li>
</ol>
<p>The <code>opt_gap_block</code> matches gaps in the <em>substrate</em> against which we are matching. Thus if we look at the example in figure <a href="#TheDoor">[TheDoor]</a>, we can construct the following topograph:</p>
<pre><code>[clause

    [clause_atom

        [word

             surface = door,

        ]

    ]

    [gap? noretrieve]

    [clause_atom noretrieve]

]
</code></pre>
<p>This retrieves all clauses which happen to have inside them a clause_atom which contains the word “door,”, followed by a gap, followed by a clause_atom. The gap and the second clause_atom are not retrieved. This would retrieve clause-1. The gap need not be there.</p>
<p>The default is for the result of an <code>opt_gap_block</code> not to be retrieved. Thus one needs to explicitly write “<code>retrieve</code>” if one wishes to retrieve the gap.</p>
<h3 id="gap_block">gap_block</h3>
<p>A <code>gap_block</code> is used to match a gap in the text. It consists of:</p>
<ol>
<li><p>The opening square bracket, ‘<code>[</code>’.</p></li>
<li><p>The keyword “<code>gap</code>”.</p></li>
<li><p>An optional T_MARKS (e.g., “‘yellow’’ or “‘red‘context’’). This will be put into the result set (i.e., sheaf) unchanged, and can be used to pass information back into the application from the user. The meaning of the T_MARKS is wholly application-dependent, since Emdros does nothing special with it — it just passes the T_MARKS on into the sheaf. See page for the formal definition of T_MARKS.</p></li>
<li><p>An optional “<code>noretrieve</code>,” “<code>retrieve</code>” or “<code>focus</code>.” The default is “<code>noretrieve</code>”. (See section <a href="#Retrieval">[Retrieval]</a>).</p></li>
<li><p>An optional <code>blocks</code>. (See section <a href="#Block%20strings:%20blocks">[Block strings: blocks]</a>).</p></li>
<li><p>The closing square bracket, ‘<code>]</code>’.</p></li>
</ol>
<p>The <code>gap_block</code> is analogous to the <code>opt_gap_block</code> in all respects except that there <em>must</em> be a gap in order for the query to match.</p>
<h3 id="object-references">object references</h3>
<p>An object reference is a name given to a previously retrieved object with the “<code>as</code> <em>identifier</em>” declaration. An object reference can then be used in subsequent comparisons with features of other objects. This is done by selecting the desired feature from the object reference by using dot-notation, as in the example below:</p>
<pre><code>[word as w

    part_of_speech = article;

]

[word‘myhit

   (part_of_speech = noun 

    or part_of_speech = adjective)

    and case = w.case 

    and number = w.number 

    and gender = w.gender;

]
</code></pre>
<p>Assuming that the <code>word</code> object type has features part_of_speech, case, number, and gender, this topograph retrieves all pairs of words which satisfy the following conditions:</p>
<ul>
<li><p>The first word has part of speech “article”,</p></li>
<li><p>The second word has part of speech “noun” or “adjective”, and</p></li>
<li><p>Both words have the same case, number, and gender.</p></li>
</ul>
<p>This concludes our gentle, informal introduction to MQL.</p>
<h2 id="syntax-of-mql_query">Syntax of mql_query</h2>
<h3 id="introduction-9">Introduction</h3>
<p>The <code>mql_query</code> non-terminal is the entry-point for the MQL query-subset. It is used in the WHERE clause of the SELECT (FOCUS|ALL) OBJECTS statement (section <a href="#SELECT_OBJECTS">[SELECT_OBJECTS]</a> on page ). In this section, we give the full grammar of the MQL query-subset. It is important that you take some time to read through the grammar. Subsequent sections will build on the bird’s-eye view given in this section.</p>
<h3 id="syntax-46">Syntax</h3>
<pre><code>mql_query : topograph
; 

topograph : blocks 
;

blocks : block_string
;

block_string : block_string2 

             | block_string2 “OR” block_string
;

block_string2 : block_string1

              | block_string1 block_string2

              | block_string1 “\!” block_string2
;

block_string1 : block_string0

              | block_string0 “*” [monad_set]
;

block_string0 : block

              | “[“ block_string “]”
;

block : opt_gap_block 

      | gap_block 

      | power_block

      | object_block

      | (“NOTEXIST” | “NOTEXISTS” ) object_block
;

opt_gap_block : “[”   “GAP?”   

                      [ marks_declaration ]

                      [ gap_retrieval ]   

                      [ blocks ]  

                “]” 
;

marks_declaration : T_MARKS
;

gap_retrieval : “NORETRIEVE”

              | “RETRIEVE”

              | “FOCUS”
;

gap_block : “[”   “GAP”   

                  [ marks_declaration ]

                  [ gap_retrieval ]   

                  [ blocks ]   

            “]”
;

object_block :  “[”   object_type_name

                     [ marks_declaration ]

                     [ object_reference_declaration ]

                     [ retrieval ]  

                     [ firstlast ]

                     [ monad_set_relation_clause ]

                     [ feature_constraints ]

                     [ feature_retrieval ]

                     [ blocks ]   

               “]”
;

object_reference_declaration : “AS” object_reference 
;

object_reference : T_IDENTIFIER 
;

retrieval : “NORETRIEVE”

          | “RETRIEVE”

          | “FOCUS”
;

firstlast : “FIRST”

          | “LAST”

          | “FIRST”   “AND”   “LAST”
;

feature_constraints  : ffeatures 
;

ffeatures : fterm 

          |  ffeatures   “OR”   fterm 
;

fterm : ffactor

      | ffactor   “AND”   fterm 
;

ffactor : “NOT”   ffactor

        | “(”   ffeatures   “)”

        | feature_comparison 
;

feature_comparison : 

    comparison_feature_name  comparison_operator   value

  | comparison_feature_name  “=”   ()

  | comparison_feature_name  “=”   enum_const_set

  | comparison_feature_name  “=”   “(“ list_of_integer “)”

  | comparison_feature_name  “IN”   enum_const_set

  | comparison_feature_name  “IN”   “(“ list_of_integer “)”

  | comparison_feature_name  “IN”   object_reference_usage
;

comparison_operator : “=”

                    | “\&lt;”

                    | “\&gt;”

                    | “\&lt;\&gt;”  /* not equal */

                    | “\&lt;=”  /* less than or equal */

                    | “=\&lt;”  /* less than or equal */

                    | “\&gt;=”  /* greater than or equal */

                    | “=\&gt;”  /* greater than or equal */

                    | “ ”   /* regular expression */

                    | “\! ”  /* inverted regular expression */

                    | “HAS” /* lhs: list; rhs: atomic value.

                                 signifies list membership. */
;

list_of_integer : T_INTEGER { “,” T_INTEGER }*
;

value : enum_const

      | signed_integer

      | T_STRING

      | object_reference_usage
;

enum_const : T_IDENTIFIER
;

object_reference_usage : object_reference   

                         “.”   feature_name 
;

enum_const_set : “(“ enum_const_list “)”
;

enum_const_list : enum_const { “,” enum_const_list }
;

power : “..”   [ restrictor ]
;

restrictor : “\&lt;” limit 

           | “\&lt;=” limit

           | “BETWEEN” limit “AND” limit
;

limit : T_INTEGER /* non-negative integer, may be 0. */
; 

feature_retrieval : “GET” feature_list

  | /* empty: Don’t retrieve any features */
;

monad_set_relation_clause : /* empty; which means: part_of(substrate) */

           | monad_set_relation_operation “(“ universe_or_substrate “)”

           | monad_set_relation_operation “(“ monad_set_or_monads “,” universe_or_substrate “)”
;

monad_set_relation_operation : “part_of” | “overlap”
;

universe_or_substrate : “universe” | “substrate”
;

monad_set_or_monads : “monads” | T_IDENTIFIER 
;

comparison_feature_name : feature_name

           | computed_feature_name
;

computed_feature_name : 

             “first_monad” computed_feature_monad_set_name

           | “last_monad” computed_feature_monad_set_name

           | “monad_count” computed_feature_monad_set_name

           | “monad_set_length” computed_feature_monad_set_name
;

computed_feature_monad_set_name : /* empty: Means “(monads)”. */

           | “(“ “monads” “)” /* Means: “(monads)”

           | “(“ monad_set_name “)”
;
</code></pre>
<h2 id="the-sheafsheaf">The sheaf<span id="sheaf" label="sheaf">[sheaf]</h2>
<h3 id="introduction-10">Introduction</h3>
<p>The sheaf is the data structure that is returned from an MQL query-query. The structure of the sheaf closely reflects the structure of the query on which it is based. This section is meant as reading for implementors of Emdros-systems, not for end-users.</p>
<p>The sheaf has a specific structure, which we will look at next. After that, we will take a look at the meaning of the structures of the sheaf.</p>
<h3 id="structure-of-the-sheaf">Structure of the sheaf</h3>
<p>A sheaf consists of the following element types:</p>
<ol>
<li><p>Sheaf</p></li>
<li><p>Straw</p></li>
<li><p>Matched_object</p></li>
</ol>
<h4 id="what-is-a-sheaf">What is a sheaf?</h4>
<p>A sheaf <em>is</em> a list of straws.</p>
<h4 id="what-is-a-straw">What is a straw?</h4>
<p>A straw <em>is</em> a list of matched_objects.</p>
<h4 id="what-is-a-matched_object">What is a matched_object?</h4>
<p>A matched_object <em>is</em> one of the following:</p>
<ol>
<li><p>(object id_d, focus boolean, marks, sheaf, object type, set of monads, list of feature-values)</p></li>
<li><p>(object id_m, focus boolean, marks, sheaf)</p></li>
</ol>
<p>That is, a matched_object is an object id (either id_d or id_m), coupled with a boolean indicating whether the block that gave rise to the matched_object had the “FOCUS” modifier, coupled with a “marks” string, coupled with a sheaf. If the matched_object is of the first kind, then additionally, the object type and the object’s set of monads are also available, and there is a (possibly empty) list of feature-values.</p>
<h3 id="mql-is-topographic">MQL is topographic</h3>
<p>There is a correspondence between the way an MQL query is structured and the structure of the resulting sheaf. In fact, the two are isomorphic to some extent. Doedens, in , called this property “topographicity.” Thus a <code>blocks</code> gives rise to a sheaf, a <code>block_str</code> gives rise to a straw, and a <code>block</code> gives rise to a matched_object. Inside a <code>block</code>, there is an optional inner <code>blocks</code>, which again gives rise to an inner sheaf. Hence a matched_object contains a sheaf. The origin of this sheaf is the optional inner <code>blocks</code> in the <code>block</code> which gave rise to the matched_object.</p>
<p>Note that this description applies to “full sheaves.” Flat sheaves are a different matter. See section <a href="#subsec:Flat-sheaf">[subsec:Flat-sheaf]</a> for a description of flat sheaves.</p>
<h3 id="meaning-of-matched_object">Meaning of matched_object</h3>
<p>A matched_object is the result of one of the following matches:</p>
<ol>
<li><p>An <code>object_block</code> against an object in the database.</p></li>
<li><p>An <code>opt_gap_block</code> against a gap.</p></li>
<li><p>A <code>gap_block</code> against a gap.</p></li>
</ol>
<p>A matched_object’s first component is either an id_d or an id_m. If the matched_object is the result of a match against an object_block or an object_block_first, then the id will be an id_d. If the matched_object is the result of a match against a <code>gap_block</code> or an <code>opt_gap_block</code>, the id is an id_m.</p>
<p>The second component is a boolean indicating whether the “FOCUS” keyword was present on the block.</p>
<p>The third component is a sheaf.</p>
<p>As we will see later, a sheaf is the result of matching against a <code>blocks</code>. It so happens that there is an optional <code>blocks</code> inside each of the four kinds of block (in the list above). The sheaf inside the matched_object is the result of a match against this <code>blocks</code>, if present. If the <code>blocks</code> is not present, then the sheaf is simply an empty sheaf.</p>
<p>For example, the following topograph:</p>
<pre><code>[word FOCUS]
</code></pre>
<p>will contain one matched_object for each word-object within the substrate of the topograph. The sheaf of each of these matched_objects will be empty, and the FOCUS boolean will be “true” because we specified the FOCUS keyword.</p>
<h3 id="meaning-of-straw">Meaning of straw</h3>
<p>A straw is the result of one complete match of a <code>block_str</code>. That is, a straw is a “string” of matched_objects corresponding to the blocks in the <code>block_str</code> which we should retrieve (which we can specify with the (“FOCUS”|”RETRIEVE”|”NORETRIEVE”) keyword triad).</p>
<p>For example, consider the following topograph:</p>
<pre><code>[word

   surface = the;

]

[word

   part_of_speech = noun;

]
</code></pre>
<p>This will return a sheaf with as many straws as there are pairs of adjacent words where the first is the word “the” and the second is a noun. Each straw will contain two matched_objects, one for each word.</p>
<h3 id="meaning-of-the-sheaf">Meaning of the sheaf</h3>
<p>A sheaf is the result of gathering all the matchings of a <code>blocks</code> non-terminal. There are four places in the MQL grammar where a <code>blocks</code> non-terminal shows up:</p>
<ol>
<li><p>In the <code>topograph</code>,</p></li>
<li><p>In the <code>object_block</code>,</p></li>
<li><p>In the <code>opt_gap_block</code>, and</p></li>
<li><p>In the <code>gap_block</code>.</p></li>
</ol>
<p>The first is the top-level non-terminal of the MQL query-query grammar. Thus the result of an MQL query-query is a sheaf.</p>
<p>Each of the last three is some kind of block. Inside each of these, there is an optional <code>blocks</code>. The result of matching this <code>blocks</code> is a sheaf.</p>
<p>But a sheaf is a list of straws. What does that mean?</p>
<p>It means that a sheaf contains as many matches of the strings of blocks (technically, block_string2) making up the <code>blocks</code> as are available within the substrate and universe that governed the matching of the <code>blocks</code>.</p>
<p>A straw constitutes one matching of the <code>block_str</code>ing2. A sheaf, on the other hand, constitutes all the matchings.</p>
<h3 id="flat-sheafsubsecflat-sheaf">Flat sheaf<span id="subsec:Flat-sheaf" label="subsec:Flat-sheaf">[subsec:Flat-sheaf]</h3>
<p>Most of the above description has applied to “full sheaves.” We now describe flat sheaves.</p>
<p>A “flat sheaf,” like a “full sheaf,” consists of the datatypes “sheaf,” “straw,” and “matched_object.” The difference is that a “matched_object” in a flat sheaf cannot have an embedded sheaf. This makes a flat sheaf a non-recursive datastructure.</p>
<p>A flat sheaf arises from a full sheaf by means of the “flatten” operator.</p>
<p>If “FullSheaf” is a full sheaf, then “flatten(FullSheaf)” returns a flat sheaf that corresponds to the full sheaf.</p>
<p>A flat sheaf contains the same matched_objects as its originating full sheaf. However, they are structured such that each straw in the flat sheaf contains only matched_objects of one object type. Each object type that is represented in the full sheaf results in one straw in the flat sheaf.</p>
<p>Thus a straw in a flat sheaf does not correspond to the matching of a block_string. Instead, it is a list of all the matched_objects of one particular object type in the originating full sheaf. All of the matched_objects in the full sheaf are represented in the flat sheaf, regardless of whether they represent the same object in the database.</p>
<p>The “flatten” operator is only applied to the output of an MQL query if the “RETURNING FLAT SHEAF” clause is given (see section <a href="#SELECT_OBJECTS">[SELECT_OBJECTS]</a>). The programmer of an Emdros application can also apply it programmatically.</p>
<p>There is a variant of the flatten operator which also takes a list of object type names, in addition to the full sheaf. Then only those object types which are in the list are put into the flat sheaf. If L is a list of object type names, and FullSheaf is a full sheaf, then flatten(FullSheaf, L) returns a flat sheaf with straws for only those object types which are in L. If L is empty, then this is interpreted as meaning that all object types in FullSheaf must go into the flat sheaf. In the this light, the single-argument flatten operator may be seen as being a special case of the two-argument flatten operator, with L being empty. That is, flatten(FullSheaf) is the same as flatten(FullSheaf, []).</p>
<h2 id="universe-and-substratesecuniverse-and-substrate">Universe and substrate<span id="sec:Universe-and-substrate" label="sec:Universe-and-substrate">[sec:Universe-and-substrate]</h2>
<h3 id="introduction-11">Introduction</h3>
<p>Two concepts which we shall need when explaining the blocks in MQL are “Universe” and “Substrate.” In this section, we define and explain them.</p>
<h3 id="universe-and-substrate">Universe and substrate</h3>
<p>A Universe is a contiguous set of monads. It always starts at a particular monad (a) and ends at another monad (b), where (a\leq b). In more everyday language, a Universe is a stretch of monads that starts at one monad and ends at another monad later in the database. The ending monad may be the same as the starting monad.</p>
<p>A Substrate, on the other hand, is an arbitrary set of monads. It may have gaps (see section <a href="#gaps">[gaps]</a> on page ). That is, while a Substrate always begins at a certain monad (a) and always ends at another monad (b), where (a\leq b), it need not contain all of the monads in between.</p>
<p>A Universe always has an accompanying Substrate, and a Substrate always has an accompanying Universe. Their starting- and ending-monads are the same. That is, the first monad of the Universe is always the same as the first monad of the accompanying Substrate. And the last monad of the Universe is always the same as the last monad of the Substrate. So a Universe is a Substrate with all the gaps (if any) filled in.</p>
<p>See section <a href="#SELECT%20OBJECTS:%20Explanation">[SELECT OBJECTS: Explanation]</a> for an explanation of how the initial substrate and universe are calculated for the query.</p>
<p>With that definition out of the way, let us proceed to describing, exemplifying, and explaining <em>blocks</em>.</p>
<h2 id="consecutiveness-and-embeddingmql-queryconsecutiveness-and-embedding">Consecutiveness and embedding<span id="mql-query:Consecutiveness-and-embedding" label="mql-query:Consecutiveness-and-embedding">[mql-query:Consecutiveness-and-embedding]</h2>
<p>Two important notions in the MQL query-subset are embedding and consecutiveness. If two blocks (be they object blocks or gap blocks) are consecutive in a query, it means that they will only match two objects or gaps which are consecutive with respect to the substrate. Likewise, a string of blocks (i.e., a <code>blocks</code>) which is embedded inside of a block of some sort will only match within the confines of the monads of the surrounding block.</p>
<p>For example, the following topograph:</p>
<pre><code>[Word psp=article]

[Word psp=noun]
</code></pre>
<p>will match two adjacent (or consecutive) words where the first is an article and the second is a noun. The consecutiveness is calculated with respect to the current substrate (see section <a href="#consecutive">[consecutive]</a>).</p>
<p>Likewise, the following topograph:</p>
<pre><code>[Clause

  [Phrase phrase_type = NP]

  [Phrase phrase_type = VP]

]
</code></pre>
<p>will match only if the two (adjacent) phrases are found <em>within the confines of</em> the monads of the surrounding Clause. In fact the monads of the surrounding clause serve as the substrate when matching the inner <code>blocks</code>.</p>
<p>You can specify the kind of containment you want: Either part_of or overlap. Part_of means that the inner object must be a subset (proper or not) of the outer object.</p>
<p>You can also specify whether the containment should be relative to the substrate or the universe. The universe is always the universe coming out the of the substrate that is the surrounding object or gap.</p>
<p>This is done as follows:</p>
<pre><code>[Clause

  // Phrase is part_of the monads of the clause

  [Phrase part_of(substrate) phrase_type=NP]

  // Phrase is part_of the monads of the clause, including any gaps

  // in the clause

  [Phrase part_of(universe) phrase_type=VP]

  

  // Phrase has non-empty intersection with the monads of the clause

  [Phrase overlaps(substrate) phrase_type=AdvP]

  // Phrase is non-empty intersection with the monads of the clause, 

  // including any gaps in the clause

  [Phrase overlaps(universe) phrase_type=PP]

]
</code></pre>
<p>The default is to use <code>part_of(substrate)</code>.</p>
<h2 id="blocksblocks">Blocks<span id="Blocks" label="Blocks">[Blocks]</h2>
<h3 id="introduction-12">Introduction</h3>
<p>Blocks are the heart and soul of MQL query-queries. They specify which objects and which gaps in those objects should be matched and/or retrieved. With object blocks, you specify which objects should be matched. With gap blocks, you specify whether a gap should be looked for.</p>
<p>In this section, we treat the four kinds of blocks in MQL in some detail. First, we describe and explain the two kinds of object block (Object blocks, <a href="#Object%20blocks">[Object blocks]</a>). Then we treat the two kinds of gap blocks (Gap blocks, <a href="#Gap%20blocks">[Gap blocks]</a>). Then we describe how to specify whether to retrieve a block’s contents (Retrieval, <a href="#Retrieval">[Retrieval]</a>). After that we describe how to specify that an object block should be either first or last in its enclosing <code>blocks</code> (First and last, <a href="#First%20and%20last">[First and last]</a>). Then we describe and explain how to specify constraints on features (Feature constraints, <a href="#Feature%20specifications">[Feature specifications]</a>). Then we describe object references, which are a way of referring to other objects in a query (Object references, <a href="#Object%20references">[Object references]</a>). Finally, we wrap up the syntactic non-terminals dealing with blocks by describing the <code>block</code> (Block, <a href="#Blocks:%20block">[Blocks: block]</a>)</p>
<h3 id="object-blocksobject-blocks">Object blocks<span id="Object blocks" label="Object blocks">[Object blocks]</h3>
<h4 id="introduction-13">Introduction</h4>
<p>Object blocks specify which objects should be matched. Therefore, they are quite important in MQL. With object blocks, it is also possible to specify whether or not matched objects should be retrieved. You can also specify constraints on the features of the objects which should be matched; You can specify whether you want objects matched against a certain object block to be first or last in the string of blocks we are looking for at the moment; And finally, you can label objects matched in a query with object reference labels, so that those objects can be referred to later in the query (i.e., further down in the MQL query, and thus further on in the string of monads). In this subsection, we deal with the object blocks themselves, deferring the treatment of feature-constraints, first/last-specifications, and object references to later subsections.</p>
<p>First, we describe the syntax of object blocks, then we give some examples, and finally we give some explanatory information.</p>
<h4 id="syntax-47">Syntax</h4>
<pre><code>object_block :  “[”   object_type_name

                     [ marks_declaration ]

                     [ object_reference_declaration ]

                     [ retrieval ]  

                     [ firstlast ]

                     [ monad_set_relation_clause ]

                     [ feature_constraints ]

                     [ feature_retrieval ]

                     [ blocks ]   

               “]”
;

object_type_name : T_IDENTIFIER
;

marks_declaration : T_MARKS
;

retrieval : “NORETRIEVE”

          | “RETRIEVE”

          | “FOCUS”
;

firstlast : “FIRST”

          |  “LAST”

          |  “FIRST”   “AND”   “LAST”
;

last : “LAST”
;

feature_retrieval : “GET” feature_list

  | /* empty: Don’t retrieve any features */
;

monad_set_relation_clause : /* empty; which means: part_of(substrate) */

           | monad_set_relation_operation “(“ universe_or_substrate “)”

           | monad_set_relation_operation “(“ monad_set_or_monads “,” universe_or_substrate “)”
;

monad_set_relation_operation : “part_of” | “overlap”
;

universe_or_substrate : “universe” | “substrate”
;

monad_set_or_monads : “monads” | T_IDENTIFIER 
;
</code></pre>
<h4 id="examples-3">Examples</h4>
<pre><code>1. [Clause]   
   
2. [Phrase noretrieve first

      phrase_type = NP

   ]   
   
3. [Clause first and last]   
   
4. [Word as w focus last 

      psp = noun and number = pl

      GET surface, lexeme

   ]   
   
5. [Clause‘context

     [Phrase‘red first

       phrase_type = NP and phrase_function = Subj

     ]

     [Phrase‘green

       phrase_type = VP

       [Word

         psp = V

       ]

       [Phrase‘blue

         phrase_type = NP and phrase_function = Obj

       ]

     ]

   ]   
    
6. [Sentence

      NOTEXIST [Word surface = saw

   ]
</code></pre>
<h4 id="explanation-44">Explanation</h4>
<p>Firstly, it will be noticed that the first item after the opening bracket must always be an object type name. This is in keeping with all other parts of MQL where object type names are used.</p>
<p>Secondly, it will be noticed that all of the other syntactic non-terminals in the definition of the object blocks are optional.</p>
<p>The marks declaration comes after the object type name. The query-writer can use it to pass information back into the application that sits on top of Emdros. Emdros does nothing special with the T_MARKS, other than passing it on into the sheaf, that is, into the matched_object that arises because of the object_block. In particular, there is no semantics associated with the marks_declaration. See page for the formal definition of T_MARKS.</p>
<p>The object reference declaration comes after the marks declaration, and will be dealt with below (<a href="#Object%20references">[Object references]</a> on page ).</p>
<p>The specification of the retrieval comes after the object reference declaration and will be dealt with in another section (<a href="#Retrieval">[Retrieval]</a> on page ).</p>
<p>The specification of the monad set relation clause has an impact on how the containment is calculated, and was dealt with above (<a href="#mql-query:Consecutiveness-and-embedding">[mql-query:Consecutiveness-and-embedding]</a> on page ).</p>
<p>The specification of first/last-constraints comes after the specification of retrieval, and will also be dealt with in another section (<a href="#First%20and%20last">[First and last]</a> on page ).</p>
<p>The specification of the monad set relation determines four things:</p>
<ol>
<li><p>It determines which monad set will be used to match against the Substrate or Universe that accompanies the surrounding <code>blocks</code>. If the “<code>monad_set_or_monads</code>” specification is left out, the constituting monad set is used (i.e., the monad set which makes up the object). The same is true if the monad_set_or_monads specification is “<code>monads</code>”. If the <code>monad_set_or_monads</code> specification is not left out, it must be a feature which must exist on the object type and be of the type “set of monads”.</p></li>
<li><p>It determines which monad set to use as the Substrate of the inner <code>blocks</code>. The monad set used for the Substrate of the inner <code>blocks</code> is currently the same as the monad set used to match against the Universe or Substrate of the outer <code>blocks</code>. This may change in future releases of Emdros.</p></li>
<li><p>It determines whether to match against the Universe or Substrate of the outer bl<code>ocks</code>. This is done by the mention of “<code>universe</code>” or “<code>substrate</code>”.</p></li>
<li><p>It determines which operation to use when matching against the Universe or Substrate of the surrounding <code>blocks</code>. This can be either “<code>part_of</code>” (the monad set of the object must be a subset of the Universe or Substrate) or “<code>overlap</code>” (non-empty set intersection). See section <a href="#part_of">[part_of]</a> on page for details of the part_of relation.</p></li>
</ol>
<p>It is possible to specify constraints on the features of objects. This is done in the <code>feature_constraints</code> non-terminal, which comes after the first/last-constraints. These constraints will be dealt with in a section below (<a href="#Feature%20specifications">[Feature specifications]</a> on page ).</p>
<p>A list of features can be given in the <code>feature_retrieval</code> clause. Their values for a given object are placed on the list of features in the matched_object in the sheaf.</p>
<p>The inner <code>blocks</code> syntactic non-terminal allows the writer of MQL queries the possibility of matching objects nested inside objects. Example 5 above shows several examples of this. Example 5 finds those clauses which have inside them first a phrase which is a Subject NP, then followed by a Phrase which is a VP, the first word inside of which is a verb, followed by an Object NP. Thus we have an object block (“Clause”) with an inner <code>blocks</code> (“NP followed by VP”), where inside the VP we have another <code>blocks</code> (V followed by NP).</p>
<p>The inner blocks, if present, must match if the object block is to match. When entering the inner <code>blocks</code>, the Substrate for that <code>blocks</code> becomes the monads of the enclosing object. Let us call that object O. The Universe for the inner <code>blocks</code> becomes the set of monads between and including the borders of the enclosing object (see section <a href="#borders,%20first,%20last">[borders, first, last]</a> on page ), i.e., the stretch of monads between (and including) O.first and O.last. This is the same as the substrate, except with any gaps filled in.</p>
<p>If you want any objects or gaps inside the object block to be retrieved, then the retrieval of the enclosing object block must be either retrieve or focus. Since the default retrieval for object blocks is to retrieve them, this condition is satisfied if you write nothing for the retrieval.</p>
<p>An object, if it is to match against a given object block, must meet all of the following criteria:</p>
<ol>
<li><p>The first/last constraints must be met.</p></li>
<li><p>The operation (“part_of” or “overlap”) of the monad_set_relation_clause must be true on the given monad set and the Substrate or Universe.</p></li>
<li><p>The feature constraints must hold. See section <a href="#Feature%20specifications">[Feature specifications]</a> on page for details.</p></li>
<li><p>The inner blocks must not return a failed sheaf.</p></li>
</ol>
<p>You can optionally place the keyword “NOTEXIST” before the object block. This will result in matching those cases where the object block does not occur, and will result in a failed match where the object block does occur. This is most useful if you have some context, i.e., a surrounding context (e.g., a sentence which does not contain such and such a word, see example 6 above). You are allowed to have blocks before and after a NOTEXIST block. Let us say that there is a block before the NOTEXIST block. Then the Substrate within which the NOTEXIST block will be matched is the Substrate of the context, minus the monads from the beginning of the Substrate to the end of the MatchedObject matching the previous block. The Universe of the NOTEXIST block will be defined analogously on the Universe of the context.</p>
<p>The NOTEXIST block will have “zero width” with respect to consecutiveness: If it matches anything, the entire block_string fails. If it does not match, it is as though the NOTEXIST block had not been there, and any block after the NOTEXIST block will be attempted matched starting at the previous block’s last monad plus 1.</p>
<p>The NOTEXIST keyword acts as an “upwards export barrier” of object reference declarations. That is, you cannot “see” an object reference declaration outside of the NOTEXIST, only inside of it.</p>
<h3 id="gap-blocksgap-blocks">Gap blocks<span id="Gap blocks" label="Gap blocks">[Gap blocks]</h3>
<h4 id="introduction-14">Introduction</h4>
<p>Gap blocks are used to match gaps in the substrate we are currently matching against. There are two kinds of blocks: plain gap blocks and optional gap blocks.</p>
<p>We start by defining the syntax related to gap blocks. We then give some examples of gap blocks. And finally, we provide some explanation.</p>
<h4 id="syntax-48">Syntax</h4>
<pre><code>gap_block : “[”   “GAP”   

                  [ marks_declaration ]

                  [ gap_retrieval ]   

                  [ blocks ]   

            “]”
;

opt_gap_block : “[”   “GAP?”   

                      [ marks_declaration ]

                      [ gap_retrieval ]   

                      [ blocks ]  

                “]” 
;

marks_declaration : T_MARKS
;

gap_retrieval : “NORETRIEVE”

              | “RETRIEVE”

              | “FOCUS”
;
</code></pre>
<h4 id="examples-4">Examples</h4>
<pre><code>1. [gap]   
   
2. [gap?]   
   
3. [gap noretrieve]   
   
4. [gap?‘yellow focus]   
   
5. [gap‘context‘red retrieve

     [Word retrieve

       psp = particle

     ]

   ]   
   
6. [gap‘yellow

   ]
</code></pre>
<h4 id="explanation-45">Explanation</h4>
<p>There are two differences between the two types of gap block: One is that the <code>gap_block</code> <em>must</em> match a gap in the substrate for the whole query to match, while the <code>opt_gap_block</code> <em>may</em> (but need not) match a gap in the substrate. The other is that the default retrieval of an opt_gap_block is NORETRIEVE, whereas the default retrieval of a gap_block is RETRIEVE. Otherwise, they are identical in semantics.</p>
<p>The retrieval will be dealt with more fully in the next section.</p>
<p>The inner <code>blocks</code>, if present, must match if the gap block is to match. When trying to match the inner <code>blocks</code>, both the Universe and the Substrate are set to the monads of the gap. So if the gap matches the monad-stretch ([a..b]), then both the Universe and the Substrate for the inner <code>blocks</code> will be this stretch of monads.</p>
<p>The last point is important in example 5. Here the Word which we are looking for inside the gap will be looked for within the monads which made up the gap.</p>
<p>If you want any objects or gaps to be retrieved inside the gap (as in example 5 above, where we want to retrieve the Word), then the retrieval of the gap block must be either “retrieve” or “focus”.</p>
<p>You can optionally specify a T_MARKS after the <code>gap</code> or <code>gap?</code> keyword. If you do, the MatchedObjects that arise because of this (opt_)gap_block will contain the same T_MARKS as you specified here. The query-writer can use it to pass information back into the application that sits on top of Emdros. Emdros does nothing special with the T_MARKS, other than passing it on into the sheaf, that is, into the matched_object that arises because of the (opt_)gap_block. In particular, there is no semantics associated with the marks_declaration. See page for the formal definition of T_MARKS.</p>
<h3 id="power-block">Power block</h3>
<h4 id="syntax-49">Syntax</h4>
<pre><code>power : “..”   [ restrictor ]
;

restrictor : “\&lt;” limit 

           | “\&lt;=” limit

           | “BETWEEN” limit “AND” limit
;

limit : T_INTEGER /* non-negative integer, may be 0. */
; 
</code></pre>
<h4 id="examples-5">Examples</h4>
<pre><code>1. [Word]   
   
2. [Word psp=article]

   [Word psp=noun]

   .. \&lt;= 5

   [Word psp=verb]   
   
3. [Phrase phrase_type = NP]

   ..

   [Phrase phrase_type = AdvP]

   .. BETWEEN 1 AND 5

   [Phrase phrase_type = VP]   
   
4. [Chapter

     topic = Noun classes in Bantu

   ]

   [Chapter 

     topic = Causatives in Setswana

   ]

   ..

   [Chapter

     topic = Verb-forms in Sesotho

   ]
</code></pre>
<h4 id="power-1">power</h4>
<p>The power block means “before the start of the next block, there must come a stretch of monads of arbitrary length, which can also be no monads (0 length)”. In its basic form, it is simply two dots, “<code>..</code>”.</p>
<p>The stretch of monads is calculated from the monad after the last monad of the previous block. If the previous block ended at monad 7, then the power block starts counting monads from monad 8.</p>
<p>One can optionally place a <code>restrictor</code> after the two dots, thus making the power block look like this, e.g., “<code>.. &lt; 5</code>”, “<code>.. &lt;= 5</code>”, or “<code>.. BETWEEN 1 AND 5</code>”.</p>
<p>The first two kinds of restrictor mean “although the stretch of monads is of arbitrary length, the length must be less than (or equal to) the number of monads given in the restrictor”. Thus “<code>.. &lt; 5</code>” means “from 0 to 4 monads after the end of the previous block”, and “<code>.. &lt;= 5</code>” means “from 0 to 5 monads after the end of the previous block”. That is, if the previous block ended at monad 7, then “<code>.. &lt; 5</code>” means “the next block must start within the monads 8 to 12”, while “<code>.. &lt;= 5</code>” means “the next block must start within the monads 8 to 13”.</p>
<p>Similarly, the third kind, “<code>.. BETWEEN</code> <code>min</code> <code>AND</code> <code>max</code>” means “there must be at least <code>min</code> monads in between, and at most <code>max</code> monads. This is construed as “<code>&gt;=</code> <code>min</code> <code>AND &lt;=</code> <code>max</code>”.</p>
<h3 id="retrievalretrieval">Retrieval<span id="Retrieval" label="Retrieval">[Retrieval]</h3>
<h4 id="introduction-15">Introduction</h4>
<p>Retrieval is used in four places in the MQL grammar. Once for each of the two object blocks and once for each of the two gap blocks. In this section we describe the three kinds of retrieval, specify the default behavior, and provide a bit of explanation.</p>
<h4 id="syntax-50">Syntax</h4>
<pre><code>retrieval : “NORETRIEVE”

          | “RETRIEVE”

          | “FOCUS”
;

gap_retrieval : “NORETRIEVE”

              | “RETRIEVE”

              | “FOCUS”
;
</code></pre>
<h4 id="examples-6">Examples</h4>
<pre><code>1. [Word focus

     psp = verb

   ]   
   
2. [gap? retrieve]   
   
3. [Phrase noretrieve]   
   
4. [gap focus]   
   
5. [Phrase retrieve

     [Word focus

       psp = article

     ]

     [gap retrieve

       [Word focus

         psp=conjunction

       ]

     ]

     [Word focus

       psp = noun

     ]

   ]
</code></pre>
<h4 id="explanation-46">Explanation</h4>
<p>Retrieval has to do with two domains pertaining to objects and gaps:</p>
<ol>
<li><p>Whether to retrieve the objects or gaps, and</p></li>
<li><p>Whether those objects or gaps should be in <em>focus</em>.</p></li>
</ol>
<p>Whether to retrieve is straightforward to understand. If we don’t retrieve, then the object or gap doesn’t get into the sheaf. The sheaf is the data-structure returned by an MQL query. The object or gap (if the gap is not optional) must still match for the overall match to be successful, but the object or gap won’t get into the sheaf if we don’t retrieve.</p>
<p>When an object is in focus, that means your application has the opportunity to filter this object out specifically from among all the objects retrieved. Exactly how this feature is used (or not used) will depend on your application. When is this useful?</p>
<p>Recall that, for objects in an inner <code>blocks</code> to be retrieved (in an object block or a gap block), the enclosing object or gap must also be retrieved. Thus you might end up with objects in the sheaf which you don’t really care about. The focus-modifier is a way of signaling special interest in certain objects or gaps. Thus you can specify exactly which objects should be of special interest to the application. In example 5 above,[6] the outer Phrase must be retrieved, because we wish to retrieve the inner objects and gaps. The inner gap must also be retrieved because we wish to retrieve the inner Word. The three Words are what we are really interested in, however, so we mark their retrieval as “focus”.</p>
<p>If we specify “focus” as the retrieval, then that implies “retrieve”. Thus we can’t not retrieve an object which is in “focus”. This makes sense. If you have registered a special interest in an object, that means you want to retrieve it as well.</p>
<p>The default for object blocks of both kinds, when no retrieval is specified, is to assume “retrieve”. The default for gap blocks of both kinds, on the other hand, is “noretrieve”.</p>
<h3 id="first-and-lastfirst-and-last">First and last<span id="First and last" label="First and last">[First and last]</h3>
<h4 id="introduction-16">Introduction</h4>
<p>The object blocks have the option of specifying whether they should be first and/or last in their enclosing <code>blocks</code>.</p>
<h4 id="syntax-51">Syntax</h4>
<pre><code>firstlast : “FIRST”

          | “LAST”

          | “FIRST”   “AND”   “LAST”
;
</code></pre>
<h4 id="examples-7">Examples</h4>
<pre><code>1. [Clause first and last]   
   
2. [Phrase first]   
   
3. [Clause

     [Phrase first]

     [Word last

       psp = verb

     ]

   ]
</code></pre>
<h4 id="explanation-47">Explanation</h4>
<p>In example 1, the clause must be both first and last in its surrounding <code>blocks</code>. In the second example, the phrase must merely be the first. In the third example, the Phrase must be first in the clause, followed by a word, which must be a verb, and which must be last. This can be realized, e.g., in verb-final languages.</p>
<p>What does it mean to be “first” and “last” in the enclosing <code>blocks</code>?</p>
<p>Again we must appeal to the notion of Universe and Substrate. Each <code>blocks</code> carries with it a Universe and a Substrate. Let us say that an object block must be first, and let us say that we are trying to match an object O against this object block. Let us call the substrate of the enclosing blocks “Su”. Then, for the object O to be first in the blocks means that O.first = Su.first. That is, the first monad of the object must be the same as the first monad of the Substrate.</p>
<p>Conversely, for an object O to be last in a blocks, means that O.last = Su.last. That is, the last monad of the object must be the same as the last monad of the Substrate.</p>
<h3 id="feature-constraintsfeature-specifications">Feature constraints<span id="Feature specifications" label="Feature specifications">[Feature specifications]</h3>
<h4 id="introduction-17">Introduction</h4>
<p>Object blocks can optionally have feature constraints. The feature constraints are boolean (i.e., logical) expressions whose basic boolean building-blocks are “and”, “or”, and “not”. The things that are related logically are comparisons of features and values, i.e., a feature followed by a comparison-symbol (e.g., “=”), followed by a value. Parentheses are allowed to make groupings explicit.</p>
<p>In the following, we first define the syntax of feature constraints. We then make refer to other parts of this manual for details of certain non-terminals. We then give some examples, followed by explanations of those examples. We then give some explanation and elucidation on feature-constraints. We then describe the constraints on type-compatibility between the feature and the value. Finally we elaborate on comparison-operators.</p>
<h4 id="syntax-52">Syntax</h4>
<pre><code>feature_constraints  : ffeatures 
;

ffeatures : fterm 

          |  ffeatures   “OR”   fterm 
;

fterm : ffactor

      | ffactor   “AND”   fterm 
;

ffactor : “NOT”   ffactor

        | “(”   ffeatures   “)”

        | feature_comparison 
;

feature_comparison : 

    feature_name  comparison_operator   value

  | feature_name  “IN”   enum_const_set

  | feature_name  “IN”   “(“  list_of_integer  “)”

  | feature_name  “IN”   object_reference_usage
;

comparison_operator : “=”

                    | “\&lt;”

                    | “\&gt;”

                    | “\&lt;\&gt;”  /* not equal */

                    | “\&lt;=”  /* less than or equal */

                    | “\&gt;=”  /* greater than or equal */

                    | “ ”   /* regular expression */

                    | “\! ”  /* inverted regular expression */

                    | “HAS” /* lhs: list; rhs: atomic value.

                                 signifies list membership. */
;

list_of_integer : T_INTEGER  { “,” T_INTEGER }*
;

value : enum_const

      | signed_integer

      | T_STRING

      | object_reference_usage
;

enum_const : T_IDENTIFIER
;

object_reference_usage : object_reference   

                         “.”   feature_name 
;

enum_const_set : “(“ enum_const_list “)”
;

enum_const_list : enum_const { “,” enum_const_list }
;
</code></pre>
<h4 id="examples-8">Examples</h4>
<pre><code>1. [Word psp = noun]   
   
2. [Word gender = neut or gender = fem]   
   
3. [Word psp = adjective and not case = nominative]   
   
4. [Phrase (phrase_type = NP

            and phrase_determination = indetermined)

           or phrase_type = AP

   ]   
   
5. [Word as w

     psp = article

   ]

   [Word

     psp = noun 

     and case = w.case

     and gender = w.gender

     and number = w.number

   ]   
   
6. [Word

     surface \&gt; Aa and surface   A-D]orkin

   ]   
   
7. [Word psp IN (verb, participle, infinitive)]   
   
8. [Word psp = verb OR psp = participle OR psp = infinitive]
</code></pre>
<h4 id="explanation-of-examples">Explanation of Examples</h4>
<p>Example 1 above is the simple case where a feature (“psp”) is being tested for equality with a value (“noun”). Example 2 is more of the same, except the gender can either be neuter or feminine, and the feature constraint would match in both cases. Example 3 finds those words which are adjectives <em>and</em> whose case is <em>not</em> nominative. Example 4 finds either adjectival phrases or NPs which are indetermined.</p>
<p>Example 5 is an example of usage of object references. The first Word is given the “label” (or “object reference”) “w”. Then the second Word’s feature-constraints refer to the values of the features of the first Word, in this case making sure that case, number, and gender are the same.</p>
<p>Example 6 is an example of two different comparison-operators, “greater-than” and “regular expression-match”.</p>
<p>Example 7 shows the comparison IN. It takes a comma-separated list of enumeration constant names in parentheses as its right-hand-side. The effect is the same as an OR-separated list of “=” feature-comparisons. So 7. and 8. are equilalent.</p>
<h4 id="explanation-48">Explanation</h4>
<p>While the syntax may look daunting to the uninitiated, the system is quite straightforward. At the bottom, we have feature comparisons. These consist of a feature, followed by a comparison-operator (such as “=”), followed by a value. These feature-comparisons can be joined by the three standard boolean operators “and”, “or”, and “not”.</p>
<p>The precedence of the operators follows standard practice, i.e., “not” has highest precedence, followed by “and”, followed by “or”. Parentheses are allowed to make groupings explicit. That is, “and” “binds” more closely than “or” so that the interpretation of this expression:</p>
<p>\smallskip{}</p>
<p>f_1 = val_1 “and” f_2 = val_2 “or” f_3 = val_3</p>
<p>\smallskip{}</p>
<p>is the following:</p>
<p>\smallskip{}</p>
<p>(f_1 = val_1 “and” f_2 = val_2) “or” f_3 = val_3</p>
<p>\smallskip{}</p>
<p>Note that if you use “not” on a feature comparison, and if you have another feature comparison before it, then you must explicitly state whether the relationship between the two is “and” or “or”. Thus the following is illegal:</p>
<p>\smallskip{}</p>
<p>f_1 = val_1 “not” f_2 = val_2</p>
<p>\smallskip{}</p>
<p>The following, however, would be legal:</p>
<p>\smallskip{}</p>
<p>f_1 = val_1 “and” “not” f_2 = val_2</p>
<p>\smallskip{}</p>
<p>The “in” comparison-operator can only be used with a comma-separated list of enumeration constant names on the right-hand-side. The effect is the same as if all of the enumeration constants had been compared “=” to the feature, with “OR” between them.</p>
<h4 id="type-compatibility">Type-compatibility</h4>
<p>The feature and the value with which we compare both have a <em>type</em>. The type is, one of “integer”, “7-bit (ASCII) string”, “8-bit string”, “enumeration constant”, “id_d”. Thus a type tells us how to interpret a value.</p>
<p>The types of the two values being compared must be <em>compatible</em>. Table <a href="#Table:%20Type-compatibility-constraints">[Table: Type-compatibility-constraints]</a> summarizes the type-compatibility-constraints.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">If value’s type is...</th>
<th style="text-align: left;">Then feature’s type must be...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">enumeration constant</td>
<td style="text-align: left;">The same enumeration as the value</td>
</tr>
<tr class="even">
<td style="text-align: left;">(enumeration constant-list)</td>
<td style="text-align: left;">The same enumeration as all the values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">signed_integer</td>
<td style="text-align: left;">integer or id_d</td>
</tr>
<tr class="even">
<td style="text-align: left;">7-bit or 8-bit string</td>
<td style="text-align: left;">7-bit or 8-bit string</td>
</tr>
<tr class="odd">
<td style="text-align: left;">object reference usage</td>
<td style="text-align: left;">The same type as the feature in the object</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">reference usage, or a list of the same type</td>
</tr>
</tbody>
</table>
<p>Type-compatibility-constraints<span id="Table: Type-compatibility-constraints" label="Table: Type-compatibility-constraints">[Table: Type-compatibility-constraints]</p>
<p>The 8-bit strings need not be of the same encoding.</p>
<h4 id="comparison-operators">Comparison-operators</h4>
<p>Table <a href="#Table:%20Comparison-operators">[Table: Comparison-operators]</a> summarizes the comparison-operators.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">op.</th>
<th style="text-align: left;">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">=</td>
<td style="text-align: left;">Equality</td>
</tr>
<tr class="even">
<td style="text-align: center;">&lt;</td>
<td style="text-align: left;">Less-than</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&gt;</td>
<td style="text-align: left;">Greater-than</td>
</tr>
<tr class="even">
<td style="text-align: center;">&lt;&gt;</td>
<td style="text-align: left;">Inequality (different from)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&lt;=</td>
<td style="text-align: left;">Less-than-or-equal-to</td>
</tr>
<tr class="even">
<td style="text-align: center;">&gt;=</td>
<td style="text-align: left;">Greater-than-or-equal-to</td>
</tr>
<tr class="odd">
<td style="text-align: center;"> </td>
<td style="text-align: left;">Regular expression-match</td>
</tr>
<tr class="even">
<td style="text-align: center;">! </td>
<td style="text-align: left;">Negated regular-expression-match</td>
</tr>
<tr class="odd">
<td style="text-align: center;">IN</td>
<td style="text-align: left;">Member of a list of enum constants</td>
</tr>
<tr class="even">
<td style="text-align: center;">HAS</td>
<td style="text-align: left;">List on left-hand-side, atomic value on right-hand-side. Signifies list membership.</td>
</tr>
</tbody>
</table>
<p>Comparison-operators<span id="Table: Comparison-operators" label="Table: Comparison-operators">[Table: Comparison-operators]</p>
<h5 id="inequality">Inequality</h5>
<p>The inequality-operator “&lt;&gt;” is logically equivalent to “not ... = ...”. The negated regular-expression-match “! ” is logically equivalent to “not ...   ...”.</p>
<h5 id="equality">Equality</h5>
<p>Equality is defined as follows: If the type is id_d, then both must be the same id_d. If the type is integer, then both must be the same number. If the type is string, then both must be byte-for-byte identical, and of the same length. If the type is enumeration, then both must have the same numerical value. That is, the enumeration constants must be the same, since an enumeration is a one-to-one correspondence between a set of labels and a set of values. If the type is a list, the two lists must be identical, i.e., consist of the same sequence of values.</p>
<h5 id="less-thangreater-than">Less-than/greater-than</h5>
<p>The four less-than/greater-than-operators use 8-bit scalar values for the comparison of strings. That is, it is the numerical value of the bytes in the strings that determine the comparison. In particular, the locale is not taken into consideration. For comparison of id_ds, the id_ds are treated as ordinary numbers, with nil being lower than everything else. For comparison of integers, the usual rules apply. For comparison of enumeration constants, it is the values of the enumeration constants that are compared, as integers.</p>
<h5 id="regular-expressionsparregular-expressions">Regular expressions<span id="par:Regular-expressions" label="par:Regular-expressions">[par:Regular-expressions]</h5>
<p>There are two regular expression-comparison-operators (“ ” and “! ”). They operate on 8-bit strings. That is, both the feature-type and the value against which the match is made must be 8-bit strings. The negated match matches everything that does not match the regular expression provided as the value.</p>
<p>The value that they are matched against must be a string.</p>
<p>The regular expressions are the same as in Perl 5. See section <a href="#PCRE">[PCRE]</a> on page for details of where regular expression-support comes from. See <code>http://www.perl.com/</code> for details of Perl regular expressions.</p>
<p>Before version 1.2.0.pre46, regular expressions were anchored, meaning that they always started matching at the start of the string. As of 1.2.0.pre46, regular expressions are not anchored, meaning that they can start their match anywhere in the string.</p>
<h5 id="in">IN</h5>
<p>The IN comparison operator must have:</p>
<ol>
<li><p>either an enumeration feature on the left hand side and a comma-separated list of enumeration constants in parentheses on the right-hand-side (or an object refence usage resolving to a list-of-enum-constants of the same type),</p></li>
<li><p>or an INTEGER feature on the left hand side, and a list of integers on the right-hand-side (or an object reference usage resolving to this),</p></li>
<li><p>or an ID_D feature on the left hand side, and a list of integers on the right-hand-side (or an object reference usage resolving to a list of ID_Ds).</p></li>
</ol>
<p>For the first case, all of the enumeration constants must belong to the enumeration of the feature. The meaning is “feature must be in this list”, and is equivalent to a string of “=” comparisons with “OR” in between, and with parentheses around the string of OR-separated comparisons.</p>
<p>For the second and third cases, the meaning is the same, but applied to integers and id_ds respectively.</p>
<h5 id="has">HAS</h5>
<p>The HAS comparison operator must have:</p>
<ol>
<li><p>Either a list-of-enumeration constant on the left hand side and an enumeration constant belonging to the same enumeration on the left hand side (or an object reference usage resolving to this),</p></li>
<li><p>or a list-of-INTEGER feature on the left hand side, and an atomic integer value the right-hand-side (or an object reference usage resolving to this),</p></li>
<li><p>or a list-of-ID_D feature on the left hand side, and an atomic id_d value on the right-hand-side (or an object reference usage resolving to this).</p></li>
</ol>
<p>This signifies list-membership of the right-hand-side in the list on the left-hand-side.</p>
<h3 id="object-referencesobject-references">Object references<span id="Object references" label="Object references">[Object references]</h3>
<h4 id="introduction-18">Introduction</h4>
<p>Object references are a way of referring to objects in a query outside of the object block which they matched. This provides the possibility of matching objects on the basis of the features of other objects earlier in the query.</p>
<p>In this subsection, we first give the syntax of object references, their declaration and their usage. We then provide some examples, followed by an explanation of those examples. We then give some explanation of object references. Finally, we document some constraints that exist on object references.</p>
<h4 id="syntax-53">Syntax</h4>
<pre><code>object_reference_declaration : “AS” object_reference 
;

object_reference : T_IDENTIFIER 
;

object_reference_usage : object_reference   

                         “.”   feature_name 
;

feature_name : T_IDENTIFIER
;
</code></pre>
<h4 id="examples-9">Examples</h4>
<pre><code>1. [Clause

     [Phrase as p

       phrase = NP

     ]

     ..

     [Phrase

       phrase = AP 

       and case = p.case 

       and number = p.number

       and gender = p.gender

     ]

   ]   
   
2. [Clause as C

     [Phrase

       phrase_type = NP

       parent = C.self

     ]

   ]   
   
3. [Sentence as S]

   ..

   [Sentence 

     head = S.self

   ]
</code></pre>
<h4 id="explanation-of-examples-1">Explanation of examples</h4>
<p>Example 1 finds, within a clause, first an NP, followed by an arbitrary stretch of text, followed by an AP. The AP’s case, number, and gender-features must be the same as the NP’s case, number, and gender-features respectively.</p>
<p>Example 2 finds a clause, and within the clause an NP which is a direct constituent of the clause. That is, its parent feature is an id_d which points to its parent in the tree. This id_d must be the same as the clause’s “self” feature. See section <a href="#self">[self]</a> on page for more information about the “self” feature.</p>
<p>Example 3 finds a sentence and calls it S. Then follows an arbitrary stretch of text. Then follows another sentence whose head feature is an id_d which points to the first sentence. That is, the second sentence is dependent upon the first sentence.</p>
<h4 id="explanation-49">Explanation</h4>
<p>The <code>object_reference_declaration</code> non-terminal is invoked from the object blocks, right after the object type name. That is, the <code>object_reference_declaration</code> must be the first item after the object type name, if it is to be there at all, as in all of the examples above. The object reference declaration says that the object that matched this object block must be called whatever the <code>object_reference</code> is (e.g., “p”, “C”, and “S” in the examples above). Then object blocks later in the query can refer to this object’s features on the right-hand-side of feature comparisons. See section <a href="#Feature%20specifications">[Feature specifications]</a> on page for details of feature-comparisons.</p>
<p>The <code>object_reference_usage</code> non-terminal shows up on the right-hand-side of feature comparisons, as in the examples above. It consists of an object reference followed by a dot followed by a feature name.</p>
<h4 id="constraints-on-object-references">Constraints on object references</h4>
<p>The following are the constraints on object references:</p>
<ul>
<li><p>Object references must be declared before they can be used. That is, they must appear in an <code>object_reference_declaration</code> earlier in the query (i.e., further towards the top).</p></li>
<li><p>The feature name on an object reference usage must be a feature of the object type of the object that had the corresponding object reference declaration.</p></li>
<li><p>The feature type of the object reference usage must be the same as the feature type of the feature with which it is compared (not just compatible with).</p></li>
<li><p>An object reference must only be declared once in a query. That is, no two object references must have the same name.</p></li>
<li><p>A “Kleene Star” construct (see Section <a href="#subsec:Block:KleeneStar(*)">[subsec:Block:KleeneStar(*)]</a>) acts as an “export barrier” upwards in the tree for object reference declarations. Thus any object reference usages which are separated from the object reference declaration by a Kleene Star cannot be “seen”. For example, this is not allowed:</p></li>
</ul>
<pre><code>[Clause

   [Phrase

      [Word as w1]

   ]* // Kleene Star acts as an export barrier\!

   [Word surface=w1.surface] // So we can’t see the declaration here...

]
</code></pre>
<ul>
<li>You also cannot have an object reference declaration on an object block that itself bears the Kleene Star. Thus this is not allowed:</li>
</ul>
<pre><code>[Clause

   [Phrase as p1]* // This is NOT allowed\!

   [Phrase function=p1.function]

]
</code></pre>
<ul>
<li>It is not allowed to have an object reference declaration that is used “above” an OR. That is, all object reference declarations and usages should be within the same block_string2 (see Section <a href="#subsec:block_string">[subsec:block_string]</a> and Section <a href="#Block%20strings:%20block_str&#39;s">[Block strings: block_str's]</a>). “OR” acts as an “export barrier” on object reference declarations, not allowing them to be “seen” beyond the “OR”. Thus this is <em>not</em> allowed:</li>
</ul>
<pre><code>[Phrase as p1]

OR

[Phrase function=p1.function] // Oops\! Can’t see declaration from here\!

 

&lt;span class=&quot;roman&quot;&gt;Whereas this &lt;span class=&quot;roman&quot;&gt;*is*
&lt;span class=&quot;roman&quot;&gt;allowed:

[Phrase as p1 

   [Phrase function=p1.function] // This is OK

   OR

   [Phrase function\&lt;\&gt;p1.function] // This is also OK

]

 

&lt;span class=&quot;roman&quot;&gt;The reason the second is allowed but the first is
not is that it is the object reference
&lt;span class=&quot;roman&quot;&gt;*declaration* &lt;span class=&quot;roman&quot;&gt;which is
under embargo above (not below) an OR, whereas the object
reference &lt;span class=&quot;roman&quot;&gt;*usage*
&lt;span class=&quot;roman&quot;&gt;is free to see an object reference
&lt;span class=&quot;roman&quot;&gt;*declaration* &lt;span class=&quot;roman&quot;&gt;that has
been declared above an
OR.
</code></pre>
<h3 id="blockblocks-block">Block<span id="Blocks: block" label="Blocks: block">[Blocks: block]</h3>
<h4 id="introduction-19">Introduction</h4>
<p>The non-terminal <code>block</code> is a choice between three kinds of block: <code>opt_gap_block</code>s, <code>gap_block</code>s, and <code>object_block</code>s. It is used in the grammar of MQL queries in the definition of <code>block_string</code>s, that is, in when defining strings of blocks. See section <a href="#Block%20strings:%20block_str&#39;s">[Block strings: block_str's]</a> on page for more information on <code>block_string</code>s.</p>
<h4 id="syntax-54">Syntax</h4>
<pre><code>block : opt_gap_block 

      | gap_block 

      | power

      | object_block

      | (“NOTEXIST” | “NOTEXISTS”) object_block
;
</code></pre>
<h2 id="strings-of-blockssecstrings-of-blocks">Strings of blocks<span id="sec:Strings-of-blocks" label="sec:Strings-of-blocks">[sec:Strings-of-blocks]</h2>
<h3 id="introduction-20">Introduction</h3>
<p>Having now described all the syntax and semantics of individual blocks, we now go on to giving the bigger picture of MQL queries. This section describes strings of blocks, as well as the higher-level non-terminals in the MQL query-query subset.</p>
<p>We first describe the <code>topograph</code>, the top-level entry-point into the MQL query-query grammar (<a href="#topograph">[topograph]</a>). We then describe the <code>blocks</code> non-terminal, which shows up inside each of the three kinds of blocks as an inner <code>blocks</code> (<a href="#Block%20strings:%20blocks">[Block strings: blocks]</a>). We then describe the <code>block_str</code> non-terminal, which provides for strings of blocks optionally connected by power blocks (the “<code>..</code>” blocks which have been exemplified previously, and which mean “an arbitrary stretch of space”) (<a href="#Block%20strings:%20block_str&#39;s">[Block strings: block_str's]</a>).</p>
<h3 id="topographtopograph">topograph<span id="topograph" label="topograph">[topograph]</h3>
<h4 id="introduction-21">Introduction</h4>
<p>The <code>topograph</code> non-terminal is the entry-point for the MQL query-query subset.[7] It simply consists of a <code>blocks</code> non-terminal. The topograph passes on a Universe and a Substrate to the <code>blocks</code> non-terminal, and these will be described below.</p>
<h4 id="syntax-55">Syntax</h4>
<pre><code>topograph : blocks 
;
</code></pre>
<h4 id="examples-10">Examples</h4>
<pre><code>1. [Word]   
   
2. [Word psp=article]

   [Word psp=noun]   
   
3. [Clause

     [Phrase phrase_type = NP]

     ..

     [Phrase phrase_type = VP]

   ]   
   
4. [Book

     title = Moby Dick

     [Chapter chapter_no = 3

       [Paragraph

         [Word surface = Ishmael

       ]

       ..

       [Paragraph

         [Word surface = whaling

       ]

     ]

   ]
</code></pre>
<h4 id="explanation-of-examples-2">Explanation of examples</h4>
<p>Example 1 simply finds all words within the topograph’s Universe and Substrate.</p>
<p>Example 2 finds all pairs of adjacent words in which the first word is an article and the second word is a noun, within the topograph’s Universe and Substrate.</p>
<p>Example 3 finds all clauses within which there are pairs of first an NP, followed by an arbitrary stretch of monads, then a VP. Within the topograph’s Universe and Substrate, of course.</p>
<p>Example 4 finds a book whose title is “Moby Dick”, and within the book it finds chapter 3, and within this chapter it finds a Paragraph within which there is a word whose surface is “Ishmael”. Then, still within the chapter, after an arbitrary stretch of monads, it finds a Paragraph within which there is a word whose surface is “whaling”.</p>
<h4 id="universe-and-substrate-1">Universe and Substrate</h4>
<p>In order to understand how the Universe and Substrate are calculated, it is necessary to refer back to the definition of the SELECT OBJECTS query. Please consult section <a href="#SELECT%20OBJECTS:%20Explanation">[SELECT OBJECTS: Explanation]</a> on page for details.</p>
<h3 id="blocksblock-strings-blocks">blocks<span id="Block strings: blocks" label="Block strings: blocks">[Block strings: blocks]</h3>
<h4 id="introduction-22">Introduction</h4>
<p>The <code>blocks</code> non-terminal is central in the MQL query-query subset. It shows up in five places:</p>
<ul>
<li><p>In the <code>topograph</code>,</p></li>
<li><p>Inside the <code>object_block</code> as the inner <code>blocks</code>,</p></li>
<li><p>Inside the <code>gap_block</code> and the <code>opt_gap_block</code> as the inner <code>blocks</code>.</p></li>
</ul>
<h4 id="syntax-56">Syntax</h4>
<pre><code>blocks : block_string
;
</code></pre>
<h3 id="block_stringsubsecblock_string">block_string<span id="subsec:block_string" label="subsec:block_string">[subsec:block_string]</h3>
<h4 id="introduction-23">Introduction</h4>
<p>A “block_string” is basically either a “block_string2” or it is a block_string2 followed by the keyword “OR” followed by another block_string. Or, put another way, a block_string is a string (possibly 1 long) or block_string2’s, separated by “OR”.</p>
<h4 id="syntax-57">Syntax</h4>
<pre><code>block_string : block_string2 

             | block_string2 “OR” block_string
;

block_string2 : block_string1

              | block_string1 block_string2

              | block_string1 “\!” block_string2
;

block_string1 : block_string0

              | block_string0 “*” [monad_set]
;

block_string0 : block

              | “[“ block_string “]”
;
</code></pre>
<h4 id="examples-11">Examples</h4>
<pre><code>1. [Clause

      [Phrase function = Predicate]  // This...

      [Phrase function = Objc]       // ... is a block_string2

      OR

      [Phrase function = Predicate]  // And this...

      [Phrase function = Complement] // is another block_string2

   ]

2. [Sentence

      [gap [Clause function = relative] // This is a block_string2

      OR

      [Clause AS c1 function = Subject] // And this...

      ..                                // ... is also ...

      [Clause daughter = c1.self]       // ... a block_string2

   ]
</code></pre>
<h4 id="explanation-50">Explanation</h4>
<p>Block_strings are recursive in that the lowest level (Block_string0) can be either a Block, or a full BlockString in [square brackets].</p>
<p>Notice that Kleene Star (*) binds more tightly than concatenation. Thus if you wish to use Kleene Star with more than one block, you must wrap those blocks in a [square bracket group].</p>
<p>Notice also that OR binds less tightly than concatenation. Thus OR works between strings of blocks.</p>
<p>The first example finds all clauses in which it is either the case that there exist two phrases inside the clause where the first is a predicate and right next to it is an object, or the first is a predicate and right next to it is a complement (or both might be true, in which case you’ll get two straws inside the inner sheaf of the clause).</p>
<p>The second example finds all clauses in which it is the case that there either is a gap with a relative clause inside it, or there are two clauses (possibly separated) where the first clause is a subject in the second. (This assumes a data model where mother clauses do not include the monads of their daughter clauses).</p>
<p>See Section <a href="#Object%20references">[Object references]</a> for some restrictions on object references regarding OR.</p>
<h4 id="the--constructsubsecblockkleenestar">The “*” construct<span id="subsec:Block:KleeneStar(*)" label="subsec:Block:KleeneStar(*)">[subsec:Block:KleeneStar(*)]</h4>
<p>The “*” construct is a so-called “Kleene Star”. It allows searching for object blocks or groups that are repeated. It has two forms: One with and one without a trailing set of integers (with the same syntax as a set of monads). For example:</p>
<pre><code>SELECT ALL OBJECTS 

WHERE

[Sentence 

  [Phrase FIRST phrase_type = NP] 

  [Phrase phrase_type IN (VP, NP, AP)]* 

  [Phrase function = adjunct]* {1-3} 

] 

GO
</code></pre>
<p>This finds sentences whose first phrase is an NP, followed by arbitrarily many phrases which can either be VPs, NPs, or APs (or any combination of those), followed by between 1 and 3 phrases whose function is adjunct.</p>
<p>A less contrived example:</p>
<pre><code>SELECT ALL OBJECTS

WHERE 

[Sentence 

  [Word psp=verb] 

  [Word psp=article or psp=noun 

        or psp=adjective or psp=conjunction]*{1-5} 

] 

GO
</code></pre>
<p>This finds sentences where there exists a word whose part of speech is verb, followed by 1 to 5 words whose parts of speech may be article, noun, adjective, or conjunction (or any combination of those). Presumably this would (in English) be a VP with (parts of) the object NP after the verb.</p>
<p>The Kleene-Star without a trailing set of integers means from 0 to MAX_MONADS. Note, however, that there is no performance penalty involved in such a large end: The algorithm stops looking when getting getting one more fails.</p>
<p>If 0 is in the set of integers, then this means that the object need not be there. This means that the following:</p>
<pre><code>SELECT ALL OBJECTS 

WHERE 

[Sentence 

  [Word psp=verb] 

  [Word psp=article]*{0-1} 

  [Word psp=noun] 

] 

GO
</code></pre>
<p>would find sentences where there exists a verb followed by 0 or 1 articles followed by a noun. Thus the case of verb immediately followed by noun would also be found by this query. Thus the {0-1} is equivalent to ? in regular expressions.</p>
<p>The set of integers has the same syntax as monad sets. Therefore, to obtain a “no upper bound” star-construct, use {&lt;lower-bound&gt;-}, e.g., {10-} to mean “from 10 times to (practically) infinitely many times.”</p>
<p>The following restrictions apply:</p>
<ul>
<li><p>You cannot have a Kleene Star on an object block which also has the <code>NOTEXIST</code> keyword in front.</p></li>
<li><p>You cannot have a Kleene Star on an object block which has the <code>“noretrieve</code>” keyword.</p></li>
</ul>
<pre><code></code></pre>
<h4 id="the-bang-">The bang (“!”)</h4>
<p>You can optionally place a bang (“<code>!</code>”) between any of the <code>block</code>s in a <code>block_string2</code>. The bang indicates that there must be no gaps between the two blocks. It is an implicit rule of MQL that there is a hidden <code>opt_gap_block</code> between each pair of <code>block</code>s in a <code>block_string</code> which are not mediated by a bang.</p>
<p>The reason for having the <code>opt_gap_block</code> is the following: It protects you from what you do not know. In some languages, there can be gaps in clauses because of post-positive conjunctions “sticking out” at a higher level. One would not wish to have to specify all the time that one wanted to look for gaps, for one would invariably forget it sometimes, thus not getting all the results available. Thus MQL inserts an <code>opt_gap_block</code> between each pair of blocks that are not mediated by a bang. The bang is a way of specifying that one does not wish the hidden <code>opt_gap_block</code> to be inserted.</p>
<p>The <code>opt_gap_block</code> that is inserted is not retrieved.</p>
<p>\appendix</p>
<h1 id="copying">Copying</h1>
<h2 id="introduction-24">Introduction</h2>
<p>Emdros is covered by two different licenses, both of which allow you freely to copy, use, and modify the sourcecode. The parts which were written by Ulrik Sandborg-Petersen are covered by the MIT License. The pcre library, which provides regular expressions-capabilities, is covered by a different license. Some parts were contributed by Kirk E. Lowery, Martin Korshøj Petersen, or Claus Tøndering; they are Copyright Sandborg-Petersen Holding ApS and are also under the MIT.</p>
<p>SQLite is in the Public Domain. See <code>www.sqlite.org</code> for details.</p>
<p>All Emdros documentation (including this document) is covered under the Creative Commons Attribution-Sharealike license version 4.0. Please see the Creative Commons website for the details.</p>
<h2 id="mit-license">MIT License</h2>
<p>MIT License</p>
<pre><code>Copyright (C) 1999-2018 Ulrik Sandborg-Petersen

Copyright (C) 2018-present Sandborg-Petersen Holding ApS

Permission is hereby granted, free of charge, to any person obtaining

a copy of this software and associated documentation files (the

Software), to deal in the Software without restriction, including

without limitation the rights to use, copy, modify, merge, publish,

distribute, sublicense, and/or sell copies of the Software, and to

permit persons to whom the Software is furnished to do so, subject to

the following conditions:

The above copyright notice and this permission notice shall be

included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,

EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE

LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION

OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION

WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>
<h2 id="pcre-licensesecpcre-license">PCRE license<span id="sec:PCRE-license" label="sec:PCRE-license">[sec:PCRE-license]</h2>
<p>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</p>
<p>Release 6 of PCRE is distributed under the terms of the BSD licence, as specified below. The documentation for PCRE, supplied in the doc directory, is distributed under the same terms as the software itself.</p>
<p>The basic library functions are written in C and are freestanding. Also included in the distribution is a set of C++ wrapper functions.</p>
<h3 id="the-basic-library-functions">THE BASIC LIBRARY FUNCTIONS</h3>
<p>Written by: Philip Hazel</p>
<p>Email local part: ph10</p>
<p>Email domain: cam.ac.uk</p>
<p>University of Cambridge Computing Service,</p>
<p>Cambridge, England. Phone: +44 1223 334714.</p>
<p>Copyright (c) 1997-2006 University of Cambridge</p>
<p>All rights reserved.</p>
<h3 id="the-c-wrapper-functions">THE C++ WRAPPER FUNCTIONS</h3>
<p>Contributed by: Google Inc.</p>
<p>Copyright (c) 2006, Google Inc. All rights reserved.</p>
<h3 id="the-bsd-license">The “BSD” license</h3>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li><p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li>
<li><p>Neither the name of the University of Cambridge nor the name of Google Inc. nor the names of their contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p></li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<pre><code></code></pre>
<h1 id="console-sheaf-grammarappendixconsole-sheaf-grammar">Console sheaf grammar<span id="Appendix:Console-sheaf-grammar" label="Appendix:Console-sheaf-grammar">[Appendix:Console-sheaf-grammar]</h1>
<h2 id="introduction-25">Introduction</h2>
<p>The sheaf’s contents were explained in section <a href="#sheaf">[sheaf]</a>. In this appendix, we give the grammar for the sheaf as it is output with console output (as opposed to XML output).</p>
<h2 id="sheaf-grammar">Sheaf grammar</h2>
<pre><code>/* Sheaf */

sheaf : failed_sheaf | successful_sheaf
;   
failed_sheaf : “//”  /* A failed sheaf means 

                          that the query failed

                          in some way. */
;   
successful_sheaf : “//” straws /* A successful sheaf

                                    means that the query

                                    did not fail. It may

                                    however, be empty,

                                    in which case the

                                    list_of_straws will

                                    not be there, and the

                                    sheaf will look like

                                    this: “// \&lt; \&gt;”.

                                 */
;   
straws : “\&lt;” list_of_straws “\&gt;”
;   
list_of_straws : { straw }
;   
   
/* Straw */

straw : “\&lt;” list_of_matched_objects “\&gt;”
;   
list_of_matched_objects : { matched_object }
;   
/* Matched object */

matched_object : mo_id_d | mo_id_m
;   
   
/* Matched object with id_d */

mo_id_d : “[” object_type_name

          id_d_of_object

          monad_set

          is_focus

          [marks]

          inner_sheaf

          “]”
;   
object_type_name : T_IDENTIFIER
;   
id_d_of_object : T_INTEGER
;   
is_focus : “true” | “false” /* Was the block against 

                                   which this matched_object

                                   was matched a “focus”

                                   block or not? I.e., was

                                   they keyword “focus” 

                                   present in the block?

                                */
;   
   
marks : T_MARKS   
;   
inner_sheaf : sheaf
;   
   
/* Matched object with id_m (see ) */

mo_id_d : “[” “pow_m”

          monad_set

          is_focus

          [marks]

          inner_sheaf

          “]”
;
</code></pre>
<p>Bibliography Doedens, Crist-Jan. 1994: <em>Text Databases, One Database Model and Several Retrieval Languages.</em> ‘Language and Computers,’ Volume 14. Editions Rodopi Amsterdam, Atlanta, GA. ISBN 90-5183-729-1.</p>
<p>Sandborg-Petersen, Ulrik. 2008. <em>Annotated text databases in the context of the Kaj Munk archive: One database model, one query language, and several applications</em>. PhD dissertation, Department of Communication and Psychology, Aalborg University, Denmark. Obtainable from URL: <code>http://ulrikp.org/</code></p>
<p>Petersen, Ulrik. 2002: <em>The Standard MdF Model</em>. Unpublished article. Obtainable from URL: <code>http://emdros.org/</code></p>
<p>Petersen, Ulrik. 2002: <em>Monad Sets – Implementation and Mathematical Foundations</em>. Unpublished article. Obtainable from URL: <code>http://emdros.org/</code></p>
<p>Petersen, Ulrik. 2004. <em>Emdros -- a text database engine for analyzed or annotated text</em>. In ICCL, Proceedings of COLING 2004, held August 23-27 in Geneva. International Commitee on Computational Linguistics, pp. 1190--1193. <code>http://emdros.org/</code></p>
<p>Petersen, Ulrik. 2007: <em>Relational Implementation of EMdF and MQL.</em> Unpublished working-paper. Obtainable from URL: <code>http://emdros.org/</code></p>
<p>Petersen, Ulrik. 2007: <em>MQL Query Guide</em>. Obtainable from URL: <code>http://emdros.org/</code></p>
<p>\printindex</p>
<ol>
<li><p>Strictly, this is not true, since all object types (except pow_m, any_m, and all_m) have at least one feature, namely the one called “self”. Please see section <a href="#self">[self]</a> for more information.</p></li>
<li><p>ASCII strings are stored exactly the same way as 8-bit STRINGs. This distinction is mostly obsolete.</p></li>
<li><p>This is true for PostgreSQL (it is a TEXT). For MySQL, the maximum is 4294967295 (2^32 - 1) characters (it is a LONGTEXT). On SQLite, it is a TEXT, but it is unknown how much this can hold.</p></li>
<li><p>For part_of, see section <a href="#part_of">[part_of]</a>.</p></li>
<li><p>“Syntactic sugar” is a term used by computer-scientists for niceties in the grammar of a language which help the user in some way, usually so that they do not have to type as much as would otherwise be required. Here, it simply means that some of the keywords are optional, or have shorthand forms.</p></li>
<li><p>This construction actually does occur in at least one language, namely ancient Greek. It is due to post-positive particles and conjunctions such as “de”, “gar”, “men”, and the like.</p></li>
<li><p>Even though <code>mql_query</code> is really the proper entry-point for an MQL query-query, we may consider the topograph to be the top-level syntactic non-terminal in the MQL query-subset. The topograph has historical primacy, since it was defined first in Doedens’ QL (see ). The <code>mql_query</code> non-terminal simply acts as a proxy, passing control to the topograph immediately.</p></li>
</ol>
</body>
</html>
