#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{a4}
\usepackage{times}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 5
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle headings
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
MQL query-subset
\end_layout

\begin_layout Author
Ulrik Petersen
\end_layout

\begin_layout Date
August 9, 2004
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \tableofcontents{}

\end_inset


\end_layout

\begin_layout Chapter
Preliminaries
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
WARNING, WARNING: This document is ancient (its contents were last updated
 in October 2001).
 It does document some of the internals of the topographic engine in Emdros,
 but the information may be out-of-date.
 For using MQL, the 
\begin_inset Quotes eld
\end_inset

MQL User's Guide
\begin_inset Quotes erd
\end_inset

 is the authoritative reference.
 For the implementation details, which this document attempts to cover,
 the source code is currently the most up-to-date authority.
 However, this document may be useful in documenting the philosophy of the
 implementation, as well as some of the details of the implementation.
 Having said that\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
In this document, I develop, motivate, and explain the query-subset of the
 MQL language.
 MQL stands for 
\begin_inset Quotes eld
\end_inset

Mini QL
\begin_inset Quotes erd
\end_inset

, and its query-subset is a subset (though not a proper subset) of the QL
 language developed in Doedens' book.
\end_layout

\begin_layout Standard
Two key structures are developed in this chapter: The sheaf, which is a
 datastructure to hold the results of a query, and the syntax and semantics
 of MQL itself.
 The semantics of MQL are given in operational terms, making it relatively
 easy to implement in practice, given the right primitives.
 The operational specifications are given in terms of functions written
 in some Pascal-like language which is not defined rigorously here.
 Anyone familiar with procedural, imperative programming languages like
 Pascal, C, Oberon, etc.
 should have no difficulty reading the specifications.
\end_layout

\begin_layout Standard
In chapter 1, we first give some motivation for why MQL is necessary.
 We then touch briefly on the notion of `topographic languages' which Doedens
 defined in his dissertation.
 MQL is a topographic language.
 We then give the definition of three concepts, namely Universe,  Substrate,
 and inst(T,U).
 These are central in the semantic definition of MQL.
 We then list and explain some differences between Doedens' work and my
 work.
 After that, we give an informal introduction to MQL by means of some examples.
 This section should give the reader some 
\begin_inset Quotes eld
\end_inset

feel
\begin_inset Quotes erd
\end_inset

 for MQL which will be helpful when reading the rest of the chapter.
 
\end_layout

\begin_layout Standard
In Chapter 2, in which we lay a the foundation for the retrieval functions
 in Chapter 3, we start by giving the definition and explanation of the
 
\emph on
sheaf
\emph default
.
 The sheaf is the datastructure which holds the results of an MQL query.
 We then touch briefly on a possible architecture for an MQL query engine.
 Next, the notion of 
\begin_inset Quotes eld
\end_inset

focus objects
\begin_inset Quotes erd
\end_inset

 is investigated.
 Focus objects allow MQL to be useful even to applications that do not need
 the elaborate structure of the sheaf for its query results.
 The next section details quite a bit of information about MQL: Lexical
 rules for MQL, the grammar for MQL, the concatenation operators of MQL,
 object references (a substitute for variables), why and what to compile,
 focus objects, datatypes, mo_nr's, and standard arguments to functions.
 
\end_layout

\begin_layout Standard
In Chapter 3, we finally come to the retrieval functions making up the semantic
 specification of MQL.
 The first section givs a bird's eye overview of the retrieval functions.
 The next two sections, which is the bulk of this chapter, give the semantics
 of MQL in an operational specification.
 This is done by defining functions on syntactic units of MQL, and explaining
 them in plain English.
 The first of these two sections give semantic specifications of utility
 functions, while the second of the two sections provides the 
\begin_inset Quotes eld
\end_inset

meat
\begin_inset Quotes erd
\end_inset

, namely the retrieval functions matching the syntactic categories in the
 grammar of MQL.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
QL is a nice language, but it has one main drawback: It is very, very difficult
 to implement in practice, because it is so powerful, and its semantics
 are so abstract.
 The fact that Doedens gave the semantics as denotational semantics means
 that there is no easy path to follow from syntax and semantics to implementatio
n.
\end_layout

\begin_layout Standard
MQL attempts to address this problem.
 
\end_layout

\begin_layout Standard
One way of doing this has been to reduce the power of the language to a
 minimum, while still retaining power enough for 
\begin_inset Quotes eld
\end_inset

most applications
\begin_inset Quotes erd
\end_inset

, whatever that may be.
 The guiding design principle here has been to 
\begin_inset Quotes eld
\end_inset

take all elements from QL which are easily implementable, and to leave out
 the rest
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The other way of doing this has been to give the semantics of each syntactic
 construct in MQL, not as denotational semantics, but as an operational
 specification.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename TheDoor.eps
	display color
	width 100text%

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{TheDoor}

\end_inset

MdF example
\end_layout

\end_inset


\begin_inset VSpace 0.3cm
\end_inset


\end_layout

\begin_layout Section
The notion of `topographic languages'
\end_layout

\begin_layout Standard
In his PhD dissertation, Doedens defines a new notion, namely that of `topograph
ic languages'.
 A language is topographic if there are isomorphisms between the graphs
 denoting the structure of the expressions of the language and the graphs
 denoting the objects denoted by the expressions of the language.
 
\end_layout

\begin_layout Standard
QL (and, therefore, MQL) is a topographic language.
 This means that there is an isomorphism between the abstract syntax trees
 made from instances of QL- (and MQL-) queries and the graphs that could
 be drawn of the part_of relationships between objects in the MdF (or EMdF)
 database.
\end_layout

\begin_layout Section
Preliminary definitions
\end_layout

\begin_layout Subsection
Universe
\begin_inset LatexCommand \label{Universe}

\end_inset


\end_layout

\begin_layout Standard
A universe is a single contiguous string of monad_ms.
 This is not a definition taken from Doedens' book.
 In Doedens' book, a universe can be any set of monads.
 However, as a consequence of the semantics of MQL, what Doedens uses as
 a universe in QL is always a contiguous string of monads in MQL.
\end_layout

\begin_layout Subsection
Substrate
\end_layout

\begin_layout Standard
A substrate is a set of monad_ms.
 It may have gaps, but it always starts at some monad_m 
\begin_inset Formula $a$
\end_inset

 and ends at some monad_m 
\begin_inset Formula $b$
\end_inset

 (where 
\begin_inset Formula $b=a$
\end_inset

 is possible).
 It is always part_of the accompanying universe.
 The first and last monads of a substrate need not, however, be the same
 as the first and last monad of the accompanying universe.
\end_layout

\begin_layout Standard
The significance of substrates is that we match relative to substrates!
\end_layout

\begin_layout Subsection
inst(T,U)
\end_layout

\begin_layout Standard
A third concept which is central to the semantics of MQL is the inst(T,U)
 array.
 An inst(T,U) array is an array of object id_ds.
 It contains the object id_ds of all the objects of type T that are part_of
 the universe U.
 They are not assumed to be in any particular order.
\end_layout

\begin_layout Standard
Since U is a universe, we may calculate inst(T,U) by looking for all those
 objects of type T that are wholly contained in U.
 I.e., inst(T,U) contains the object id_ds of all the objects O of type T
 for which the following holds:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
U.first() 
\begin_inset Formula $\leq$
\end_inset

O.first() 
\begin_inset Formula $\wedge$
\end_inset

O.last() 
\begin_inset Formula $\leq$
\end_inset

U.last()
\end_layout

\begin_layout Section
Changes from Doedens' work
\end_layout

\begin_layout Standard
This section details the changes that I have made to QL in order to obtain
 MQL.
 It assumes a lot of familiarity with Doedens' work.
\end_layout

\begin_layout Standard
The core elements are still there -- 
\family typewriter
topograph
\family default
, 
\family typewriter
blocks
\family default
, 
\family typewriter
block_string
\family default
, 
\family typewriter
block
\family default
, and 
\family typewriter
object_block
\family default
.
 The 
\family typewriter
power_block
\family default
 is also there, but in another form.
\end_layout

\begin_layout Standard
The main change, semantics-wise, is that a 
\family typewriter
blocks
\family default
 need 
\emph on
not
\emph default
 match the whole universe.
 Thus there is no need for 
\begin_inset Quotes eld
\end_inset


\family typewriter
..
\family default

\begin_inset Quotes erd
\end_inset

 before and after the 
\family typewriter
object_block
\family default
s which one wishes to retrieve.
\end_layout

\begin_layout Standard
Instead, the first block in a 
\family typewriter
block_string
\family default
 has to be a special 
\family typewriter
object_block
\family default
, called 
\family typewriter
object_block_first
\family default
, which can optionally be specified as having to be the first in the universe.
 The semantics-function for this 
\family typewriter
object_block_first
\family default
 is passed an 
\emph on
index
\emph default
 into an inst(T,U) array.
 The semantics function for 
\family typewriter
object_block_first
\family default
 does not return until it either finds the next match within this array
 (starting at the index), or it exhausts the array.
\end_layout

\begin_layout Standard
Note that I have changed the definition of a 
\family typewriter
sheaf
\family default
 slightly, but not much.
 The main difference is that a 
\family typewriter
matched_object
\family default
 can now be several different things, which it couldn't in Doedens' definition
 of the 
\family typewriter
sheaf
\family default
.
\end_layout

\begin_layout Standard
Also, there is no provision for extracting 
\emph on
features
\emph default
 into the 
\family typewriter
sheaf
\family default
.
 It is assumed that the implementation only wishes to obtain object_id's
 from the MQL engine, and that the objects themselves can then be inspected
 for features if desired.
 This saves memory.
\end_layout

\begin_layout Standard
There is no provision for variables.
 Instead, there is a provision for 
\emph on
object references
\emph default
.
 An object reference is a way of referring to an object in another part
 of the query.
 For example, we might declare an object reference 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset

 for an object of type 
\begin_inset Quotes eld
\end_inset

Word.
\begin_inset Quotes erd
\end_inset

 Then, later in the query, we can refer to features of the object previously
 found by using 
\begin_inset Quotes eld
\end_inset

dotted notation,
\begin_inset Quotes erd
\end_inset

 e.g., 
\begin_inset Quotes eld
\end_inset

w.gender
\begin_inset Quotes erd
\end_inset

 for the 
\begin_inset Quotes eld
\end_inset

gender
\begin_inset Quotes erd
\end_inset

 feature of the 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset

 object.
\end_layout

\begin_layout Standard
When comparing a feature with a given value, all the six standard comparisons
 can be used: 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

<>
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

<=
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

>=
\begin_inset Quotes erd
\end_inset

.
 Note also that a feature is compared with a singular value.
 This differs from QL, where a feature must be a member of a 
\emph on
set 
\emph default
of values for the query to match.
\end_layout

\begin_layout Standard
I have also restricted the types of values to be
\end_layout

\begin_layout Itemize
enumeration constants (for things like 
\begin_inset Quotes eld
\end_inset


\family typewriter
singular
\family default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
plural
\family default

\begin_inset Quotes erd
\end_inset

, etc.)
\end_layout

\begin_layout Itemize
integers
\end_layout

\begin_layout Itemize
strings
\end_layout

\begin_layout Itemize
id_ds
\end_layout

\begin_layout Standard
MQL introduces the notion of 
\begin_inset Quotes eld
\end_inset

focus objects.
\begin_inset Quotes erd
\end_inset

 An object can be declared to be 
\begin_inset Quotes eld
\end_inset

in focus
\begin_inset Quotes erd
\end_inset

 by placing the keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default

\begin_inset Quotes erd
\end_inset

 in the 
\family typewriter
object_block
\family default
 or 
\family typewriter
object_block_first
\family default
 which corresponds to the object.
 When an object is 
\begin_inset Quotes eld
\end_inset

in focus,
\begin_inset Quotes erd
\end_inset

 it means two things: Firstly, it is retrieved into the sheaf.
 Secondly, the sheaf can, after the query has executed, be 
\begin_inset Quotes eld
\end_inset

sifted
\begin_inset Quotes erd
\end_inset

 to obtain exactly those objects that are 
\begin_inset Quotes eld
\end_inset

in focus
\begin_inset Quotes erd
\end_inset

 an no other objects.
\end_layout

\begin_layout Standard
The sheaf has been changed so that it is no longer explicitly based on sets.
 Rather, it is based on lists.
 The reason why this is allowable is that the semantics of MQL guarantee
 that no two identical 
\family typewriter
matched_object
\family default
s get into the sheaf, and no two identical 
\family typewriter
straw
\family default
s get into the sheaf.
\end_layout

\begin_layout Section
Informal introduction to MQL by means of some examples
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
This section informally introduces MQL by way of a number of examples.
 The example database which we will use is the same as in Doedens' book,
 namely part of Melville's 
\begin_inset Quotes eld
\end_inset

Moby Dick
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

CALL me Ishmael.
 Some years ago - never mind how long precisely - having little or no money
 in my purse, and nothing particular to interest me on shore, I thought
 I would sail about a little and see the watery part of the world.
 It is a way I have of driving off the spleen, and regulating the circulation.
 Whenever I find myself growing grim about the mouth; whenever it is damp,
 drizzly November in my soul; whenever I find myself involuntarily pausing
 before coffin warehouses, and bringing up the rear of every funeral I meet;
 and especially whenever my hypos get such an upper hand of me, that it
 requires a strong moral principle to prevent me from deliberately stepping
 into the street, and methodically knocking people's hats off - then, I
 account it high time to get to sea as soon as I can.
 [...]
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

[...] By reason of these things, then, the whaling voyage was welcome; the
 great flood-gates of the wonder-world swung open, and in the wild conceits
 that swayed me to my purpose, two and two there floated into my inmost
 soul, endless procesions of the whale, and, mid most of them all, one grand
 hoofed phantom, like a snow hill in the air.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Suppose that we have in this EMdF database the domain-dependent object types
 
\begin_inset Quotes eld
\end_inset

paragraph
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

sentence
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

, which correspond to paragraphs, sentences, and words of the text.
 And suppose that we add to the object type 
\begin_inset Quotes eld
\end_inset

sentence
\begin_inset Quotes erd
\end_inset

 the feature 
\begin_inset Quotes eld
\end_inset

mood
\begin_inset Quotes erd
\end_inset

, which draws its values from the enumeration type { imperative, declarative
 }.
 And suppose that we add to the object type 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

 the features 
\begin_inset Quotes eld
\end_inset

surface
\begin_inset Quotes erd
\end_inset

 (which gives the surface text of the word) and 
\begin_inset Quotes eld
\end_inset

part_of_speech
\begin_inset Quotes erd
\end_inset

 (which gives the part of speech of the word).
 The codomain of the feature 
\begin_inset Quotes eld
\end_inset

part_of_speech
\begin_inset Quotes erd
\end_inset

 on the object type 
\begin_inset Quotes eld
\end_inset

word
\begin_inset Quotes erd
\end_inset

 draws its values from the enumeration type { adjective, adverb, conjunction,
 determiner, noun, numeral, particle, preposition, pronoun, verb }.
 This hypothetical database will give the background for most of the examples
 in our informal introduction to MQL.
\end_layout

\begin_layout Subsection
A query does not match the whole database
\end_layout

\begin_layout Standard
In the QL language in Doedens' book, a query matches the whole database.
 This need not hold true for an MQL query, for two reasons.
 First, because the universe and substrate over which an MQL query is processed
 need not be the whole database.
 And second, because the syntactic construction of an MQL query does not
 reflect any supposition that a query matches the whole database, as a QL
 query does.
\end_layout

\begin_layout Subsection
topograph
\end_layout

\begin_layout Standard
An MQL query is called a topograph.
 Consider the following topograph:
\end_layout

\begin_layout LyX-Code
[sentence]
\end_layout

\begin_layout Standard
This topograph retrieves a list of all sentence objects in the database.
 
\end_layout

\begin_layout Subsection
features
\end_layout

\begin_layout Standard
A query can specify which features an object must have for it to be retrieved.
 For example, consider the following topograph:
\end_layout

\begin_layout LyX-Code
[word
\end_layout

\begin_layout LyX-Code
   surface = "Ishmael" or part_of_speech = verb;
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
This topograph retrieves a list of all words which either have the surface
 
\begin_inset Quotes eld
\end_inset

Ishmael
\begin_inset Quotes erd
\end_inset

, or whose part of speech is 
\begin_inset Quotes eld
\end_inset

verb
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
object_block, object_block_first
\end_layout

\begin_layout Standard
There are several types of blocks.
 They are meant to come in a string of blocks, where each block in the string
 must match some part of the database in order for the whole string to match.
 Two such blocks are the 
\family typewriter
object_block
\family default
 and the 
\family typewriter
object_block_first
\family default
.
\end_layout

\begin_layout Standard
Object blocks are the heart and soul of MQL queries.
 They are used to match objects and objects nested in other objects.
 An object block (be it an 
\family typewriter
object_block
\family default
 or an 
\family typewriter
object_block_first
\family default
) consists of the following parts:
\end_layout

\begin_layout Enumerate
The opening square bracket, `
\family typewriter
[
\family default
'.
\end_layout

\begin_layout Enumerate
An identifier indicating the object type of the objects which we wish to
 match.
\end_layout

\begin_layout Enumerate
An optional 
\begin_inset Quotes eld
\end_inset

object reference declaration.
\begin_inset Quotes erd
\end_inset

 A reference to this object can be declared witht the 
\begin_inset Quotes eld
\end_inset


\family typewriter
as
\family default

\begin_inset Quotes erd
\end_inset

 keyword, like 
\begin_inset Quotes eld
\end_inset


\family typewriter
[word as w
\family default
 
\begin_inset Formula $\ldots$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Subsequent blocks can then refer to features of this object as 
\begin_inset Quotes eld
\end_inset


\family typewriter
w
\family default
.
\emph on
featurename
\emph default

\begin_inset Quotes erd
\end_inset

 .
\end_layout

\begin_layout Enumerate
An optional keyword which can be either of 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default

\begin_inset Quotes erd
\end_inset

.
 The default, when it is not specified, is 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

.
 The keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default

\begin_inset Quotes erd
\end_inset

 says as much as 
\begin_inset Quotes eld
\end_inset

I do not wish to retrieve this object, even if matched
\begin_inset Quotes erd
\end_inset

.
 It is useful for specifying the context of what we really wish to retrieve.
 The keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default

\begin_inset Quotes erd
\end_inset

 specifies that this object is to be retrieved (it implies 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

), and also that, when sifting the sheaf for focus objects, this object
 must go into the result.
\end_layout

\begin_layout Enumerate
An optional keyword, 
\begin_inset Quotes eld
\end_inset


\family typewriter
first
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
last
\family default

\begin_inset Quotes erd
\end_inset

, which says as much as 
\begin_inset Quotes eld
\end_inset

this object must be first/last in the universe against which we are matching.
\end_layout

\begin_layout Enumerate
An optional Boolean expression giving what features need to hold true for
 this object for it to be retrieved.
\end_layout

\begin_layout Enumerate
An optional inner 
\family typewriter
blocks
\family default
 which matches objects inside the object.
\end_layout

\begin_layout Enumerate
The closing square bracket, `
\family typewriter
]
\family default
'.
\end_layout

\begin_layout Standard
Note that only the first object block in a string of blocks can have the
 
\begin_inset Quotes eld
\end_inset


\family typewriter
first
\family default

\begin_inset Quotes erd
\end_inset

 keyword, and only the last 
\family typewriter
object_block
\family default
 in a string of 
\family typewriter
block
\family default
s can have the 
\begin_inset Quotes eld
\end_inset


\family typewriter
last
\family default

\begin_inset Quotes erd
\end_inset

 keyword.
 
\end_layout

\begin_layout Standard
Consider the following 
\family typewriter
topograph
\family default
:
\end_layout

\begin_layout LyX-Code
[sentence
\end_layout

\begin_layout LyX-Code
    mood = imperative;
\end_layout

\begin_layout LyX-Code
    [word noretrieve first
\end_layout

\begin_layout LyX-Code
         surface = "CALL";
\end_layout

\begin_layout LyX-Code
    ]
\end_layout

\begin_layout LyX-Code
    [word]
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
This 
\family typewriter
topograph
\family default
 retrieves the set of sentences which are imperative, and whose first word
 is 
\begin_inset Quotes eld
\end_inset

CALL
\begin_inset Quotes erd
\end_inset

.
 Within each sentence in that set, we retrieve the second word, but not
 the first.
 The only sentence in our example database which qualifies is the first
 sentence.
\end_layout

\begin_layout Subsection
power
\end_layout

\begin_layout Standard
The power construct is used to indicate that we allow some distance in between
 two blocks.
 A power construct must always stand between two other blocks, and can thus
 never be first or last in a query.
 It comes in two varieties: 
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

plain vanilla
\begin_inset Quotes erd
\end_inset

 power construct, syntactically denoted by two dots, 
\begin_inset Quotes eld
\end_inset


\family typewriter
..
\family default

\begin_inset Quotes erd
\end_inset

, and 
\end_layout

\begin_layout Itemize
A power construct with a limit.
 The limit specifies the maximum monads that can intervene between the two
 surrounding blocks.
 It is denoted as e.g., 
\begin_inset Quotes eld
\end_inset


\family typewriter
..\InsetSpace ~
<\InsetSpace ~
5
\family default

\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Consider the following topograph:
\end_layout

\begin_layout LyX-Code
[sentence
\end_layout

\begin_layout LyX-Code
    [word
\end_layout

\begin_layout LyX-Code
        part_of_speech = preposition]
\end_layout

\begin_layout LyX-Code
    ..
 < 4
\end_layout

\begin_layout LyX-Code
    [word
\end_layout

\begin_layout LyX-Code
        part_of_speech = noun]
\end_layout

\begin_layout LyX-Code
    ..
\end_layout

\begin_layout LyX-Code
    [word last
\end_layout

\begin_layout LyX-Code
        surface = "world"]
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
This topograph retrieves a list of sentences which have a word that has
 part of speech preposition, followed by a word which has part of speech
 noun, and which is within 4 monads of the preposition, followed by the
 last word of the sentence, which must be 
\begin_inset Quotes eld
\end_inset

world
\begin_inset Quotes erd
\end_inset

.
 Within that sentence, retrieve all the three words.
 The only sentence which qualifies is the second.
\end_layout

\begin_layout Subsection
opt_gap_block
\end_layout

\begin_layout Standard
An 
\family typewriter
opt_gap_block
\family default
 is used to match an optional gap in the text.
 It consists of:
\end_layout

\begin_layout Enumerate
The opening square bracket, `
\family typewriter
[
\family default
'.
\end_layout

\begin_layout Enumerate
The keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
gap?
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
An optional 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default
,
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default
.
\begin_inset Quotes erd
\end_inset

 The default is 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
An 
\family typewriter
opt_blocks
\family default
.
\end_layout

\begin_layout Enumerate
The closing square bracket, `
\family typewriter
]
\family default
'.
\end_layout

\begin_layout Standard
The 
\family typewriter
opt_gap_block
\family default
 matches gaps in the 
\emph on
subtrate
\emph default
 against which we are matching.
 Thus if we look at the example in figure 
\begin_inset LatexCommand \vref{TheDoor}

\end_inset

, we can construct the following topograph:
\end_layout

\begin_layout LyX-Code
[clause
\end_layout

\begin_layout LyX-Code
    [clause_atom
\end_layout

\begin_layout LyX-Code
        [word
\end_layout

\begin_layout LyX-Code
             surface = "door,"
\end_layout

\begin_layout LyX-Code
        ]
\end_layout

\begin_layout LyX-Code
    ]
\end_layout

\begin_layout LyX-Code
    [gap? noretrieve]
\end_layout

\begin_layout LyX-Code
    [clause_atom noretrieve]
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
This retrieves all clauses which happen to have inside them a clause_atom
 which contains the word 
\begin_inset Quotes eld
\end_inset

door,
\begin_inset Quotes erd
\end_inset

, followed by a gap, followed by a clause_atom.
 The gap and the second clause_atom are not retrieved.
 This would retrieve clause-1.
 The gap need not be there.
 Since this is the case, Clause-2 would also be retrieved, were it not for
 the fact that it contains no word 
\begin_inset Quotes eld
\end_inset

door,
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The default is for the result of an opt_gap_block not to be retrieved.
 Thus one needs to explicitly write 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

 if one wishes to retrieve the gap.
\end_layout

\begin_layout Subsection
gap_block
\end_layout

\begin_layout Standard
A 
\family typewriter
gap_block
\family default
 is used to match a gap in the text.
 It consists of:
\end_layout

\begin_layout Enumerate
The opening square bracket, `
\family typewriter
[
\family default
'.
\end_layout

\begin_layout Enumerate
The keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
gap
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
An optional 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default
,
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default
.
\begin_inset Quotes erd
\end_inset

 The default is 
\begin_inset Quotes eld
\end_inset


\family typewriter
noretrieve
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
An 
\family typewriter
opt_blocks
\family default
.
\end_layout

\begin_layout Enumerate
The closing square bracket, `
\family typewriter
]
\family default
'.
\end_layout

\begin_layout Standard
The 
\family typewriter
gap_block
\family default
 is analogous to the 
\family typewriter
opt_gap_block
\family default
 in all respects except that there must be a gap in order for the query
 to match.
\end_layout

\begin_layout Subsection
object references
\end_layout

\begin_layout Standard
An object reference is a name given to a previously retrieved object with
 the 
\begin_inset Quotes eld
\end_inset


\family typewriter
as
\family default
 
\emph on
identifier
\emph default

\begin_inset Quotes erd
\end_inset

 declaration.
 An object reference can then be used in subsequent comparisons with features
 of other objects.
 This is done by selecting the desired feature from the object reference
 by using dot-notation, as in the example below:
\end_layout

\begin_layout LyX-Code
[word as w
\end_layout

\begin_layout LyX-Code
    part_of_speech = article;
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout LyX-Code
[word
\end_layout

\begin_layout LyX-Code
   (part_of_speech = noun 
\end_layout

\begin_layout LyX-Code
    or part_of_speech = adjective)
\end_layout

\begin_layout LyX-Code
    and case = w.case 
\end_layout

\begin_layout LyX-Code
    and number = w.number 
\end_layout

\begin_layout LyX-Code
    and gender = w.gender;
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
Assuming that the 
\family typewriter
word
\family default
 object type has features part_of_speech, case, number, and gender, this
 topograph retrieves all pairs of words which satisfy the following conditions:
 
\end_layout

\begin_layout Itemize
The first word has part of speech 
\begin_inset Quotes eld
\end_inset

article
\begin_inset Quotes erd
\end_inset

,
\end_layout

\begin_layout Itemize
The second word has part of speech 
\begin_inset Quotes eld
\end_inset

noun
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

adjective
\begin_inset Quotes erd
\end_inset

, and
\end_layout

\begin_layout Itemize
Both words have the same case, number, and gender.
\end_layout

\begin_layout Standard
This concludes our gentle, informal introduction to MQL.
\end_layout

\begin_layout Chapter
Laying the foundation
\end_layout

\begin_layout Section
Sheaf
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
The 
\family typewriter
sheaf
\family default
 is the datastructure which holds the results of an MQL query.
 It has been amended slightly from the sheaf in Doedens' book.
 The reason for choosing to use a sheaf-like structure to hold the results
 of an MQL query is this: I found that, even though the sheaf is a little
 hard to understand, it nicely captures the results we expect from a query,
 as well as the topographic nature of MQL queries.
\end_layout

\begin_layout Standard
The 
\family typewriter
sheaf
\family default
 is a list of 
\family typewriter
straw
\family default
s.
 A 
\family typewriter
straw
\family default
 is a list of 
\family typewriter
matched_object
\family default
s.
 A 
\family typewriter
matched_object
\family default
 denotes a 
\begin_inset Quotes eld
\end_inset

hit
\begin_inset Quotes erd
\end_inset

 of one block against an object or a gap in the database.
 A 
\family typewriter
matched_object
\family default
 can, in two of its syntactic incarnations, have a 
\family typewriter
sheaf
\family default
 inside it, thus capturing the embedding that can take place in hierarchies
 of MdF object types.
\end_layout

\begin_layout Subsection
Grammar
\end_layout

\begin_layout Standard
The grammar for the sheaf is:
\end_layout

\begin_layout LyX-Code
sheaf  :  "//"
\end_layout

\begin_layout LyX-Code
       |  "//" list_of_straws  ;
\end_layout

\begin_layout LyX-Code
list_of_straws  :  "< >"  | "<" straws ">"
\end_layout

\begin_layout LyX-Code
straws : straw  | straws straw 
\end_layout

\begin_layout LyX-Code
straw  :  "< >"  |  "<" matched_objects ">" ;
\end_layout

\begin_layout LyX-Code
matched_objects  :  matched_object  
\end_layout

\begin_layout LyX-Code
                 |  matched_objects  matched_object  ;
\end_layout

\begin_layout LyX-Code
matched_object  :  NIL_mo  
\end_layout

\begin_layout LyX-Code
                |  EMPTY_mo  
\end_layout

\begin_layout LyX-Code
                |  '['  OBJECT_ID_D  focus  sheaf  ']' 
\end_layout

\begin_layout LyX-Code
                |  '['  OBJECT_ID_M  focus  sheaf  ']'  ;
\end_layout

\begin_layout Subsection
Explanation
\end_layout

\begin_layout Standard
As already remarked, a 
\family typewriter
sheaf
\family default
 is a list of 
\family typewriter
straw
\family default
s, and a 
\family typewriter
straw
\family default
 is a list of 
\family typewriter
matched_object
\family default
s.
 We begin our discussion of the 
\family typewriter
sheaf
\family default
 by explaining in detail what a 
\family typewriter
matched_object
\family default
 is.
\end_layout

\begin_layout Subsubsection
matched_object
\end_layout

\begin_layout Standard
A 
\family typewriter
matched_object
\family default
 can be one of four things:
\end_layout

\begin_layout Enumerate

\family typewriter
NIL_mo
\end_layout

\begin_layout Enumerate

\family typewriter
EMPTY_mo
\end_layout

\begin_layout Enumerate
an object id_d, a 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean, and a 
\family typewriter
sheaf
\family default
.
\end_layout

\begin_layout Enumerate
an object id_m, a 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean, and a 
\family typewriter
sheaf
\family default
.
\end_layout

\begin_layout Standard
The first syntactic incarnation, 
\family typewriter
NIL_mo
\family default
, conveys the information that a match failed.
 It never gets into any 
\family typewriter
straw
\family default
.
 It is meant only to convey information while processing an MQL query.
\end_layout

\begin_layout Standard
The second syntact incarnation, 
\family typewriter
EMPTY_mo
\family default
, conveys the information that an 
\family typewriter
opt_gap_block
\family default
 was successfully matched against an empty stretch of the database.
 That is, even though there was no gap in the database, the match succeeded
 because the gap was optional.
 Like the 
\family typewriter
NIL_mo
\family default
 syntactic incarnation, it never gets into any 
\family typewriter
straw
\family default
.
\end_layout

\begin_layout Standard
The third syntactic incarnation conveys the information that the object
 with the given object id_d was matched successfully against an 
\family typewriter
object_block
\family default
 or an 
\family typewriter
object_block_first
\family default
.
 It does get into 
\family typewriter
straw
\family default
s.
 The 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean shows whether the object is in focus or not.
 It has a sheaf inside it which contains the results of the optional 
\family typewriter
blocks
\family default
 in the 
\family typewriter
object_block
\family default
 or 
\family typewriter
object_block_first
\family default
.
\end_layout

\begin_layout Standard
The fourth syntactic incarnation conveys the information that an 
\family typewriter
opt_gap_block
\family default
 or a 
\family typewriter
gap_block
\family default
 was successfully matched against a gap in the database.
 Since it is an object id_m, it is the set of monads belonging to a pow_m
 object.
 It also gets into straws.
 The 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean shows whether the pow_m-object is in focus or not.
 The opt_blocks matches a 
\family typewriter
blocks
\family default
 with the gap as both the universe and the substrate.
\end_layout

\begin_layout Subsubsection
straw
\end_layout

\begin_layout Standard
A 
\family typewriter
straw
\family default
 is a list of 
\family typewriter
matched_object
\family default
s.
 The intuition of a 
\family typewriter
straw
\family default
 is that it denotes a 
\begin_inset Quotes eld
\end_inset

string
\begin_inset Quotes erd
\end_inset

 of 
\family typewriter
matched_object
\family default
s.
 The sequence of the string is that of the objects in the database that
 matched a 
\family typewriter
block_string
\family default
 part of a given query.
 A straw constitutes one matching of a 
\family typewriter
block_string
\family default
.
\end_layout

\begin_layout Standard
For example, consider the following topograph:
\end_layout

\begin_layout LyX-Code
[word
\end_layout

\begin_layout LyX-Code
   surface = "the";
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout LyX-Code
[word
\end_layout

\begin_layout LyX-Code
   part_of_speech = noun;
\end_layout

\begin_layout LyX-Code
]
\end_layout

\begin_layout Standard
This will return a 
\family typewriter
sheaf
\family default
 with as many 
\family typewriter
straw
\family default
s as there are pairs of adjacent words where the first is the word 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

 and the second is a noun.
 Each 
\family typewriter
straw
\family default
 will contain two 
\family typewriter
matched_object
\family default
s, one for each word.
\end_layout

\begin_layout Subsubsection
sheaf
\end_layout

\begin_layout Standard
A 
\family typewriter
sheaf
\family default
 is a list of 
\family typewriter
straw
\family default
s.
 It can be one of the following things:
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset


\family typewriter
//
\family default

\begin_inset Quotes erd
\end_inset

, in which case the matching failed, or
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset


\family typewriter
// 
\family default
< >
\begin_inset Quotes erd
\end_inset

, in which case the matching did not fail, but the results were empty, or
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset


\family typewriter
//
\family default

\begin_inset Quotes erd
\end_inset

 followed by a nonempty set of straws, which constitutes a nonempty successful
 match.
\end_layout

\begin_layout Standard
See the preceding section on the 
\begin_inset Quotes eld
\end_inset

straw
\begin_inset Quotes erd
\end_inset

 for an example.
\end_layout

\begin_layout Standard
While a 
\family typewriter
straw
\family default
 is like a string (of 
\family typewriter
matched_object
\family default
s), the 
\family typewriter
sheaf
\family default
 need not be like a string.
\end_layout

\begin_layout Subsubsection
Correlation of sheaf-structures and MQL-structures
\end_layout

\begin_layout Standard
This section explains in a little more detail the correlation between sheaf-stru
ctures and MQL-structures.
 It assumes familiarity with certain MQL-constructs.
 Therefore, it may be skimmed or skipped until a thorough understanding
 of MQL has been gained.
 The reader is then advised to return to this section, and even to refer
 back to it as he or she reads through the exposition on MQL.
\end_layout

\begin_layout Standard
Because MQL is a topographic language, there should also be topographicity
 between the results of a query and the query from which it was constructed.
\end_layout

\begin_layout Paragraph
sheaf
\end_layout

\begin_layout Standard
A 
\family typewriter
sheaf
\family default
 constitutes a matching of a 
\family typewriter
blocks
\family default
.
 Note that there are two places in the MQL grammar which refer to a 
\family typewriter
blocks
\family default
:
\end_layout

\begin_layout Itemize
One is the top-level start symbol, 
\family typewriter
topograph
\family default
.
 This means that the result of a query is a 
\family typewriter
sheaf
\family default
.
 
\end_layout

\begin_layout Itemize
The other is 
\family typewriter
opt_blocks
\family default
.
 The 
\family typewriter
opt_blocks
\family default
 syntactic construct is used in two places: in an 
\family typewriter
object_block_first
\family default
 and in an 
\family typewriter
object_block
\family default
.
 It can either be a 
\family typewriter
blocks
\family default
, meaning that we want to match something inside the 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
), or it can be empty, meaning that we put no restrictions on what must
 be inside the 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
).
 If it is a 
\family typewriter
blocks
\family default
, the result will, of course, be a 
\family typewriter
sheaf
\family default
.
 This is why the third syntactic incarnation of a 
\family typewriter
matched_object
\family default
 has a 
\family typewriter
sheaf
\family default
 inside it.
\end_layout

\begin_layout Paragraph
straw
\end_layout

\begin_layout Standard
A 
\family typewriter
straw
\family default
 constitutes once matching of a 
\family typewriter
block_string
\family default
.
 However, the result of a match of a 
\family typewriter
block_string
\family default
 is a 
\emph on
list of 
\family typewriter
\emph default
straw
\family default
\emph on
s
\emph default
, not a single 
\family typewriter
straw
\family default
! The list of straws is based on one object in the inst(T,U) array, and
 in that sense, it is one matching.
\end_layout

\begin_layout Paragraph
matched_object
\end_layout

\begin_layout Standard
A 
\family typewriter
matched_object
\family default
 constitutes a match of a block of some kind, be it an 
\family typewriter
object_block_first
\family default
, an 
\family typewriter
object_block
\family default
, an 
\family typewriter
opt_gap_block
\family default
, or a 
\family typewriter
gap_block
\family default
.
\end_layout

\begin_layout Subsection
Lists and concatenation
\end_layout

\begin_layout Standard
The lists used in an implementation of MQL must be optimized for both prepending
 and appending.
 In addition, they must be easily copiable.
 (?)
\end_layout

\begin_layout Standard
In this document, we will express concatenation with the 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

 operator.
\end_layout

\begin_layout Section
An architecture for an MQL query engine
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{architecture}

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename architecture.eps
	display color
	width 80text%

\end_inset


\end_layout

\begin_layout Caption
An architecture for an MQL query engine
\end_layout

\begin_layout Standard
\align center
\begin_inset LatexCommand \label{architectureFig}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 
\begin_inset LatexCommand \vref{firstlast_explanation}

\end_inset

, we have suggested an architecture for an MQL query engine.
 The figure should be straightforward to read and should deserve no further
 comment.
\end_layout

\begin_layout Section
Focus-objects
\end_layout

\begin_layout Standard
The section giving an informal introduction to MQL explained that an object
 can be a 
\begin_inset Quotes eld
\end_inset

focus object.
\begin_inset Quotes erd
\end_inset

 To the sheaf, the only difference between being a 
\begin_inset Quotes eld
\end_inset

focus object
\begin_inset Quotes erd
\end_inset

 and being an object for ordinary retrieval is that, in the 
\family typewriter
matched_object
\family default
 which denotes the object, the 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean is either true or false.
 This is of no consequence in the building of the sheaf.
\end_layout

\begin_layout Standard
However, once a sheaf has been built, various operations can be done on
 it.
 One is to extract all the objects whose 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 boolean is 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

.
 We will expand on this next.
\end_layout

\begin_layout Subsection
Sifting a sheaf for focus objects
\end_layout

\begin_layout Standard
Once a sheaf has been constructed, it can be 
\begin_inset Quotes eld
\end_inset

sifted
\begin_inset Quotes erd
\end_inset

 to extract sets of object ids for each object type involved.
 
\end_layout

\begin_layout Standard
The notation for sifting a sheaf 
\begin_inset Formula $S$
\end_inset

 for focus-objects is 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $S$
\end_inset

|focus
\begin_inset Quotes erd
\end_inset

.
 The result of such an operation is a set of sets of object ids.
 Each set of object ids in the big set contains the ids of all the focus-objects
 in 
\begin_inset Formula $S$
\end_inset

 from a given type 
\begin_inset Formula $T$
\end_inset

.
 Thus each set of ids corresponds to one object type 
\begin_inset Formula $T$
\end_inset

.
 For all other types than pow_m, the object ids are object id_ds.
 For the pow_m object type, the object ids are object id_ms.
\begin_inset Foot
status collapsed

\begin_layout Standard
The reason I do not mention the other special object types, any_m and all_m,
 is that these types can never get into a sheaf.
 This is guaranteed by the semantics of the query-subset of MQL.
\end_layout

\end_inset

 Once a sheaf has been sifted for focus objects, one can select the set
 belonging to a given type from the big set.
 The notation for doing so is 
\begin_inset Formula $S$
\end_inset

|focus.
\begin_inset Formula $T$
\end_inset

 for the sheaf 
\begin_inset Formula $S$
\end_inset

 and the object type 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Section
MQL
\end_layout

\begin_layout Subsection
Lexical rules
\end_layout

\begin_layout Standard
Whitespace is to be ignored in the lexer, except as delimiters of tokens
 and in strings.
 The token 
\family typewriter
T_IDENTIFIER
\family default
 is any identifier valid in C or Pascal.
 The token 
\family typewriter
T_STRING
\family default
 is a string enclosed in "double quotes".
 The token 
\family typewriter
T_INTEGER
\family default
 is any integer, positive or negative.
 The lexer is case 
\emph on
in
\emph default
sensitive.
 
\end_layout

\begin_layout Subsection
Grammar
\begin_inset LatexCommand \label{MQLgrammar}

\end_inset


\end_layout

\begin_layout Standard
In this section, we give the full grammar of MQL.
 It is specified using Bison/Yacc syntax.
\end_layout

\begin_layout Standard
This grammar has been tested with Bison and has been found to be unambiguous
 and LALR(1).
\end_layout

\begin_layout Standard
The full bison-grammar for MQL is:
\end_layout

\begin_layout LyX-Code
%token T_INTEGER                    /* An integer */
\end_layout

\begin_layout LyX-Code
%token T_STRING                     /* A quoted string */
\end_layout

\begin_layout LyX-Code
%token T_IDENTIFIER                 /* A C identifier */
\end_layout

\begin_layout LyX-Code
%token T_KEY_NORETRIEVE             /* "noretrieve" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_RETRIEVE               /* "retrieve" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_FOCUS                  /* "focus" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_FIRST                  /* "first" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_LAST                   /* "last" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_OR                     /* "or" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_AND                    /* "and" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_NOT                    /* "not" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_GAP                    /* "gap" */ 
\end_layout

\begin_layout LyX-Code
%token T_KEY_OPT_GAP                /* "gap?" */ 
\end_layout

\begin_layout LyX-Code
%token T_KEY_POWER                  /* ".." */  
\end_layout

\begin_layout LyX-Code
%token T_KEY_AS                     /* "as" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_EQUALS                 /* "=" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_LESS_THAN              /* "<" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_GREATER_THAN           /* ">" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_NOT_EQUAL              /* "<>" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_LESS_THAN_OR_EQUAL     /* "<=" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_GREATER_THAN_OR_EQUAL  /* ">=" */
\end_layout

\begin_layout LyX-Code
%token T_KEY_TILDE                  /* "~" : Regular expressions */
\end_layout

\begin_layout LyX-Code
%token T_KEY_NOT_TILDE              /* "!~" : Negated regular expr.*/
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
%%
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
topograph : blocks ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
blocks : block_string  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
block_string  : block_str  |  block_str  power  block_string ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
block_str : object_block_first  
\end_layout

\begin_layout LyX-Code
          |  object_block_first  '!' rest_of_block_str  
\end_layout

\begin_layout LyX-Code
          |  object_block_first  rest_of_block_str  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_block_first : '['  object_type_name  
\end_layout

\begin_layout LyX-Code
                     object_reference_declaration
\end_layout

\begin_layout LyX-Code
                     retrieval  firstlast  features  
\end_layout

\begin_layout LyX-Code
                     opt_blocks  ']'  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_type_name : T_IDENTIFIER ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_reference_declaration : /* empty */ 
\end_layout

\begin_layout LyX-Code
                             | T_KEY_AS object_reference ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_reference : T_IDENTIFIER ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
retrieval : /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
          |  T_KEY_RETRIEVE  |  T_KEY_FOCUS ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
firstlast  :  /* empty */  |  T_KEY_FIRST  |  T_KEY_LAST  
\end_layout

\begin_layout LyX-Code
           |  T_KEY_FIRST  T_KEY_AND  T_KEY_LAST ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
features  :  /* empty */  |  ffeatures ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
ffeatures  :  fterm  |  ffeatures T_KEY_OR fterm ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
fterm : ffactor  |  ffactor T_KEY_AND fterm  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
ffactor :  T_KEY_NOT  ffactor  |  '('  ffeatures  ')'  
\end_layout

\begin_layout LyX-Code
        |  feature_comparison ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
feature_comparison : feature_name comparison_operator value  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
feature_name  :  T_IDENTIFIER  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
comparison_operator : T_KEY_EQUALS | T_KEY_LESS_THAN 
\end_layout

\begin_layout LyX-Code
                    | T_KEY_GREATER_THAN | T_KEY_NOT_EQUAL
\end_layout

\begin_layout LyX-Code
                    | T_KEY_LESS_THAN_OR_EQUAL
\end_layout

\begin_layout LyX-Code
                    | T_KEY_GREATER_THAN_OR_EQUAL 
\end_layout

\begin_layout LyX-Code
                    | T_KEY_TILDE
\end_layout

\begin_layout LyX-Code
                    | T_KEY_NOT_TILDE  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
value  :  enum_const  |  T_INTEGER  |  T_STRING  
\end_layout

\begin_layout LyX-Code
       |  object_reference_usage  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
enum_const  :  T_IDENTIFIER  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_reference_usage : object_reference '.' feature_name ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
opt_blocks  :  /* empty */  |  blocks  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
rest_of_block_str  :  block  
\end_layout

\begin_layout LyX-Code
                   |  block  '!' rest_of_block_str  
\end_layout

\begin_layout LyX-Code
                   |  block  rest_of_block_str  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
block  :  opt_gap_block  |  gap_block |  object_block  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
opt_gap_block : '['  T_KEY_OPT_GAP  gap_retrieval  opt_blocks ']'  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
gap_retrieval  :  /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
               |  T_KEY_RETRIEVE  |  T_KEY_FOCUS;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
gap_block : '['  T_KEY_GAP  gap_retrieval  opt_blocks ']'  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_block  :  '['  object_type_name
\end_layout

\begin_layout LyX-Code
                      object_reference_declaration
\end_layout

\begin_layout LyX-Code
                      retrieval  last  features  
\end_layout

\begin_layout LyX-Code
                      opt_blocks  ']'  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
last  :  /* empty */ | T_KEY_LAST ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
power  :  T_KEY_POWER  restrictor  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
restrictor  :  /*  empty  */  |  '<'  limit  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
limit  :  T_INTEGER  ;  /* non-negative integer, may be 0.
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
%%
\end_layout

\begin_layout Subsection
The concatenation operators
\end_layout

\begin_layout Standard
There are two places in the grammar where an exclamation mark (`
\family typewriter
!
\family default
') is used.
 One is in 
\family typewriter
block_str
\family default
 between an 
\family typewriter
object_block_first
\family default
 and a 
\family typewriter
rest_of_block_str
\family default
.
 The other is in 
\family typewriter
rest_of_block_str
\family default
 between a 
\family typewriter
block
\family default
 and a 
\family typewriter
rest_of_block_str
\family default
.
 It will be noted that both of these constructs have counterparts with no
 exclamation mark in between.
 The exclamation mark is called a 
\begin_inset Quotes eld
\end_inset

concatenation operator
\begin_inset Quotes erd
\end_inset

, as is the 
\begin_inset Quotes eld
\end_inset

invisible
\begin_inset Quotes erd
\end_inset

 counterpart.
\end_layout

\begin_layout Standard
After parsing, and before passing the Abstract Syntax Tree to the MQL query
 interpreter, the following syntactic operations must be applied:
\end_layout

\begin_layout Itemize
Each exclamation mark concatenation operator must be erased.
\end_layout

\begin_layout Itemize
Each invisible concatenation operator must be replaced with the representation
 of the string 
\begin_inset Quotes eld
\end_inset


\family typewriter
[gap?\InsetSpace ~
noretrieve]
\family default

\begin_inset Quotes erd
\end_inset

, unless it stands before or after an 
\family typewriter
opt_gap_block
\family default
, in which case it must simply be erased.
\end_layout

\begin_layout Standard
Thus there are no exclamation mark concatenation operators in the Abstract
 Syntax Tree that gets passed to the MQL query interpreter.
\end_layout

\begin_layout Standard
The reason for having these concatenation operators is that we do not want
 the user to have to know about possible optional gaps in the text.
 This is very useful, for example in dealing with classical Greek, where
 any sentence-initial phrase may be split in the middle by a word from a
 certain set of well-known words.
 We do not want the user to explicitly mark that such gaps could optionally
 be there.
 It is better, when asking for results, to be shielded from one's ignorance
 than to retrieve incomplete results.
 Thus this amendment embodies the principle that 
\begin_inset Quotes eld
\end_inset

what you don't know won't hurt you
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Object references
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Standard
In this section, we expand on the object references.
\end_layout

\begin_layout Subsubsection
Naming
\end_layout

\begin_layout Standard
An object reference can be named anything at all, including existing object
 type names.
 This is possible because object reference names are set off from all other
 namespaces by their syntactic placement in the syntax tree.
 Therefore, you can name an object reference, e.g., the same as the object
 type which goes with it.
\end_layout

\begin_layout Standard
Object references are analogous to 
\begin_inset Quotes eld
\end_inset

tuple variables
\begin_inset Quotes erd
\end_inset

 in SQL.
\end_layout

\begin_layout Subsubsection
Declaration
\end_layout

\begin_layout Standard
An object reference must be declared before it can be used.
 It is declared right after the object type name of a block, as in 
\begin_inset Quotes eld
\end_inset


\family typewriter
[word as w 
\begin_inset Formula $\ldots$
\end_inset


\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Furthermore, an object reference must only be declared once in a topograph.
\end_layout

\begin_layout Subsubsection
Usage
\end_layout

\begin_layout Standard
An object reference is, as is seen in the grammar, used only with the dotted
 notation to select a given feature.
 For example, the feature 
\begin_inset Quotes eld
\end_inset

gender
\begin_inset Quotes erd
\end_inset

 on the object reference 
\begin_inset Quotes eld
\end_inset

w
\begin_inset Quotes erd
\end_inset

 is selected with the expression 
\begin_inset Quotes eld
\end_inset

w.gender
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The following criteria must be true for all usages of an object reference:
\end_layout

\begin_layout Enumerate
The object reference must have been declared previously (i.e., textually before
 the usage).
\end_layout

\begin_layout Enumerate
The feature selected must exist on the object being referenced (i.e., the
 object type must have this feature).
\end_layout

\begin_layout Enumerate
The two features to be compared must be type-compatible (see below).
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
I suggest the following as an implementation-strategy:
\end_layout

\begin_layout Standard
Associated with the AST must be a symbol table.
 In this symbol table, we can store all the information necessary for manipulati
ng the object references, not only at compile-time, but also at interpret-time.
\end_layout

\begin_layout Standard
Each object reference name must be paired with the following information:
\end_layout

\begin_layout Enumerate
Static information which can be determined at compile-time:
\end_layout

\begin_deeper
\begin_layout Enumerate
The object type_id of the object type of the object being referenced.
\end_layout

\begin_layout Enumerate
The object type name of the object type of the object being referenced.
\end_layout

\begin_layout Enumerate
The names of all the features that will be used in an object reference usage.
\end_layout

\end_deeper
\begin_layout Enumerate
Dynamic information which can only be determined at interpret-time:
\end_layout

\begin_deeper
\begin_layout Enumerate
The object id_d of the object being referenced.
 
\end_layout

\begin_layout Enumerate
The values for all the features that will be used in an object reference
 usage.
 This can be loaded from the database when setting the object id_d.
\end_layout

\end_deeper
\begin_layout Subsection
MQL needs to be compiled
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Standard
As noted in section 
\begin_inset LatexCommand \ref{architecture}

\end_inset

, I think it would be wise to transform an MQL query, written in MQL, into
 an AST (Abstract Syntax Tree).
 Various checks should be performed on this AST before passing it to an
 interpreter which actually builds the sheaf.
 For example, various well-formedness criteria should be checked for, and
 symbol-checking must occur for object references.
 In the following sections, we list some of the criteria that should be
 checked.
\end_layout

\begin_layout Subsubsection
Weeding: Non-negative limit
\end_layout

\begin_layout Standard
The 
\family typewriter
limit
\family default
 in a 
\family typewriter
power
\family default
 construct must be non-negative.
 It can be zero, but it must not be negative.
\end_layout

\begin_layout Subsubsection
Weeding: Usage of 
\begin_inset Quotes eld
\end_inset

first
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

first and last
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
It is the intention that the 
\begin_inset Quotes eld
\end_inset


\family typewriter
first
\family default

\begin_inset Quotes erd
\end_inset

 modifier of 
\family typewriter
object_block_first
\family default
 only be used for the first 
\family typewriter
object_block_first
\family default
 in a 
\family typewriter
blocks
\family default
.
 It is also the intention that teh 
\begin_inset Quotes eld
\end_inset


\family typewriter
last
\family default

\begin_inset Quotes erd
\end_inset

 modifier on an 
\family typewriter
object_block_first
\family default
 or 
\family typewriter
object_block
\family default
 only be used for the last 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
) in the 
\family typewriter
blocks
\family default
.
 Finally, it is the intention that if both modifier are used (
\begin_inset Quotes eld
\end_inset


\family typewriter
first and last
\family default

\begin_inset Quotes erd
\end_inset

), the 
\family typewriter
object_block_first
\family default
 must be both the first and the last block in the 
\family typewriter
blocks
\family default
.
\end_layout

\begin_layout Standard
The compiler should enforce this.
 Note that the grammar allows an 
\family typewriter
object_block_first
\family default
 after a 
\family typewriter
power
\family default
, and so this is not enforced by the grammar.
 
\end_layout

\begin_layout Subsubsection
Weeding: Comparand of ~ and !~ must be T_STRING
\end_layout

\begin_layout Standard
When comparing by means of a regular expression (T_KEY_TILDE and T_KEY_NOT_TILDE
), the comparand on the right-hand-side must be a string.
\end_layout

\begin_layout Subsubsection
Symbol-checking of object types
\end_layout

\begin_layout Standard
The type of object in an 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
) must be a valid object type, i.e., the object type must exist in the EMdF
 database, and it must not be all_m, pow_m, or any_m!
\end_layout

\begin_layout Subsubsection
Symbol-checking of feature_name 
\end_layout

\begin_layout Standard
The compiler should check that 
\family typewriter
feature_name
\family default
 (of 
\family typewriter
features
\family default
) is part of the type for the immediately enclosing object-type.
\end_layout

\begin_layout Subsubsection
Symbol-checking of declarations of object references
\end_layout

\begin_layout Standard
An object reference must be declared only once in a topograph.
\end_layout

\begin_layout Subsubsection
Symbol-checking of object reference in object reference usage
\end_layout

\begin_layout Standard
When being used, an object reference must have been declared before its
 usage.
\end_layout

\begin_layout Subsubsection
Symbol-checking of feature on object reference usage
\end_layout

\begin_layout Standard
The feature selected by an object reference usage must exist for the given
 object type.
 At the same time, store the information in the symbol table that this feature
 will be used for this object reference.
\end_layout

\begin_layout Subsubsection
Symbol-checking of enumeration constants in feature comparisons
\end_layout

\begin_layout Standard
If an enumeration constant is involved in a 
\family typewriter
feature_comparison
\family default
, it must exist.
\end_layout

\begin_layout Subsubsection
Symbol-checking of feature usage
\end_layout

\begin_layout Standard
The compiler should build, for each 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
), a table of all features that are used in a 
\family typewriter
feature_comparison
\family default
 belonging directly to the object block.
 This can then be used to get only the features that are necessary for an
 object, before comparing any features with actual values from the object.
\end_layout

\begin_layout Subsubsection
Type-checking of feature_comparison (compatibility)
\end_layout

\begin_layout Standard
The compiler should check that the two types of the feature and the value
 to be compared are type-compatible.
 Two types are type-compatible if and only if 
\end_layout

\begin_layout Enumerate
They are exactly the same, or
\end_layout

\begin_layout Enumerate
One type is INTEGER while the other id ID_D.
\end_layout

\begin_layout Standard
A consequence of this requirement is that you can't compare an enumeration
 type with an integer.
 Another consequence is that all enumeration constants must be symbolically
 unique, since it must be possible to infer the type of an enumeration constant
 from the constant itself.
\end_layout

\begin_layout Subsection
Focus objects
\end_layout

\begin_layout Standard
As already explained, MQL allows objects to be specified as 
\begin_inset Quotes eld
\end_inset

focus objects.
\begin_inset Quotes erd
\end_inset

 The MQL grammar shows that the keyword 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

 shares its syntactic place with 
\begin_inset Quotes eld
\end_inset

retrieve
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

noretrieve.
\begin_inset Quotes erd
\end_inset

 Thus these three keywords encode the answers to two questions: 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Should the object be retrieved or not?
\begin_inset Quotes erd
\end_inset

 and 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Should this object be a focus-object or not?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The relationships among them are as follows:
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Keyword
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
retrieve?
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
focus?
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
yes
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
retrieve
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
no
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
noretrieve
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
no
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

The default chosen in absence of any of these words varies with the kind
 of block.
\end_layout

\begin_layout Subsection
Datatypes
\end_layout

\begin_layout Standard
We need the following datatypes:
\end_layout

\begin_layout Itemize

\family typewriter
INTEGER
\family default
 - ordinary integers.
\end_layout

\begin_layout Itemize

\family typewriter
index
\family default
 - an integer suitable for indexing into inst(T,U)
\end_layout

\begin_layout Itemize

\family typewriter
monad
\family default
 - a monad_m
\end_layout

\begin_layout Itemize

\family typewriter
boolean
\family default
 - a Boolean
\end_layout

\begin_layout Itemize

\family typewriter
sheaf
\family default
, 
\family typewriter
list_of_straws
\family default
, 
\family typewriter
straw
\family default
, 
\family typewriter
matched_object
\family default
 - as in the grammar for the sheaf.
\end_layout

\begin_layout Itemize

\family typewriter
mo_nr
\family default
 - See the next section
\end_layout

\begin_layout Itemize

\family typewriter
list_of_mo_nr
\family default
 - a list of 
\begin_inset Quotes eld
\end_inset


\family typewriter
mo_nr
\family default

\begin_inset Quotes erd
\end_inset

s.
\end_layout

\begin_layout Itemize

\family typewriter
enum
\family default
 
\family typewriter
enum_first_last
\family default
 
\family typewriter
{
\family default
 
\family typewriter
first
\family default
, 
\family typewriter
last,first_and_last,no_first_last}
\family default
 - an enumeration.
\end_layout

\begin_layout Itemize

\family typewriter
set_of_monad_ms
\family default
 - a set of monad_m's : the same as in an object.
 Used for universe, substrate, and pow_m object id_m's.
\end_layout

\begin_layout Itemize

\family typewriter
instances
\family default
 - an array intended to hold inst(T,U).
\end_layout

\begin_layout Itemize

\family typewriter
object
\family default
 - an 
\family typewriter
object_dm
\family default
.
\end_layout

\begin_layout Subsection
mo_nr
\begin_inset LatexCommand \label{sub:mo_nr}

\end_inset


\end_layout

\begin_layout Standard
A very important construct is the 
\family typewriter
mo_nr
\family default
 construct.
 It is used again and again throughout the retrieval functions.
 Therefore, it is best to explain it in full before delving into the retrieval
 functions.
\end_layout

\begin_layout Standard
An 
\family typewriter
mo_nr
\family default
 is a pair, 
\family typewriter
(matched_object,boolean)
\family default
.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
boolean
\family default
 is intended to answer the question, 
\begin_inset Quotes eld
\end_inset

do we 
\emph on
not
\emph default
 want to retrieve this 
\family typewriter
matched_object
\family default
?
\begin_inset Quotes erd
\end_inset

.
 It is an importaint point that this boolean is true when we do 
\emph on
not
\emph default
 want to retrieve the 
\family typewriter
matched_object
\family default
, while it is false when we 
\emph on
do
\emph default
 want to retrieve it.
\end_layout

\begin_layout Standard
The matched_object can be one of four things.
 The following table summarizes these and their relationship to noretrieve.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="left" valignment="top" leftline="true" width="0pt">
<column alignment="center" valignment="top" leftline="true" width="0pt">
<column alignment="left" valignment="top" leftline="true" rightline="true" width="0pt">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
matched_object
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
noretrieve
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Where from
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
NIL_mo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
always true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A call to 
\family typewriter
R_object_block
\family default
 failed
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
EMPTY_mo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
always true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
An 
\family typewriter
opt_gap_block
\family default
 matched 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
an empty stretch (no gap)
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
[ id_d focus sheaf ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
true or false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
A call to 
\family typewriter
R_object_block
\family default
 succeeded
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
[ id_m focus ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
true or false
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
An 
\family typewriter
opt_gap_block
\family default
 or a 
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
gap_block
\family default
 matched a gap
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset

In the first case, there was no object to match the 
\family typewriter
object_block 
\family default
.
\end_layout

\begin_layout Standard
In the second case, there was no gap to match, but this is, of course, not
 a fail, since the gap was optional.
\end_layout

\begin_layout Standard
In both the first and the second cases, the 
\begin_inset Quotes eld
\end_inset

noretrieve
\begin_inset Quotes erd
\end_inset

 boolean is always true.
 Thus these 
\family typewriter
matched_object
\family default
 incarnations never get into any straw.
\end_layout

\begin_layout Standard
In the third and fourth cases, the value of noretrieve depends on the presence
 or absence of one of the keywords 
\begin_inset Quotes eld
\end_inset

focus
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

retrieve
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

noretrieve
\begin_inset Quotes erd
\end_inset

 in the block in question.
\end_layout

\begin_layout Subsection
First and last
\begin_inset LatexCommand \label{firstlast_explanation}

\end_inset


\end_layout

\begin_layout Standard
The non-terminal 
\family typewriter
firstlast
\family default
 in the MQL grammar can be one of four things:
\end_layout

\begin_layout Enumerate
It can be empty, or
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

first
\begin_inset Quotes erd
\end_inset

, or
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

, or
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

first and last
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The non-terminal is a restrictor which restricts an object_block_first.
 A similar nonterminal is present in an object_block, but here it can only
 be either empty or 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The idea is that, if the keyword 
\begin_inset Quotes eld
\end_inset

first
\begin_inset Quotes erd
\end_inset

 is present, then an object's first monad must be the same as the first
 monad of the accompanying universe.
 Similarly, if the keyword 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

 is present, then the object's last monad must be the same as the last monad
 of the accompanying universe.
 If both keywords are present, then both constraints must hold.
 Finally, if neither are present, then there is no restriction.
\end_layout

\begin_layout Subsection
Standard arguments to the functions
\end_layout

\begin_layout Standard
The following are standard arguments to the retrieval functions.
 Not all of them need be in the formal parameters of any given retrieval
 function.
\end_layout

\begin_layout Itemize
U, Su - Universe, Substrate.
 
\end_layout

\begin_layout Itemize
Sm - Start Monad -- the monad at which we are to start our matching.
\end_layout

\begin_layout Itemize
i - index into inst(T,U) which we are to use.
\end_layout

\begin_layout Itemize
inst - an inst(T,U) array
\end_layout

\begin_layout Itemize
limit - limit of 
\family typewriter
..

\family default
 (
\family typewriter
power
\family default
), counted in monad_ms.
 If 0, it means 
\begin_inset Quotes eld
\end_inset

no limit
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The semantics of the arguments is call-by-value, unless prefixed by the
 keyword 
\begin_inset Quotes eld
\end_inset


\family typewriter
var
\family default

\begin_inset Quotes erd
\end_inset

 in the list of formal parameters, in which case they are call-by-name.
 However, nothing is changed which is not call-by-name.
 Therefore, call-by-value parameters might be implemented in C++ as 
\family typewriter
const
\family default
-references.
\end_layout

\begin_layout Chapter
Retrieval functions
\end_layout

\begin_layout Section
Overview of MQL retrieval functions
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
This section gives a bird's-eye view of the retrieval functions specifying
 the semantics of MQL.
 We list the salient functions in a bottom-up fashion, starting from the
 blocks and working our way up through the grammar, until we reach the start-sym
bol, 
\family typewriter
topograph
\family default
.
 Less salient, more peripheral functions are not treated.
\end_layout

\begin_layout Subsection
object_block
\end_layout

\begin_layout Standard
The 
\family typewriter
object_block
\family default
 is one of two blocks that retrieves object_dms.
 The other is 
\family typewriter
object_block_first
\family default
.
\end_layout

\begin_layout Standard
The function 
\family typewriter
R_object_block
\family default
 returns a list of mo_nr's.
 A successful match of an 
\family typewriter
object_block
\family default
 results in a list of mo_nrs that contains objects starting at a specific
 monad Sm.
 This monad is passed to the retrieval function from higher up in the hierarchy.
 A failed match results in a list that has one member, namely the mo_nr
 (NIL_mo,true).
\end_layout

\begin_layout Standard
A successful match contains only objects that satisfy a number of criteria.
 In particular, the rules about last must be obeyed, the object must be
 part_of Su, and the features must match.
 If there is an inner 
\family typewriter
blocks
\family default
, it must not constitute a failed match.
\end_layout

\begin_layout Subsection
opt_gap_block
\end_layout

\begin_layout Standard
The 
\family typewriter
opt_gap_block
\family default
 is used to match gaps that may or may not be there.
 The function 
\family typewriter
R_opt_gap_block
\family default
 returns a list of mo_nr's, but there is always only exactly one mo_nr in
 the list.
 If there was a gap in the database at the start monad Sm, then the mo_nr
 contains a 
\family typewriter
matched_object
\family default
 with the id_m denoting the gap.
 If, on the other hand, there was no gap in the database at the start monad
 Sm, then the mo_nr is (EMPTY_mo, true).
 This function fails if there were an 
\family typewriter
opt_blocks
\family default
 and this did not match.
 Otherwise, it cannot fail -- if there is no 
\family typewriter
opt_blocks
\family default
, it always returns something that constitutes a successful match (an (EMPTY_mo,
 true)).
\end_layout

\begin_layout Subsection
gap_block
\end_layout

\begin_layout Standard
The 
\family typewriter
gap_block
\family default
 is used to match gaps that are actually present in the database.
 The 
\family typewriter
R_gap_block
\family default
 function fails if there is no gap in the database at the start monad Sm.
 In this case, the result is a list of mo_nr's containing only the mo_nr
 (NIL_mo, true).
 If, on the other hand, a gap was present at start monad Sm, then the id_m
 of this gap is returned in the sole mo_nr in the list.
\end_layout

\begin_layout Subsection
block
\end_layout

\begin_layout Standard
The block syntactic construct can be one of three things: Either an opt_gap_bloc
k, a gap_block, or an object_block.
 The R_block function returns a list of mo_nr's because the retrieval functions
 for each of these three syntactic constructs returns a list of mo_nr's.
\end_layout

\begin_layout Subsection
object_block_first
\end_layout

\begin_layout Standard
The 
\family typewriter
object_block_first
\family default
 stands at the beginning of every 
\family typewriter
block_str
\family default
, and nowhere else.
 The function 
\family typewriter
R_object_block_first
\family default
 is passed both an inst(T,U) array and a starting index 
\family typewriter
i
\family default
 into this array.
 The inst(T,U) array has been calculated higher up in the hierarchy, based
 on the object type of the 
\family typewriter
object_block_first
\family default
 and on the accompanying universe.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_object_block_first
\family default
 function returns a single mo_nr.
 It looks through the inst(T,U) array, starting at 
\family typewriter
i
\family default
, trying to find a match.
 If it doesn't find a match at i, it increments 
\family typewriter
i
\family default
 and tries the next object.
 If an object is found which satisfies a number of criteria, then an mo_nr
 is returned containing this object.
 If the array is exhausted, then (NIL_mo, true) is returned.
\end_layout

\begin_layout Standard
Thus there are only two possible results: Either the functions succeeds
 and returns an mo_nr containing an object_dm, or the function fails by
 exhausting the inst(T,U) array, in which case it returns (NIL_mo,true).
\end_layout

\begin_layout Standard
The 
\family typewriter
i
\family default
-parameter is a call-by-name parameter.
 Therefore, incrementing it in this function also affects the value used
 higher up in the hierarchy.
\end_layout

\begin_layout Subsection
rest_of_block_str
\end_layout

\begin_layout Standard
The 
\family typewriter
rest_of_block_str
\family default
 syntactic construct stands after the initial 
\family typewriter
object_block_first
\family default
 in a 
\family typewriter
block_str
\family default
.
 It consists of a string of 
\family typewriter
block
\family default
s.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_rest_of_block_str
\family default
 function returns a list of straws.
 The reason is that we must start at a given start monad Sm.
 At this monad we must find one or more object_dms or pow_ms (gaps) which
 satisfy a number of criteria, one of which is that the rest of the string
 of 
\family typewriter
block
\family default
s must also match.
 Since the initial block may match more than one object_dm (since more than
 one object may start at Sm), we must return at least one straw for each
 of these.
 If, in turn, the rest of the 
\family typewriter
block
\family default
s in the string also result in a number of straws, then these must be multiplied
 by the number of matching objects from the initial 
\family typewriter
block
\family default
.
 Therefore, the result is a list of straws, one straw for each successful
 match of the whole string of 
\family typewriter
block
\family default
s.
\end_layout

\begin_layout Standard
The function also returns a boolean indicating whether the match was a success
 or not.
 The reason is that the string of blocks may result in an empty list of
 mo_nr's, e.g., if an 
\family typewriter
opt_gap_block
\family default
 matched an empty stretch of the database coupled with another 
\family typewriter
block
\family default
 which we were not to retrieve.
 This would be a successful match, yet the list of straws would be empty.
 We must propagate this success-information up through the hierarchy, and
 we cannot use the empty list of straws as an indicator.
 Therefore, we use a boolean.
\end_layout

\begin_layout Subsection
block_str
\end_layout

\begin_layout Standard
The 
\family typewriter
block_str
\family default
 syntactic construct consists of an initial 
\family typewriter
object_block_first
\family default
 and an optional trailing string of 
\family typewriter
block
\family default
s.
 It is part of the 
\family typewriter
block_string
\family default
 syntactic construct.
 The 
\family typewriter
block_str
\family default
 construct either stands alone or stands before and after a 
\family typewriter
power
\family default
 construct.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_block_str
\family default
 function returns a list of straws.
 It is passed an index into an inst(T,U) array.
 A successful match returns the list of straws resulting from one member
 of the inst(T,U) array.
 It does not return until it has either found such a match or has exhausted
 the array.
\end_layout

\begin_layout Standard
The function also returns a boolean showing whether the match was successful
 or not.
 Again, this is because an empty list of mo_nr's does not entail a failed
 match.
 Thus we use a boolean to show whether we succeeded or failed.
\end_layout

\begin_layout Subsection
block_string
\end_layout

\begin_layout Standard
The 
\family typewriter
block_string
\family default
 syntactic construct consists of a string of 
\family typewriter
block_str
\family default
s, the 
\family typewriter
block_str
\family default
s being separated by the 
\family typewriter
power
\family default
 construct.
 A 
\family typewriter
block_string
\family default
 makes up a 
\family typewriter
blocks
\family default
 construct.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_block_string
\family default
 function returns a list of straws.
 The function is passed an index into an inst(T,U) array.
 The list of straws contains the straws stemming from one index into the
 array.
 These straws may be many, for two reasons: First, because the 
\family typewriter
block_str
\family default
 before the 
\family typewriter
power
\family default
 construct may return more than one straw.
 And second, because the 
\family typewriter
block_str
\family default
 after the 
\family typewriter
power
\family default
 construct may return more than one straw, and the straws from the first
 
\family typewriter
block_str
\family default
 must be multiplied into the straws from the second 
\family typewriter
block_str
\family default
.
\end_layout

\begin_layout Standard
The function does not return until it has either found a match or has exhausted
 all possibilities in the inst(T,U) array.
\end_layout

\begin_layout Subsection
blocks
\end_layout

\begin_layout Standard
The 
\family typewriter
blocks
\family default
 syntactic construct is made up solely of a 
\family typewriter
block_string
\family default
.
 The 
\family typewriter
blocks
\family default
 construct, in turn, is embedded in the 
\family typewriter
topograph
\family default
 construct.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_blocks
\family default
 function returns a sheaf.
 It is passed an inst(T,U) array.
 It returns all the possible matches in this array.
\end_layout

\begin_layout Standard
The result can be a failed match if none of the members of the inst(T,U)
 array resulted in a successful match.
\end_layout

\begin_layout Subsection
topograph
\end_layout

\begin_layout Standard
The topograph syntactic construct is made up solely of a blocks construct.
 The topograph is the start-symbol in the grammar for the MQL query-subset.
\end_layout

\begin_layout Standard
The 
\family typewriter
R_topograph
\family default
 function returns whatever the call to 
\family typewriter
R_blocks
\family default
 returns.
\end_layout

\begin_layout Section
Utility functions
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
In this section, we list all of the utility-functions needed by the MQL-interpre
ter.
 The utility functions are distinct from the retrieval functions in that
 they do not operate on syntactic constructs from MQL.
\end_layout

\begin_layout Standard
The return types of the retrieval functions are given after an arrow, 
\begin_inset Quotes eld
\end_inset


\family typewriter
-->
\family default

\begin_inset Quotes erd
\end_inset

.
 Unlike Pascal functions, these functions may return more than one value
 at a time.
\end_layout

\begin_layout Subsection
Restrict
\end_layout

\begin_layout Standard
The function 
\family typewriter
Restrict
\family default
 is used in 
\family typewriter
R_block_string
\family default
.
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout Standard
One implementation could be like this:
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * Restrict
\end_layout

\begin_layout LyX-Code
 * returns : set_of_monad_ms 
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function Restrict(SOM : set_of_monad_ms, m : monad) --> set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    return SOM 
\backslash
 (SOM.first()..m-1);  /* 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 = set difference */
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The result of the 
\family typewriter
Restrict
\family default
 function is 
\family typewriter
SOM
\family default
 minus all the monads from 
\family typewriter
SOM
\family default
.first() to 
\family typewriter
m
\family default
-1.
 Thus the first monad of the result will be 
\family typewriter
m
\family default
, if {
\family typewriter
m
\family default
} is part_of 
\family typewriter
SOM
\family default
.
 The function is used to restrict both universes and substrates.
\end_layout

\begin_layout Subsection
Join
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{join}

\end_inset

The function 
\family typewriter
Join
\family default
 is used in 
\family typewriter
R_block_string
\family default
, 
\family typewriter
R_block_str
\family default
, and 
\family typewriter
R_rest_of_block_str
\family default
.
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
function Join(s : straw, LS : list_of_straws) --> list_of_straws;
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
  Result : list_of_straws;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    Result := < >;
\end_layout

\begin_layout LyX-Code
    if (LS is empty)
\end_layout

\begin_layout LyX-Code
       Result := < s >;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
       for (each straw s' in LS) do
\end_layout

\begin_layout LyX-Code
       begin
\end_layout

\begin_layout LyX-Code
           Result := Result + < s + s' >;
\end_layout

\begin_layout LyX-Code
       end;
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
    return Result;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
What 
\family typewriter
Join
\family default
 does is to 
\begin_inset Quotes eld
\end_inset

multiply
\begin_inset Quotes erd
\end_inset

 
\family typewriter
s
\family default
 into all the straws in 
\family typewriter
LS
\family default
.
 For each straw 
\family typewriter
s'
\family default
 in 
\family typewriter
LS
\family default
, 
\family typewriter
s
\family default
 is prepended to 
\family typewriter
s'
\family default
, and the resulting straw is appended to the list of straws that will be
 the result.
 Thus the result is the same as 
\family typewriter
LS
\family default
, only with 
\family typewriter
s
\family default
 prepended to each straw in 
\family typewriter
LS
\family default
.
\end_layout

\begin_layout Standard
If LS is empty, a list of straws containing only 
\family typewriter
s
\family default
 is returned.
\end_layout

\begin_layout Standard
Note that this involves making copies of 
\family typewriter
s
\family default
.
 Note also that the result can equivalently be obtained by prepending 
\family typewriter
s
\family default
 to each straw in 
\family typewriter
LS
\family default
, without using the intermediate variable 
\family typewriter
Result
\family default
.
\end_layout

\begin_layout Subsection
Hat
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{hat}

\end_inset

The function 
\family typewriter
\series bold
Hat
\family default
\series default
 is used in 
\family typewriter
object_block_first
\family default
 and 
\family typewriter
object_block
\family default
.
 
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout Standard
The syntax of Hat is 
\begin_inset Quotes eld
\end_inset

O^U
\begin_inset Quotes erd
\end_inset

, where O and U are two sets of monads.
 O is an object and U is a universe.
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
function Hat(O : object, U : set_of_monad_ms) --> 
\end_layout

\begin_layout LyX-Code
         set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    return(O.first() ..
 O.last());
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The O^U function is defined on p.
 156 in Doedens.
 There, it is defined as:
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

O^U is the smallest pow_m object without gaps relative to U that O is part_of
 and which is itself part_of U.
 In other words O^U is the pow_m object which has the monads of O plus the
 monads of the gaps of O relative to U.
\begin_inset Quotes erd
\end_inset

 (p.
 156)
\end_layout

\begin_layout Standard
Here, I have simplified the definition to be simply the range O.first() ..
 O.last().
 This is OK, since U is never empty, and O is always part_of U! This is
 because we only call this function if O part_of Su, which is always part_of
 U.
\end_layout

\begin_layout Section
The Retrieval Functions R
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
This section details the syntax and semantics of a set of retrieval runctions
 for MQL.
 Each retrieval function either operates on some syntactic construct in
 MQL or are helper functions.
\end_layout

\begin_layout Standard
The suggested way of reading this section is as follows: Once from front
 to back and once from back to front.
 That way, the reader will first get the broad picture in a top-down manner,
 and then the details in a bottom-up manner.
 The sections are arranged approximately in a depth-first order according
 to the order in which non-terminals are introduced in the MQL grammar,
 starting from the start symbol.
\end_layout

\begin_layout Subsection
topograph
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
topograph  :  blocks  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout Standard
The retrieval function R for the 
\family typewriter
topograph
\family default
 is:
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_topograph
\end_layout

\begin_layout LyX-Code
 * returns : sheaf 
\end_layout

\begin_layout LyX-Code
 * ON FAIL: "// " (see R_blocks)
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_topograph(U,Su,topograph) --> sheaf;
\end_layout

\begin_layout LyX-Code
var 
\end_layout

\begin_layout LyX-Code
    inst : instances;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    inst := R_inst_blocks(U, blocks);
\end_layout

\begin_layout LyX-Code
    return R_blocks(U, Su, inst, blocks);
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
R_topograph
\family default
 retrival function takes a universe 
\family typewriter
U
\family default
, a substrate 
\family typewriter
Su
\family default
, and a 
\family typewriter
topograph
\family default
.
 It returns a 
\family typewriter
sheaf
\family default
.
\end_layout

\begin_layout Standard
An instances array is calculated for the universe U and the first 
\family typewriter
object_block_first
\family default
 of 
\family typewriter
blocks
\family default
.
 This will be passed down all the way to the call of the 
\family typewriter
R_object_block_first
\family default
 function.
\end_layout

\begin_layout Standard
Other than that, the function simply calls 
\family typewriter
R_blocks
\family default
.
\end_layout

\begin_layout Standard
Note that we do 
\emph on
not
\emph default
, as QL does, specify that 
\family typewriter
U
\family default
 and 
\family typewriter
Su
\family default
 must be all_m-1 and all_m-1 respectively.
 This is because this decision should be made higher up in the architectural
 hierarchy.
 For example, we might wish to search the results previously made, or we
 might wish to restrict the search to certain books (in a Biblical setting),
 without specifying it in the MQL query itself.
\end_layout

\begin_layout Subsection
R_inst_block_string
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
blocks : block_string  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
block_string  : block_str  |  block_str  power  block_string ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
block_str : object_block_first  
\end_layout

\begin_layout LyX-Code
          |  object_block_first  rest_of_block_str  ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
object_block_first : '['  object_type_name  
\end_layout

\begin_layout LyX-Code
                     object_reference_declaration
\end_layout

\begin_layout LyX-Code
                     retrieval  firstlast  features  
\end_layout

\begin_layout LyX-Code
                     opt_blocks  ']'  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_inst_block_string
\end_layout

\begin_layout LyX-Code
 * returns : An inst(T,U) array.
\end_layout

\begin_layout LyX-Code
 * ON FAIL: Cannot fail (but the array may be empty).
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_inst_block_string(U, block_string) --> instances;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* Calculates the inst(T,U) array for the universe U
\end_layout

\begin_layout LyX-Code
       and the object type T which is the object type of the 
\end_layout

\begin_layout LyX-Code
       first object_block_first in the block_string.
\end_layout

\begin_layout LyX-Code
       Returns this array.
\end_layout

\begin_layout LyX-Code
    */
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
Calculates and returns an array inst(T,U).
 The universe U is as specified in the formal parameters.
 The object type T is taken from the first 
\family typewriter
object_block_first
\family default
 in the 
\family typewriter
block_string
\family default
 argument.
 The reason for this is that the inst array is only ever used with this
 particular 
\family typewriter
object_block_first
\family default
.
\end_layout

\begin_layout Subsection
R_inst_blocks
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
blocks : block_string  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_inst_blocks
\end_layout

\begin_layout LyX-Code
 * returns : An inst(T,U) array.
\end_layout

\begin_layout LyX-Code
 * ON FAIL: Cannot fail (but the array may be empty).
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_inst_blocks(U,blocks) --> instances;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    return R_inst_block_string(U, block_string);
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
Just calls 
\family typewriter
R_inst_block_string
\family default
 with the 
\family typewriter
block_string
\family default
 in the 
\family typewriter
block
\family default
.
\end_layout

\begin_layout Subsection
blocks
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
blocks  :  block_string  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_blocks
\end_layout

\begin_layout LyX-Code
 * returns : sheaf 
\end_layout

\begin_layout LyX-Code
 * ON FAIL: "// "
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_blocks(U,Su,inst,blocks) --> sheaf;
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    Sheaf : sheaf;
\end_layout

\begin_layout LyX-Code
    i : index;
\end_layout

\begin_layout LyX-Code
    Result : list_of_straws;
\end_layout

\begin_layout LyX-Code
    LStraws1 : list_of_straws;
\end_layout

\begin_layout LyX-Code
    block_string_success : boolean;
\end_layout

\begin_layout LyX-Code
    self_success : boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* Initialize */
\end_layout

\begin_layout LyX-Code
    i := 0;
\end_layout

\begin_layout LyX-Code
    Result := < >;
\end_layout

\begin_layout LyX-Code
    self_success := false;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
    /* Treat the block_string.
 */
\end_layout

\begin_layout LyX-Code
    repeat
\end_layout

\begin_layout LyX-Code
        /* Get the block_string for one i */
\end_layout

\begin_layout LyX-Code
        (LStraws1, block_string_success) := 
\end_layout

\begin_layout LyX-Code
           R_block_string(U,Su,i,inst,0,block_string); 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* If it was a success, we are a success,
\end_layout

\begin_layout LyX-Code
           and we can add the block_string result
\end_layout

\begin_layout LyX-Code
           to our result.
 */
\end_layout

\begin_layout LyX-Code
        if (block_string_success) then
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            self_success := true;
\end_layout

\begin_layout LyX-Code
            Result := Result + LStraws1;
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
        if (i is not already at the end of inst)
\end_layout

\begin_layout LyX-Code
            i := i + 1;
\end_layout

\begin_layout LyX-Code
    until (not block_string_success or i is at the end of inst); 
\end_layout

\begin_layout LyX-Code
    /* Return when match fails.
 */
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
    /* Calculate and return sheaf.
 */
\end_layout

\begin_layout LyX-Code
    if (self_success) then
\end_layout

\begin_layout LyX-Code
        Sheaf := "//" Result;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        Sheaf := "//  ";
\end_layout

\begin_layout LyX-Code
    return Sheaf;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The idea of 
\family typewriter
R_blocks
\family default
 is that it returns a 
\family typewriter
sheaf
\family default
 with all the possible matches of the 
\family typewriter
block_string
\family default
.
\end_layout

\begin_layout Standard
The function is very simple.
 The reason why we enclose the call to 
\family typewriter
R_block_string
\family default
 in a 
\family typewriter
repeat
\family default
 \SpecialChar \ldots{}
 
\family typewriter
until
\family default
 statement is that we wish to retrieve all of the 
\family typewriter
block_string
\family default
 matches we can get.
 Thus we increment 
\family typewriter
i
\family default
 each time.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
i
\family default
 variable is an index into an inst(T,U) array, and it is used as such in
 
\family typewriter
R_object_block_first
\family default
.
 The 
\family typewriter
i
\family default
 variable is a call-by-name variable all the way down through the call-path
 down to 
\family typewriter
R_object_block_first
\family default
, and can be modified by all of the functions along the path.
\end_layout

\begin_layout Subsection
block_string
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
block_string  :  block_str  |
\end_layout

\begin_layout LyX-Code
                 block_str1  power  block_string1  ;
\end_layout

\begin_layout Standard
Note: The 
\family typewriter
1
\family default
's on the 
\family typewriter
block_str
\family default
 and 
\family typewriter
block_string
\family default
 in the rule are just there for identification purposes: They are just 
\begin_inset Quotes eld
\end_inset


\family typewriter
block_str
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
block_string
\family default

\begin_inset Quotes erd
\end_inset

 respectively.
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_block_string
\end_layout

\begin_layout LyX-Code
 * Returns : (list_of_straws, boolean)
\end_layout

\begin_layout LyX-Code
 *           The boolean indicates success (true) or failure (false)
\end_layout

\begin_layout LyX-Code
 * ON FAIL: (< >, false)
\end_layout

\begin_layout LyX-Code
 *          Only fails if all the i's within the Universe 
\end_layout

\begin_layout LyX-Code
 *          have been tried unsuccessfully.
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: (list_of_straws, true)
\end_layout

\begin_layout LyX-Code
 *              The list of straws is a match stemming from
\end_layout

\begin_layout LyX-Code
 *              one index into the inst array.
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_block_string(U,Su,var i,inst,limit,block_string) 
\end_layout

\begin_layout LyX-Code
         --> (list_of_straws, boolean);
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    Straw1 : straw;
\end_layout

\begin_layout LyX-Code
    U',Su' : set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
    i' : index;
\end_layout

\begin_layout LyX-Code
    inst' : instances; 
\end_layout

\begin_layout LyX-Code
    limit' : INTEGER;
\end_layout

\begin_layout LyX-Code
    LStraws1, LStraws2, Result : list_of_straws;
\end_layout

\begin_layout LyX-Code
    block_str_success, block_string_success : boolean;
\end_layout

\begin_layout LyX-Code
    self_success : boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
    if (block_string = block_str) then
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        return R_block_str(U,Su,i,inst,limit,block_str);
\end_layout

\begin_layout LyX-Code
    end
\end_layout

\begin_layout LyX-Code
    else /* block_str1  power  block_string1 */
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        while(true) do
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            /* Get result of block_str1 */
\end_layout

\begin_layout LyX-Code
            (LStraws1, block_str_success) 
\end_layout

\begin_layout LyX-Code
                 := R_block_str(U,Su,i,inst,limit,block_str1);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
            /* If the block_str wasn't there, we needn't look 
\end_layout

\begin_layout LyX-Code
               any further.
 */
\end_layout

\begin_layout LyX-Code
            if (not block_str_success) then
\end_layout

\begin_layout LyX-Code
                return (< >, false)
\end_layout

\begin_layout LyX-Code
            else
\end_layout

\begin_layout LyX-Code
            begin
\end_layout

\begin_layout LyX-Code
                Result := < >;
\end_layout

\begin_layout LyX-Code
                self_success := false;
\end_layout

\begin_layout LyX-Code
                if (LStraws1 is empty) then
\end_layout

\begin_layout LyX-Code
                begin
\end_layout

\begin_layout LyX-Code
                    /* Calculate new universe, substrate, etc.
 */
\end_layout

\begin_layout LyX-Code
                    U' := U;
\end_layout

\begin_layout LyX-Code
                    Su' := Su;
\end_layout

\begin_layout LyX-Code
                    i' := 0;
\end_layout

\begin_layout LyX-Code
                    inst' := R_inst_block_string(U', block_string1);
\end_layout

\begin_layout LyX-Code
                    limit' := R_power(power);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                    /* --- This repeat...until statement embodies 
\end_layout

\begin_layout LyX-Code
                       the idea that the power plus block_string1 
\end_layout

\begin_layout LyX-Code
                       matches _all_ those matching block_string1 
\end_layout

\begin_layout LyX-Code
                       inside the universe, not just the first 
\end_layout

\begin_layout LyX-Code
                       one.
 --- */
\end_layout

\begin_layout LyX-Code
                    repeat
\end_layout

\begin_layout LyX-Code
                        /* Get result of block_string1 */
\end_layout

\begin_layout LyX-Code
                        (LStraws2, block_string_success) := 
\end_layout

\begin_layout LyX-Code
                           R_block_string(U',Su',i',inst',
\end_layout

\begin_layout LyX-Code
                             limit',block_string1);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                        if (block_string_success) then
\end_layout

\begin_layout LyX-Code
                        begin
\end_layout

\begin_layout LyX-Code
                            self_success := true;
\end_layout

\begin_layout LyX-Code
                            Result := Result + LStraws2;
\end_layout

\begin_layout LyX-Code
                        end;
\end_layout

\begin_layout LyX-Code
                        if (i' is not already at the end of inst')
\end_layout

\begin_layout LyX-Code
                             i' := i' + 1;
\end_layout

\begin_layout LyX-Code
                    until (not block_string_success);
\end_layout

\begin_layout LyX-Code
                end
\end_layout

\begin_layout LyX-Code
                else for (each straw Straw1 in LStraws1) do
\end_layout

\begin_layout LyX-Code
                begin
\end_layout

\begin_layout LyX-Code
                    /* Calculate new universe, substrate, etc.
 */
\end_layout

\begin_layout LyX-Code
                    U' := Restrict(U,Straw1.last()+1);
\end_layout

\begin_layout LyX-Code
                    Su' := Restrict(Su,Straw1.last()+1);
\end_layout

\begin_layout LyX-Code
                    if (U' is not empty and Su' is not empty)
\end_layout

\begin_layout LyX-Code
                    begin
\end_layout

\begin_layout LyX-Code
                        i' := 0;
\end_layout

\begin_layout LyX-Code
                        inst' := R_inst_block_string(U', block_string1);
\end_layout

\begin_layout LyX-Code
                        limit' := R_power(power);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                        /* --- This repeat...until statement embodies 
\end_layout

\begin_layout LyX-Code
                           the idea that the power plus block_string1 
\end_layout

\begin_layout LyX-Code
                           matches _all_ those matching block_string1 
\end_layout

\begin_layout LyX-Code
                           inside the universe, not just the first 
\end_layout

\begin_layout LyX-Code
                           one.
 --- */
\end_layout

\begin_layout LyX-Code
                        repeat
\end_layout

\begin_layout LyX-Code
                            /* Get result of block_string1 */
\end_layout

\begin_layout LyX-Code
                            (LStraws2, block_string_success) := 
\end_layout

\begin_layout LyX-Code
                               R_block_string(U',Su',i',inst',
\end_layout

\begin_layout LyX-Code
                                 limit',block_string1);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                            /* If this was a success, we must multiply
\end_layout

\begin_layout LyX-Code
                               Straw1 into LStraws2.
 */
\end_layout

\begin_layout LyX-Code
                            if (block_string_success) then
\end_layout

\begin_layout LyX-Code
                            begin
\end_layout

\begin_layout LyX-Code
                                self_success := true;
\end_layout

\begin_layout LyX-Code
                                Result := Result + 
\end_layout

\begin_layout LyX-Code
                                          Join(Straw1, LStraws2);
\end_layout

\begin_layout LyX-Code
                            end;
\end_layout

\begin_layout LyX-Code
                            if (i' is not already at the end of inst')
\end_layout

\begin_layout LyX-Code
                                i' := i' + 1;
\end_layout

\begin_layout LyX-Code
                        until (not block_string_success);
\end_layout

\begin_layout LyX-Code
                    end;
\end_layout

\begin_layout LyX-Code
                end;
\end_layout

\begin_layout LyX-Code
                if (self_success)
\end_layout

\begin_layout LyX-Code
                    return (Result, true);
\end_layout

\begin_layout LyX-Code
            end;
\end_layout

\begin_layout LyX-Code
            if (i is not already at the end of inst)
\end_layout

\begin_layout LyX-Code
                i := i + 1;
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
R_block_string
\family default
 function returns a list of straws stemming from one object in the 
\family typewriter
inst
\family default
 parameter.
 It does not return until it has either found such a match or has exhausted
 the 
\family typewriter
inst
\family default
 array.
\end_layout

\begin_layout Standard
The outline of the function is as follows:
\end_layout

\begin_layout Enumerate
If the syntactic incarnation is just a 
\family typewriter
block_str
\family default
, return the result from a call to 
\family typewriter
R_block_str
\family default
.
\end_layout

\begin_layout Enumerate
If the syntactic incarnation is 
\family typewriter
block_str1 power block_string1
\family default
, then do the following: WHILE (true) DO
\end_layout

\begin_deeper
\begin_layout Enumerate
Get the results of 
\family typewriter
block_str1
\family default
 in 
\family typewriter
LStraws1
\family default
.
\end_layout

\begin_layout Enumerate
IF this was a failure, there is no use looking any further.
 We return with a failed match.
\end_layout

\begin_layout Enumerate
ELSE do the following
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialize 
\family typewriter
Result
\family default
 and 
\family typewriter
self_success
\family default
.
\end_layout

\begin_layout Enumerate
IF 
\family typewriter
LStraws1
\family default
 was empty (although it was a successful match) THEN do the following
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialize 
\family typewriter
U'
\family default
 and 
\family typewriter
Su'
\family default
 to be 
\family typewriter
U
\family default
 and 
\family typewriter
Su
\family default
 respectively.
\end_layout

\begin_layout Enumerate
Initialize 
\family typewriter
i'
\family default
 and calculate 
\family typewriter
inst'
\family default
 based on 
\family typewriter
U'
\family default
 and 
\family typewriter
block_string1
\family default
.
\end_layout

\begin_layout Enumerate
Exhaust 
\family typewriter
inst'
\family default
, adding the the results from 
\family typewriter
block_string1
\family default
 to our 
\family typewriter
Result
\family default
 for each match in 
\family typewriter
inst'
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
ELSE FOR (each 
\family typewriter
Straw1
\family default
 in 
\family typewriter
LStraws1
\family default
) DO
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialize 
\family typewriter
U'
\family default
 and 
\family typewriter
Su'
\family default
 to be 
\family typewriter
U
\family default
 and 
\family typewriter
Su
\family default
 respectively, but with all the monads up to 
\family typewriter
Straw1
\family default
.last()
\begin_inset Foot
status collapsed

\begin_layout Standard
Note that the last() operation on a 
\family typewriter
straw
\family default
 is always well defined because there will always be a 
\family typewriter
matched_object
\family default
 that has the largest monad.
 The last monad of a 
\family typewriter
straw
\family default
 could be stored explicitly and updated every time a 
\family typewriter
matched_object
\family default
 was added to it.
\end_layout

\end_inset

 cut away.
 If either 
\family typewriter
U'
\family default
 or 
\family typewriter
Su'
\family default
 is now empty, don't do the next two items.
\end_layout

\begin_layout Enumerate
Initialize 
\family typewriter
i'
\family default
 and calculate 
\family typewriter
inst'
\family default
 based on 
\family typewriter
U'
\family default
 and 
\family typewriter
block_string1
\family default
.
\end_layout

\begin_layout Enumerate
Exhaust 
\family typewriter
inst'
\family default
, adding the join of 
\family typewriter
Straw1
\family default
 and the results from 
\family typewriter
block_string1
\family default
 to our 
\family typewriter
Result
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
IF we were a success THEN return 
\family typewriter
Result
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Increment 
\family typewriter
i
\family default
and go once more round the loop.
\end_layout

\end_deeper
\begin_layout Subsection
power
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
power  :  ".."  restrictor  ;
\end_layout

\begin_layout LyX-Code
restrictor  :  /* empty */  |  '<'  limit  ;
\end_layout

\begin_layout LyX-Code
limit  :  INTEGER  ;  /* non-negative integer, may be 0.
  */
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_power
\end_layout

\begin_layout LyX-Code
 * Returns : an integer which is the limit, 0 if no restrictor
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_power(power) --> INTEGER;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
    if (restrictor is empty) then
\end_layout

\begin_layout LyX-Code
        return 0;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return limit;  /* Note: This is an abstraction of "return
\end_layout

\begin_layout LyX-Code
                          R_limit(limit)", where R_limit simply
\end_layout

\begin_layout LyX-Code
                          returns the integer value of limit.
 */
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
This retrieval function simply returns the 
\family typewriter
limit
\family default
 in the 
\family typewriter
restrictor
\family default
, or 0 if the 
\family typewriter
restrictor
\family default
 is empty.
 The reason why we return 0 when the 
\family typewriter
restrictor
\family default
 is empty is that 
\begin_inset Quotes eld
\end_inset

no 
\family typewriter
restrictor
\family default

\begin_inset Quotes erd
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

no limit
\begin_inset Quotes erd
\end_inset

, which is denoted by a limit of 0.
\end_layout

\begin_layout Subsection
block_str
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
block_str  :  object_block_first  |
\end_layout

\begin_layout LyX-Code
              object_block_first  rest_of_block_str  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_block_str
\end_layout

\begin_layout LyX-Code
 * Returns : (list_of_straws, boolean)
\end_layout

\begin_layout LyX-Code
 *           The boolean indicates success (true) or failure (false)
\end_layout

\begin_layout LyX-Code
 * ON FAIL: (< >, false)
\end_layout

\begin_layout LyX-Code
 *          Only fails if all the i's within the inst array
\end_layout

\begin_layout LyX-Code
 *          have been exhausted.
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: (list_of_straws, true)
\end_layout

\begin_layout LyX-Code
 *             A list of straws stemming from one index 
\end_layout

\begin_layout LyX-Code
 *             in the inst array.
\end_layout

\begin_layout LyX-Code
function R_block_str(U,Su,var i,inst,limit,block_str) 
\end_layout

\begin_layout LyX-Code
         --> (list_of_straws,boolean);
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
   mo : matched_object;
\end_layout

\begin_layout LyX-Code
   Sm : monad; /* Start Monad */
\end_layout

\begin_layout LyX-Code
   noretrieve : boolean;
\end_layout

\begin_layout LyX-Code
   los : list_of_straws;
\end_layout

\begin_layout LyX-Code
   rest_success : boolean;
\end_layout

\begin_layout LyX-Code
   self_success : boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    self_success := false;
\end_layout

\begin_layout LyX-Code
    while (true) do
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
        if (block_str = object_block_first) then
\end_layout

\begin_layout LyX-Code
        begin 
\end_layout

\begin_layout LyX-Code
            (mo, noretrieve) := R_object_block_first(U,Su,i,
\end_layout

\begin_layout LyX-Code
                                    inst,limit,object_block_first);
\end_layout

\begin_layout LyX-Code
            if (mo = NIL_mo) then
\end_layout

\begin_layout LyX-Code
               return (< >, self_success);  
\end_layout

\begin_layout LyX-Code
                           /* This means that R_object_block_first 
\end_layout

\begin_layout LyX-Code
                              failed.
 */
\end_layout

\begin_layout LyX-Code
            else if (not noretrieve)
\end_layout

\begin_layout LyX-Code
               return (< < mo > >, true); 
\end_layout

\begin_layout LyX-Code
            else /* we are a success, but we mustn't return yet.
 */
\end_layout

\begin_layout LyX-Code
                self_success := true; 
\end_layout

\begin_layout LyX-Code
        end 
\end_layout

\begin_layout LyX-Code
        else
\end_layout

\begin_layout LyX-Code
        begin /*  object_block_first  rest_of_block_str  */
\end_layout

\begin_layout LyX-Code
            /* Get result of object_block_first */
\end_layout

\begin_layout LyX-Code
            (mo, noretrieve) := R_object_block_first(U,Su,i,
\end_layout

\begin_layout LyX-Code
                                    inst,limit,object_block_first); 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* If mo = NIL_mo, it means that R_object_block_first
\end_layout

\begin_layout LyX-Code
             * has exhausted all possibilities */
\end_layout

\begin_layout LyX-Code
            if (mo = NIL_mo) then
\end_layout

\begin_layout LyX-Code
                return (< >, false); 
\end_layout

\begin_layout LyX-Code
            else
\end_layout

\begin_layout LyX-Code
            begin
\end_layout

\begin_layout LyX-Code
                /* Calculate start monad */
\end_layout

\begin_layout LyX-Code
                Sm := mo.last() + 1;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
                /* Get result of rest_of_block_str */
\end_layout

\begin_layout LyX-Code
                (los, rest_success) := R_rest_of_block_str(U,Su,
\end_layout

\begin_layout LyX-Code
                         Sm,rest_of_block_str);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
                if (rest_success) then
\end_layout

\begin_layout LyX-Code
                begin
\end_layout

\begin_layout LyX-Code
                    if (noretrieve) then
\end_layout

\begin_layout LyX-Code
                        return (los, true);
\end_layout

\begin_layout LyX-Code
                    else
\end_layout

\begin_layout LyX-Code
                        return (Join( < mo > , los ), true);
\end_layout

\begin_layout LyX-Code
                end;
\end_layout

\begin_layout LyX-Code
            end;
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
        i := i + 1;
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The R_block_str function returns a list of straws.
 If successful, it returns a list of straws stemming from one member of
 the inst parameter.
 If unsuccessful, it returns (< >,false).
 It does not return until it has either found a match or has exhausted all
 possibilities.
\end_layout

\begin_layout Standard
This function only returns in these cases:
\end_layout

\begin_layout Enumerate
If the syntactic incarnation is just 
\family typewriter
object_block_first
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
If the call to 
\family typewriter
R_object_block_first
\family default
 failed, we return the empty list of straws, coupled with a boolean saying
 whether we were overall a success or not.
\end_layout

\begin_layout Enumerate
If the call to 
\family typewriter
R_object_block_first
\family default
 did not fail, but returned a matched_object 
\family typewriter
mo
\family default
 which we must also retrieve, we return a list of straws containing one
 
\family typewriter
straw
\family default
 containing 
\family typewriter
mo
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
If the syntactic incarnation is 
\family typewriter
object_block_first
\family default
 followed by 
\family typewriter
rest_of_block_str
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
If the call to 
\family typewriter
R_object_block_first
\family default
 failed, we return the empty list of straws.
\end_layout

\begin_layout Enumerate
If the call to 
\family typewriter
R_object_block_first
\family default
 did not fail, but returned a 
\family typewriter
matched_object
\family default
 
\family typewriter
mo
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
If we are 
\emph on
not
\emph default
 to retrieve 
\family typewriter
mo
\family default
, and the call to 
\family typewriter
R_rest_of_block_str
\family default
 returned a non-empty list of straws 
\family typewriter
los
\family default
, we return 
\family typewriter
los
\family default
.
\end_layout

\begin_layout Enumerate
If we are to retrieve 
\family typewriter
mo
\family default
, and the call to 
\family typewriter
R_rest_of_block_str
\family default
 returned a non-empty list of straws 
\family typewriter
los
\family default
, we return 
\family typewriter
< mo >
\family default
 joined into 
\family typewriter
los
\family default
.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
If none of these cases apply, we increment 
\family typewriter
i
\family default
 by one and try once more.
\end_layout

\begin_layout Subsection
object_block_first
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
object_block_first : '['  object_type_name  
\end_layout

\begin_layout LyX-Code
                     object_reference_declaration
\end_layout

\begin_layout LyX-Code
                     retrieval  firstlast  features  
\end_layout

\begin_layout LyX-Code
                     opt_blocks  ']'  ;
\end_layout

\begin_layout LyX-Code
object_type_name : T_IDENTIFIER ;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_object_block_first
\end_layout

\begin_layout LyX-Code
 * Returns : mo_nr (pair: (matched_object, noretrieve))
\end_layout

\begin_layout LyX-Code
 * NOTE: The matched_object cannot be EMPTY_mo
\end_layout

\begin_layout LyX-Code
 * ON FAIL: (NIL_mo,true)
\end_layout

\begin_layout LyX-Code
 *          Only fails if it has exhausted all the i's 
\end_layout

\begin_layout LyX-Code
 *          in the inst array.
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: ( [ id_d focus sheaf ] , true|false )
\end_layout

\begin_layout LyX-Code
 *
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_object_block_first(U,Su,var i,inst,limit,
\end_layout

\begin_layout LyX-Code
            object_block_first) --> mo_nr ;
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    O : object;
\end_layout

\begin_layout LyX-Code
    Inner : sheaf;
\end_layout

\begin_layout LyX-Code
    fl : enum_first_last;
\end_layout

\begin_layout LyX-Code
    U' : set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
    inst' : instances;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- Calculate first or last.
 --- */
\end_layout

\begin_layout LyX-Code
    fl := R_first_last(firstlast);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
    while (true) do
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* --- If we have gone too far, we must fail.
  --- */
\end_layout

\begin_layout LyX-Code
        if (i > length(inst)) then
\end_layout

\begin_layout LyX-Code
            return (NIL_mo,true);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* --- Get the object of type "type" which is the i'th 
\end_layout

\begin_layout LyX-Code
           within the universe U.
 --- */
\end_layout

\begin_layout LyX-Code
        O := inst[i];
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* --- Only do rest of checking if the first/last rules 
\end_layout

\begin_layout LyX-Code
           are obeyed.
 --- */
\end_layout

\begin_layout LyX-Code
        if (((limit <> 0) and (O.first() > (Su.first() + limit)))
\end_layout

\begin_layout LyX-Code
             or (limit = 0))
\end_layout

\begin_layout LyX-Code
            and
\end_layout

\begin_layout LyX-Code
            (((fl = first or fl = first_and_last) 
\end_layout

\begin_layout LyX-Code
              and (O.first() = Su.first()))
\end_layout

\begin_layout LyX-Code
             or (fl = no_first_last))
\end_layout

\begin_layout LyX-Code
            and 
\end_layout

\begin_layout LyX-Code
            (((fl = last or fl = first_and_last) 
\end_layout

\begin_layout LyX-Code
              and (O.last() = Su.last()))
\end_layout

\begin_layout LyX-Code
             or (fl = no_first_last))
\end_layout

\begin_layout LyX-Code
            and
\end_layout

\begin_layout LyX-Code
            (O part_of Su)
\end_layout

\begin_layout LyX-Code
            and 
\end_layout

\begin_layout LyX-Code
            (R_features(O,features))) then
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            /* --- Update symbol table with 
\end_layout

\begin_layout LyX-Code
               object reference declaration --- */
\end_layout

\begin_layout LyX-Code
            R_object_reference_declaration(O,
\end_layout

\begin_layout LyX-Code
                object_reference_declaration);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Make new universe 
\end_layout

\begin_layout LyX-Code
               (O.first()..O.last()) --- */ 
\end_layout

\begin_layout LyX-Code
            U' = Hat(O,U);  /* O^U */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Calculate new inst --- */
\end_layout

\begin_layout LyX-Code
            inst' := R_inst_opt_blocks(U', opt_blocks);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Compute the inner blocks.
 --- */ 
\end_layout

\begin_layout LyX-Code
            Inner := R_opt_blocks(U',O,inst',opt_blocks);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Only return the object if the inner 
\end_layout

\begin_layout LyX-Code
               did not fail.
 Make sure that noretrieve 
\end_layout

\begin_layout LyX-Code
               rules are obeyed.
 --- */
\end_layout

\begin_layout LyX-Code
            if (Inner <> "// ") 
\end_layout

\begin_layout LyX-Code
                return ([ O.id R_focus_retrieval(retrieval) 
\end_layout

\begin_layout LyX-Code
                          Inner ], 
\end_layout

\begin_layout LyX-Code
                         R_retrieveal_retrieval(retrieval));
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
        if (i is not already at the end of inst)
\end_layout

\begin_layout LyX-Code
            i := i + 1;
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
R_object_block_first
\family default
 function returns an mo_nr pair (see section 
\begin_inset LatexCommand \vref{sub:mo_nr}

\end_inset

).
 If successful, the 
\family typewriter
matched_object
\family default
 in the pair refers to an object_dm.
 If unsuccessful, the matched_object is 
\begin_inset Quotes eld
\end_inset

NIL_mo
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The function looks through the 
\family typewriter
inst
\family default
 array, starting at 
\family typewriter
i
\family default
.
 It does not return until it has either found a match or has exhausted the
 array.
\end_layout

\begin_layout Standard
When 
\family typewriter
limit
\family default
 is non-zero, it means that there must be at most 
\family typewriter
limit
\family default
 monads between the first monad of the 
\family typewriter
U
\family default
 universe-parameter and the first monad of an object O matched by the 
\family typewriter
object_block_first
\family default
.
 When 
\family typewriter
limit
\family default
 is 0, it means that no limit is enforced.
\end_layout

\begin_layout Standard
This function only returns in the following cases:
\end_layout

\begin_layout Enumerate
If we went past the end of the inst(T,U) array, we return 
\family typewriter
(NIL_mo,true)
\family default
, which means 
\begin_inset Quotes eld
\end_inset

failed match
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
If we did find an object at some inst(T,U)[i], and a lot of constraints
 on this object were upheld (see below), we return the 
\family typewriter
matched_object
\family default
 along with the 
\family typewriter
boolean
\family default
 returned by 
\family typewriter
R_retrieval(retrieval)
\family default
.
\end_layout

\begin_layout Standard
Otherwise, we just keep incrementing 
\family typewriter
i
\family default
 until one of the three cases above apply.
\end_layout

\begin_layout Standard
This function is actually quite simple, despite its cluttered look.
 The basic outline is as follows:
\end_layout

\begin_layout Enumerate
Calculate 
\family typewriter
fl
\family default
 
\family typewriter
:=
\family default
 
\family typewriter
R_first_last(firstlast)
\family default
.
\end_layout

\begin_layout Enumerate
WHILE (
\family typewriter
true
\family default
) DO
\end_layout

\begin_deeper
\begin_layout Enumerate
IF (
\family typewriter
i
\family default
 is past the length of 
\family typewriter
inst
\family default
, THEN return 
\family typewriter
(NIL_mo,true)
\family default
.
 We have exhausted the array, so we must fail.
\end_layout

\begin_layout Enumerate
Calculate 
\family typewriter
O
\family default
 := 
\family typewriter
inst[i]
\family default
.
\end_layout

\begin_layout Enumerate
IF (limit is upheld) AND (the rules on 
\family typewriter
firstlast
\family default
 are obeyed) AND (
\family typewriter
O
\family default
 part_of 
\family typewriter
Su
\family default
) AND (the features match) THEN
\end_layout

\begin_deeper
\begin_layout Enumerate
Update the symbol table with the object reference declaration.
\end_layout

\begin_layout Enumerate
Calculate 
\family typewriter
U'
\family default
 
\family typewriter
:=
\family default
 
\family typewriter
Hat(O,U)
\family default
.
 (See section 
\begin_inset LatexCommand \vref{hat}

\end_inset

.)
\end_layout

\begin_layout Enumerate
Calculate a new instances array based on 
\family typewriter
U'
\family default
.
\end_layout

\begin_layout Enumerate
Calculate the inner 
\family typewriter
blocks
\family default
 by calling 
\family typewriter
R_opt_blocks
\family default
 with 
\family typewriter
U'
\family default
 as the universe, 
\family typewriter
O
\family default
 as the substrate
\begin_inset Foot
status collapsed

\begin_layout Standard
This is important! O becomes the substrate!
\end_layout

\end_inset

, inst' as the instances array, and 
\family typewriter
opt_blocks
\family default
 as the syntactic construct.
\end_layout

\begin_layout Enumerate
IF (this Inner 
\family typewriter
blocks
\family default
 was not a failed match) THEN return a 
\family typewriter
matched_object
\family default
 consisting of the object id_d of 
\family typewriter
O
\family default
 along with the Inner 
\family typewriter
sheaf
\family default
.
 This is, of course, paired with 
\family typewriter
R_retrieval(retrieval)
\family default
, since we are returning an 
\family typewriter
mo_nr
\family default
 rather than a 
\family typewriter
matched_object
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Increment 
\family typewriter
i
\family default
 by 1 and take one more pass through the WHILE loop.
\end_layout

\end_deeper
\begin_layout Subsection
object_reference_declaration
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
object_reference_declaration : /* empty */ 
\end_layout

\begin_layout LyX-Code
                             | T_KEY_AS object_reference ;
\end_layout

\begin_layout LyX-Code
object_reference : T_IDENTIFIER ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_object_reference_declaration
\end_layout

\begin_layout LyX-Code
 * Returns : Nothing
\end_layout

\begin_layout LyX-Code
 * ON FAIL: Cannot fail.
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_object_reference_declaration(O,
\end_layout

\begin_layout LyX-Code
             object_reference_declaration);
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (syntactic incarnation is not empty) 
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        /* Associate the object_reference with O's object id_d
\end_layout

\begin_layout LyX-Code
           in the symbol table.
 */
\end_layout

\begin_layout LyX-Code
        /* Retrieve the features that are used later.
 */
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
This function does not return anything.
 Rather, it updates the symbol table with information.
 If the syntactic incarnation is not empty, it does the following two things:
\end_layout

\begin_layout Enumerate
It associates the object reference with O's object id_d.
\end_layout

\begin_layout Enumerate
It retrieves all the features that are to be used later.
 The list of features to be retrieved has been determined statically at
 compile-time.
 The pertinent features are fetched and stored in the symbol table.
\end_layout

\begin_layout Subsection
R_inst_opt_blocks
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
opt_blocks  :  /* empty */  |  blocks  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_inst_opt_blocks
\end_layout

\begin_layout LyX-Code
 * returns : an inst(T,U) array.
\end_layout

\begin_layout LyX-Code
 * ON FAIL: Cannot fail (but the array may be empty).
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_inst_opt_blocks(U,opt_blocks) --> instances;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (syntactic incarnation is 
\begin_inset Quotes eld
\end_inset

blocks
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
        return R_inst_blocks(U, blocks);
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return /* empty instances array */;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
If the syntactic incarnation is 
\begin_inset Quotes eld
\end_inset


\family typewriter
blocks
\family default

\begin_inset Quotes erd
\end_inset

, this function calls the 
\family typewriter
R_inst_blocks
\family default
 function and returns its result.
 If, on the other hand, the syntactic incarnation is empty, then an empty
 array is returned.
\end_layout

\begin_layout Subsection
R_focus_retrieval
\end_layout

\begin_layout Standard
The 
\family typewriter
retrieval
\family default
 syntactic construct is used in 
\family typewriter
object_block_first
\family default
 and 
\family typewriter
object_block
\family default
.
 This function returns the answer to the question 
\begin_inset Quotes eld
\end_inset

Is this a focus-object?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
retrieval  :  /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
           |  T_KEY_RETRIEVE  |  T_KEY_FOCUS;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_focus_retrieval
\end_layout

\begin_layout LyX-Code
 * Returns : true if "focus", false otherwise.
\end_layout

\begin_layout LyX-Code
 *           Thus the default, when empty, is to retrieve
\end_layout

\begin_layout LyX-Code
 *           the object.
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_focus_retrieval(retrieval) --> boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (retrieval = T_KEY_FOCUS) then
\end_layout

\begin_layout LyX-Code
        return true;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return false;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
This function returns the answer to the question 
\begin_inset Quotes eld
\end_inset

Is this object a focus-object?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
R_retrieval_retrieval
\end_layout

\begin_layout Standard
The 
\family typewriter
retrieval
\family default
 syntactic construct is used in 
\family typewriter
object_block_first
\family default
 and 
\family typewriter
object_block
\family default
.
 It differs from the 
\family typewriter
gap_retrieval
\family default
 construct only in its interpretation of what to return when empty.
 This function returns the answer to the question 
\begin_inset Quotes eld
\end_inset

Should this object be retrieved?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
retrieval  :  /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
           |  T_KEY_RETRIEVE  |  T_KEY_FOCUS;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_retrieval_retrieval
\end_layout

\begin_layout LyX-Code
 * Returns : true if "noretrieve", false otherwise.
\end_layout

\begin_layout LyX-Code
 *           Thus the default, when empty, is to retrieve
\end_layout

\begin_layout LyX-Code
 *           the object.
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_retrieval_retrieval(retrieval) --> boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (retrieval = T_KEY_NORETRIEVE) then
\end_layout

\begin_layout LyX-Code
        return true;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return false;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The idea of 
\family typewriter
retrieval
\family default
 is that, if the user does not wish to retrieve an object, he or she can
 choose not to do so.
 The meaning of the result of 
\family typewriter
R_retrieval_retrieval
\family default
 is the answer to the question 
\begin_inset Quotes eld
\end_inset

do we want to 
\emph on
not
\emph default
 retrieve this 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
)?
\begin_inset Quotes erd
\end_inset

.
 Thus this function returns 
\begin_inset Quotes eld
\end_inset


\family typewriter
true
\family default

\begin_inset Quotes erd
\end_inset

 if the 
\family typewriter
noretrieve
\family default
 modifier is present and false otherwise.
\end_layout

\begin_layout Standard
The default for 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
) is to assume that we do want to retrieve the objects.
 This differs from Doedens' QL, where we have to explicitly mark 
\family typewriter
block
\family default
s for retrieval.
\end_layout

\begin_layout Standard
If a an 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
) B has the 
\family typewriter
no_retrieve
\family default
 modifier, no objects matched inside B can be retrieved either.
 This is because MQL is a topographic language, and allowing objects inside
 a non-retrieved object to be retrieved would violate the topographic nature
 of the language.
\end_layout

\begin_layout Subsection
first_last
\end_layout

\begin_layout Standard
The 
\family typewriter
first_last
\family default
 construct is used in 
\family typewriter
object_block_first
\family default
.
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
firstlast  :  /* empty */  |  T_KEY_FIRST  |  T_KEY_LAST  
\end_layout

\begin_layout LyX-Code
           |  T_KEY_FIRST  T_KEY_AND  T_KEY_LAST  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_first_last
\end_layout

\begin_layout LyX-Code
 * Returns : enum_first_last
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_first_last(firstlast) --> enum_first_last;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (firstlast = T_KEY_FIRST) then
\end_layout

\begin_layout LyX-Code
        return first;
\end_layout

\begin_layout LyX-Code
    else if (firstlast = T_KEY_LAST) then
\end_layout

\begin_layout LyX-Code
        return last;
\end_layout

\begin_layout LyX-Code
    else if (firstlast is empty) then
\end_layout

\begin_layout LyX-Code
        return no_first_last;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return first_and_last;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
See section 
\begin_inset LatexCommand \vref{firstlast_explanation}

\end_inset

 for an explanation.
\end_layout

\begin_layout Subsection
features
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
features  :  /* empty */  |  ffeatures  ;
\end_layout

\begin_layout LyX-Code
ffeatures  :  fterm  |  ffeatures  "or"  fterm  ;
\end_layout

\begin_layout LyX-Code
fterm  :  ffactor  |  fterm  "and"  ffactor  ;
\end_layout

\begin_layout LyX-Code
ffactor :  T_KEY_NOT  ffactor  |  '('  ffeatures  ')'  
\end_layout

\begin_layout LyX-Code
        |  feature_comparison ;
\end_layout

\begin_layout LyX-Code
feature_comparison : feature_name comparison_operator value  ;
\end_layout

\begin_layout LyX-Code
feature_name  :  T_IDENTIFIER  ;
\end_layout

\begin_layout LyX-Code
comparison_operator : T_KEY_EQUALS | T_KEY_LESS_THAN 
\end_layout

\begin_layout LyX-Code
                    | T_KEY_GREATER_THAN | T_KEY_NOT_EQUAL
\end_layout

\begin_layout LyX-Code
                    | T_KEY_LESS_THAN_OR_EQUAL
\end_layout

\begin_layout LyX-Code
                    | T_KEY_GREATER_THAN_OR_EQUAL ;
\end_layout

\begin_layout LyX-Code
value  :  enum_const  |  T_INTEGER  |  T_STRING  
\end_layout

\begin_layout LyX-Code
       |  object_reference_usage  ;
\end_layout

\begin_layout LyX-Code
enum_const  :  T_IDENTIFIER  ;
\end_layout

\begin_layout LyX-Code
object_reference_usage : object_reference '.' feature_name ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_features
\end_layout

\begin_layout LyX-Code
 * Returns : a boolean indicating whether the features matched
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_features(O,features) --> boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
  if (features is empty) then
\end_layout

\begin_layout LyX-Code
      return true.
  
\end_layout

\begin_layout LyX-Code
  else, 
\end_layout

\begin_layout LyX-Code
      traverse tree represented by features,
\end_layout

\begin_layout LyX-Code
      deciding truth-value with respect to O.
  
\end_layout

\begin_layout LyX-Code
      Return the result.
 
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The result of 
\family typewriter
R_features
\family default
 is the answer to the question, 
\begin_inset Quotes eld
\end_inset

do the feature-constraints in 
\family typewriter
features
\family default
 match with the features of the object 
\family typewriter
O
\family default
?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
ffeatures
\family default
 syntactic construct is assumed to be represented as an Abstract Syntax
 Tree (AST).
 We can then traverse the tree in depth-first order, deciding truth-value
 recursively.
 We may use short-circuit evaluation, since there are no side-effects.
\end_layout

\begin_layout Subsection
opt_blocks
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
opt_blocks  :  /* empty */  |  blocks  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_opt_blocks
\end_layout

\begin_layout LyX-Code
 * Returns: sheaf
\end_layout

\begin_layout LyX-Code
 *          For opt_blocks being empty: // < > (not a fail)
\end_layout

\begin_layout LyX-Code
 *          For opt_blocks being a blocks:  The sheaf for the blocks
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
function R_opt_blocks(U,Su,inst,opt_blocks) --> sheaf;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
    if (opt_blocks = blocks) then
\end_layout

\begin_layout LyX-Code
        return R_blocks(U,Su,inst,opt_blocks);
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return "// < >";
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
As will be recalled from the grammar in section 
\begin_inset LatexCommand \ref{MQLgrammar}

\end_inset

 on page 
\begin_inset LatexCommand \pageref{MQLgrammar}

\end_inset

, 
\family typewriter
opt_blocks
\family default
 represents the inner 
\family typewriter
blocks
\family default
 in an 
\family typewriter
object_block
\family default
 or 
\family typewriter
object_block_first
\family default
.
 The reason why we have a special nonterminal and not just a 
\family typewriter
blocks
\family default
 is, of course, that we want it to be able to be empty.
 When empty, we should just return the least sheaf which is not a failed
 match (i.e., 
\begin_inset Quotes eld
\end_inset


\family typewriter
//\InsetSpace ~
< >
\family default

\begin_inset Quotes erd
\end_inset

).
 When non-empty, we should return whatever the retrieveal function on the
 inner 
\family typewriter
blocks
\family default
 returns.
 
\family typewriter
R_opt_blocks
\family default
 does just that.
\end_layout

\begin_layout Subsection
rest_of_block_str
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
rest_of_block_str  :  block  |  block1  rest_of_block_str1  ;
\end_layout

\begin_layout Standard
NOTE: The 1's on the second usage of 
\family typewriter
block
\family default
 and 
\family typewriter
rest_of_block_str
\family default
 are just there for identification purposes.
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_rest_of_block_str
\end_layout

\begin_layout LyX-Code
 * Returns : (list_of_straws, boolean) 
\end_layout

\begin_layout LyX-Code
 *           The boolean indicates success (true) or failure (false)
\end_layout

\begin_layout LyX-Code
 * ON FAIL: (< >, false)
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: (list_of_straws, true)
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_rest_of_block_str(U,Su,Sm,rest_of_block_str) --> 
\end_layout

\begin_layout LyX-Code
         (list_of_straws,boolean);
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    noretrieve : boolean;
\end_layout

\begin_layout LyX-Code
    mo : matched_object;
\end_layout

\begin_layout LyX-Code
    rest : list_of_straws;
\end_layout

\begin_layout LyX-Code
    Sm' : monad; /* --- Start Monad.
 --- */
\end_layout

\begin_layout LyX-Code
    Result : list_of_straws;
\end_layout

\begin_layout LyX-Code
    lomn : list_of_mo_nr;
\end_layout

\begin_layout LyX-Code
    recursive_success : boolean; /* result of recursive call */
\end_layout

\begin_layout LyX-Code
    self_success : boolean; /* Success of this call */
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
    if (rest_of_block_str = block) then
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        /* --- Get the result of R_block.
 --- */
\end_layout

\begin_layout LyX-Code
        lomn := R_block(U,Su,Sm,block);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        if (lomn has NIL_mo)
\end_layout

\begin_layout LyX-Code
            return (< >, false); 
\end_layout

\begin_layout LyX-Code
        else if (lomn has EMPTY_mo)
\end_layout

\begin_layout LyX-Code
            return (< >, true);
\end_layout

\begin_layout LyX-Code
        else 
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            Result := < >;
\end_layout

\begin_layout LyX-Code
            for (each (mo,noretrieve) in lomn) do
\end_layout

\begin_layout LyX-Code
            begin
\end_layout

\begin_layout LyX-Code
                /* --- Note: We will always get here, since the match 
\end_layout

\begin_layout LyX-Code
                   did not fail.
 --- */
\end_layout

\begin_layout LyX-Code
                if (not noretrieve) then
\end_layout

\begin_layout LyX-Code
                    Result := Result + < < mo > >;
\end_layout

\begin_layout LyX-Code
            end;
\end_layout

\begin_layout LyX-Code
            return (Result, true);
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
    end else /* ---  block1  rest_of_block_str1  --- */
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        /* --- Get first block.
 --- */
\end_layout

\begin_layout LyX-Code
        lomn := R_block(U,Su,Sm,block1);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* Return now if we failed.
 */
\end_layout

\begin_layout LyX-Code
        if (lomn has NIL_mo) then
\end_layout

\begin_layout LyX-Code
            return (< >, false);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* --- Calculate the rest.
 --- */
\end_layout

\begin_layout LyX-Code
        Result := < >;
\end_layout

\begin_layout LyX-Code
        self_success := false;
\end_layout

\begin_layout LyX-Code
        for (each (mo,noretrieve) in lomn) do
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            /* --- Note:  We will always get here, since the 
\end_layout

\begin_layout LyX-Code
               match did not fail (wasn't NIL_mo).
 --- */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Calculate Start Monad.
 --- */
\end_layout

\begin_layout LyX-Code
            if (mo = EMPTY_mo) then
\end_layout

\begin_layout LyX-Code
                Sm' := Sm;
\end_layout

\begin_layout LyX-Code
            else
\end_layout

\begin_layout LyX-Code
                Sm' := mo.last() + 1;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Get the rest.
 This is a recursive call to
\end_layout

\begin_layout LyX-Code
               ourselves.
 ---  */
\end_layout

\begin_layout LyX-Code
            (rest, success) := R_rest_of_block_str(U,Su,
\end_layout

\begin_layout LyX-Code
                                 Sm',rest_of_block_str1);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Only add if rest was a success! --- */
\end_layout

\begin_layout LyX-Code
            if (success) then
\end_layout

\begin_layout LyX-Code
            begin
\end_layout

\begin_layout LyX-Code
                /* We succeed if at least one mo in lomn
\end_layout

\begin_layout LyX-Code
                 * matched together with the rest_of_block_str1.
 */
\end_layout

\begin_layout LyX-Code
                self_success := true;
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
                /* If noretrieve was true, do not add mo.
\end_layout

\begin_layout LyX-Code
                 * Add rest.
 
\end_layout

\begin_layout LyX-Code
                 * Note that, for EMPTY_mo, noretrieve is true,
\end_layout

\begin_layout LyX-Code
                 * and therefore the EMPTY_mo does not enter the
\end_layout

\begin_layout LyX-Code
                 * result.
 */
\end_layout

\begin_layout LyX-Code
                if (noretrieve) then
\begin_inset Foot
status collapsed

\begin_layout Standard
Note how this excludes EMPTY_mo from being included in the result.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
                    Result := Result + rest;
\end_layout

\begin_layout LyX-Code
                else 
\end_layout

\begin_layout LyX-Code
                    Result := Result + Join(< mo >, rest);
\end_layout

\begin_layout LyX-Code
                end;
\end_layout

\begin_layout LyX-Code
            end;
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
        return (Result, self_success);
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The R_rest_of_block_str function returns a list of straws.
 This list of straws contains all the straws stemming from objects starting
 at Sm.
\end_layout

\begin_layout Standard
If the syntactic incarnation is just 
\begin_inset Quotes eld
\end_inset


\family typewriter
block
\family default

\begin_inset Quotes erd
\end_inset

, and the 
\family typewriter
block
\family default
 is an 
\family typewriter
object_block
\family default
, then the list of straws contains a straw for each object that starts at
 Sm and which matches and which we must retrieve.
\end_layout

\begin_layout Standard
If the syntactic incarnation is 
\begin_inset Quotes eld
\end_inset

block1 rest_of_block_str1
\begin_inset Quotes erd
\end_inset

, then the list of straws contains a straw for each object/gap that starts
 at Sm, multiplied by the straws resulting from a recursive call to ourselves.
\end_layout

\begin_layout Standard
The outline of the function is not that difficult to understand.
 It just looks cluttered in the code.
 The outline is as follows:
\end_layout

\begin_layout Enumerate
If the syntactic incarnation is 
\family typewriter
block
\family default
, do the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Set 
\family typewriter
lomn
\family default
 
\family typewriter
:=
\family default
 the result of a call to 
\family typewriter
R_block
\family default
 on the 
\family typewriter
block
\family default
.
\end_layout

\begin_layout Enumerate
IF the result was 
\family typewriter
(NIL_mo,true)
\family default
 THEN return 
\family typewriter
(< >
\family default
, false).
 This is because we failed.
\end_layout

\begin_layout Enumerate
ELSE IF the result was (EMPTY_mo, true) THEN return (< >, true).
 We matched an empty gap with 
\family typewriter
opt_gap_block
\family default
, which was a success.
\end_layout

\begin_layout Enumerate
ELSE Return a list of straws, each straw containing one 
\family typewriter
matched_object
\family default
 from 
\family typewriter
lomn
\family default
, if that 
\family typewriter
matched_object
\family default
 was to be retrieved.
\end_layout

\end_deeper
\begin_layout Enumerate
If the syntactic incarnation is 
\begin_inset Quotes eld
\end_inset


\family typewriter
block1\InsetSpace ~
\InsetSpace ~
rest_of_block_str1
\family default

\begin_inset Quotes erd
\end_inset

, do the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Set 
\family typewriter
lomn
\family default
 := the result of a call to 
\family typewriter
R_block
\family default
 on the 
\family typewriter
block1
\family default
.
\end_layout

\begin_layout Enumerate
IF (the 
\family typewriter
lomn
\family default
 is a singleton set with a 
\family typewriter
(NIL_mo,true)
\family default
 as the element) THEN return 
\family typewriter
(< >
\family default
, false), since we failed.
\end_layout

\begin_layout Enumerate
If not, initialize 
\family typewriter
Result
\family default
 to be 
\family typewriter
< >
\family default
 and 
\family typewriter
self_success
\family default
 to be 
\family typewriter
false
\family default
.
\end_layout

\begin_layout Enumerate
FOR each 
\family typewriter
(mo,noretrieve)
\family default
 in 
\family typewriter
lomn
\family default
, DO
\end_layout

\begin_deeper
\begin_layout Enumerate
IF (
\family typewriter
mo
\family default
 is 
\family typewriter
EMPTY_mo
\family default
) THEN
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialize 
\family typewriter
Sm'
\family default
 to be 
\family typewriter
Sm
\end_layout

\end_deeper
\begin_layout Enumerate
ELSE
\end_layout

\begin_deeper
\begin_layout Enumerate
Initialize 
\family typewriter
Sm'
\family default
 to be 
\family typewriter
mo.last() + 1
\begin_inset Foot
status collapsed

\begin_layout Standard
Where 
\family typewriter
mo.last()
\family default
 refers to the last monad_m of the object denoted by the object id_d in
 the 
\family typewriter
matched_object
\family default
 or the last monad_m of the object id_m in the 
\family typewriter
matched_object
\family default
.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Set 
\family typewriter
rest
\family default
 to be the result of a recursive call to 
\family typewriter
R_rest_of_block_str
\family default
, with the parameters the same as our formal parameters, except use 
\family typewriter
Sm'
\family default
 in place of 
\family typewriter
Sm
\family default
.
\end_layout

\begin_layout Enumerate
IF (
\family typewriter
rest
\family default
 succeeded) THEN
\end_layout

\begin_deeper
\begin_layout Enumerate
We now know that we have something successful to return.
 Therefore, set 
\family typewriter
self_success
\family default
 to true.
\end_layout

\begin_layout Enumerate
IF (
\family typewriter
noretrieve
\family default
 for the 
\family typewriter
mo_nr
\family default
 in the FOR-clause was true) THEN add 
\family typewriter
rest
\family default
 to 
\family typewriter
Result
\family default
, but do not add 
\family typewriter
mo
\family default
.
\end_layout

\begin_layout Enumerate
ELSE add the result of 
\family typewriter
Join({mo},rest)
\family default
 to 
\family typewriter
Result
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Return 
\family typewriter
(Result
\family default
, 
\family typewriter
self_success
\family default
).
\end_layout

\end_deeper
\begin_layout Standard
See section 
\begin_inset LatexCommand \vref{join}

\end_inset

 for the definition of 
\family typewriter
Join
\family default
.
\end_layout

\begin_layout Standard
Note that, in the second syntactic incarnation, the function is successful
 only if both the call to 
\family typewriter
R_blocks
\family default
 and the recursive call to 
\family typewriter
R_rest_of_block_str
\family default
 were successful.
 This is because the whole 
\family typewriter
rest_of_block_str
\family default
 must be present for the function not to fail.
\end_layout

\begin_layout Subsection
block
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
block  :  opt_gap_block  |  gap_block  |  object_block  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/* 
\end_layout

\begin_layout LyX-Code
 * R_block
\end_layout

\begin_layout LyX-Code
 * Returns: list_of_mo_nr
\end_layout

\begin_layout LyX-Code
 * ON FAIL: < (NIL_mo,true) >
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: Either:
\end_layout

\begin_layout LyX-Code
 *   - < (EMPTY_mo, true) > (from opt_gap_block).
\end_layout

\begin_layout LyX-Code
 *   - < ([ id_m focus sheaf ], true|false) > (from gap_block or 
\end_layout

\begin_layout LyX-Code
 *                                             opt_gap_block).
\end_layout

\begin_layout LyX-Code
 *   - A list of ([ id_d focus Sheaf ], true|false) with
\end_layout

\begin_layout LyX-Code
 *     all the object ids which start at Sm and which satisfy
\end_layout

\begin_layout LyX-Code
 *     certain criteria.
 (from object_block).
\end_layout

\begin_layout LyX-Code
 *
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_block(U,Su,Sm,block) --> list_of_mo_nr
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (block = opt_gap_block)
\end_layout

\begin_layout LyX-Code
        return R_opt_gap_block(U,Su,Sm,opt_gap_block);
\end_layout

\begin_layout LyX-Code
    else  if (block = gap_block)
\end_layout

\begin_layout LyX-Code
        return R_gap_block(U,Su,Sm,gap_block);
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return R_object_block(U,Su,Sm,object_block);
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The function just decides syntactic incarnation and calls the relevant retrieval
 function.
 
\end_layout

\begin_layout Standard
The result of a 
\family typewriter
block
\family default
 is either:
\end_layout

\begin_layout Enumerate
For 
\family typewriter
opt_gap_block
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
A 
\family typewriter
matched_object
\family default
 in the object id_m incarnation indicating a 
\emph on
gap
\emph default
 starting at monad 
\family typewriter
Sm
\family default
, paired with information about whether to retrieve the gap (the decision
 about whether to include them in a straw is made higher up in the hierarchy)
 OR
\end_layout

\begin_layout Enumerate
an 
\family typewriter
EMPTY_mo
\family default
 
\family typewriter
matched_object
\family default
 paired with the information that we 
\emph on
do not
\emph default
 want to retrieve it.
 Even if we didn't find a gap, we have succeeded in matching an empty stretch
 of the database: The gap was optional and thus needed not be there for
 the function to succeed.
\end_layout

\end_deeper
\begin_layout Enumerate
For 
\family typewriter
gap_block
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
A 
\family typewriter
matched_object
\family default
 in the object id_m incarnation indicating a 
\emph on
gap
\emph default
 starting at monad 
\family typewriter
Sm
\family default
, paired with information about whether to retrieve the gap (the decision
 about whether to include them in a straw is made higher up in the hierarchy)
 OR
\end_layout

\begin_layout Enumerate
an 
\family typewriter
NIL_mo
\family default
 
\family typewriter
matched_object
\family default
 paired with the information that we 
\emph on
do not
\emph default
 want to retrieve it.
 If we didn't find a gap, we must fail.
\end_layout

\end_deeper
\begin_layout Enumerate
For 
\family typewriter
object_block
\family default
:
\end_layout

\begin_deeper
\begin_layout Enumerate
A list of 
\family typewriter
matched_object
\family default
s starting at monad 
\family typewriter
Sm
\family default
, paired with information about whether we do not want to retrieve them
 (as with 
\family typewriter
opt_gap_block
\family default
, the decision about whether to include them in a straw is made higher up
 in the hierarchy), OR
\end_layout

\begin_layout Enumerate
A 
\family typewriter
NIL_mo
\family default
 
\family typewriter
matched_object
\family default
 paired with the information that we do not want to retrieve it.
 A 
\family typewriter
NIL_mo
\family default
 
\family typewriter
matched_object
\family default
 means 
\begin_inset Quotes eld
\end_inset

failed match
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
opt_gap_block
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
opt_gap_block : '['  T_KEY_OPT_GAP  gap_retrieval  opt_blocks  ']'  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/* 
\end_layout

\begin_layout LyX-Code
 * R_opt_gap_block
\end_layout

\begin_layout LyX-Code
 * Returns: (matched_object, noretrieve)
\end_layout

\begin_layout LyX-Code
 * ON FAIL: < (NIL_mo, true) >
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: < ( [ id_m focus sheaf ], true|false ) > or
\end_layout

\begin_layout LyX-Code
 *             < ( EMPTY_mo , true ) > (if there is no gap)
\end_layout

\begin_layout LyX-Code
 *
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_opt_gap_block(U,Su,Sm,opt_gap_block) --> list_of_mo_nr ; 
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    U', Su' : set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
    inst' : instances;
\end_layout

\begin_layout LyX-Code
    s : sheaf;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (there exists monad m such that Sm..m is a gap in Su 
\end_layout

\begin_layout LyX-Code
        with respect to U) then
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        U' := pow_m(Sm..m);
\end_layout

\begin_layout LyX-Code
        Su' := U';
\end_layout

\begin_layout LyX-Code
        inst' := R_inst_opt_blocks(U,opt_blocks);
\end_layout

\begin_layout LyX-Code
        s := R_opt_blocks(U',Su',inst',opt_blocks);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
        return < ( [ pow_m(Sm..m) R_focus_gap_retrieval(gap_retrieval) s],
 
\end_layout

\begin_layout LyX-Code
                   R_gap_retrieval(gap_retrieval)) >;
\end_layout

\begin_layout LyX-Code
    end
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return < (EMPTY_mo,true) >;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
This function returns a list of mo_nr's, but the list always has exactly
 1 member.
\end_layout

\begin_layout Standard
If there is a gap in Su with respect to U starting at Sm, then the singleton
 
\family typewriter
mo_nr
\family default
 contains a 
\family typewriter
matched_object
\family default
 containing and id_m.
 The two questions 
\begin_inset Quotes eld
\end_inset

is this a focus-object?
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

is this object to be retrieved?
\begin_inset Quotes erd
\end_inset

 are also answered.
\end_layout

\begin_layout Standard
If there is no such gap, then the singleton 
\begin_inset Quotes eld
\end_inset

(
\family typewriter
EMPTY_mo
\family default
, 
\family typewriter
true
\family default
)
\begin_inset Quotes erd
\end_inset

 is returned.
 This is not a failure, but indicates that the optional gap matched an empty
 stretch of the database.
\end_layout

\begin_layout Standard
Since 
\family typewriter
U
\family default
 is always a universe (see our definition in section 
\begin_inset LatexCommand \ref{Universe}

\end_inset

 on page 
\begin_inset LatexCommand \pageref{Universe}

\end_inset

), we can calculate the existence of gaps in 
\family typewriter
Su
\family default
 with respect to 
\family typewriter
U
\family default
 from 
\family typewriter
Su
\family default
 alone.
 Thus we need not even inspect the database, but can just look at 
\family typewriter
Su
\family default
.
\end_layout

\begin_layout Subsection
R_focus_gap_retrieval
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
gap_retrieval  :  /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
               |  T_KEY_RETRIEVE  |  T_KEY_FOCUS;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_focus_gap_retrieval
\end_layout

\begin_layout LyX-Code
 * Returns:  true on focus, false otherwise
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_focus_gap_retrieval(gap_retrieval) --> boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (gap_retrieval = T_KEY_FOCUS) then
\end_layout

\begin_layout LyX-Code
        return true;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return false;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
This function answers the question 
\begin_inset Quotes eld
\end_inset

Is this a focus object?
\begin_inset Quotes erd
\end_inset

 It returns true if the syntactic incarnation of 
\family typewriter
gap_retrieval
\family default
 is 
\family typewriter
T_KEY_FOCUS
\family default
.
 Otherwise, it returns false.
\end_layout

\begin_layout Subsection
R_retrieval_gap_retrieval
\end_layout

\begin_layout Standard
The 
\family typewriter
gap_retrieval
\family default
 syntactic construct is used in 
\family typewriter
opt_gap_block
\family default
 and 
\family typewriter
gap_block
\family default
.
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
gap_retrieval  :  /* empty */  |  T_KEY_NORETRIEVE  
\end_layout

\begin_layout LyX-Code
               |  T_KEY_RETRIEVE  |  T_KEY_FOCUS;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_retrieval_gap_retrieval
\end_layout

\begin_layout LyX-Code
 * Returns:  false on must retrieve, true otherwise
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_retrieval_gap_retrieval(gap_retrieval) --> boolean;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (gap_retrieval = T_KEY_RETRIEVE or 
\end_layout

\begin_layout LyX-Code
        gap_retrieval = T_KEY_FOCUS) then
\end_layout

\begin_layout LyX-Code
        return false;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return true;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
gap_retrieval
\family default
 syntactic construct is used to specify whether the user wants to retrieve
 the gap or not.
 The default, when empty, is to assume that we do 
\emph on
not
\emph default
 want to retrieve the gap.
 Thus, if the user wants to retrieve the gap, they must explicitly write
 
\begin_inset Quotes eld
\end_inset


\family typewriter
retrieve
\family default

\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
focus
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Note that this has different semantics from 
\family typewriter
retrieval
\family default
 for the default.
 For 
\family typewriter
gap_retrieval
\family default
, the default is to assume that we do 
\emph on
not
\emph default
 want to retrieve the gap.
 For 
\family typewriter
retrieval
\family default
, the default is to assume that we 
\emph on
do
\emph default
 want to retrieve the 
\family typewriter
object_block
\family default
(
\family typewriter
_first
\family default
).
\end_layout

\begin_layout Subsection
gap_block
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
gap_block : '['  T_KEY_GAP  gap_retrieval  opt_blocks ']'  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/* 
\end_layout

\begin_layout LyX-Code
 * R_gap_block
\end_layout

\begin_layout LyX-Code
 * Returns: (matched_object, noretrieve)
\end_layout

\begin_layout LyX-Code
 * ON FAIL: < (NIL_mo, true) >
\end_layout

\begin_layout LyX-Code
 * ON SUCCESS: < ( [ id_m focus ], true|false ) >
\end_layout

\begin_layout LyX-Code
 *
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_gap_block(U,Su,Sm,gap_block) --> list_of_mo_nr ; 
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    U', Su' : set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
    inst' : instances;
\end_layout

\begin_layout LyX-Code
    s : sheaf;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    if (there exists monad m such that Sm..m is a gap in Su 
\end_layout

\begin_layout LyX-Code
        with respect to U) then
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        U' := pow_m(Sm..m);
\end_layout

\begin_layout LyX-Code
        Su' := U';
\end_layout

\begin_layout LyX-Code
        inst' := R_inst_opt_blocks(U,opt_blocks);
\end_layout

\begin_layout LyX-Code
        s := R_opt_blocks(U',Su',inst',opt_blocks);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
        return < ( [ pow_m(Sm..m) R_focus_gap_retrieval(gap_retrieval) s],
 
\end_layout

\begin_layout LyX-Code
                   R_gap_retrieval(gap_retrieval)) >;
\end_layout

\begin_layout LyX-Code
    end
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return < (NIL_mo,true) >;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
R_gap_block
\family default
 function is very analogous to the 
\family typewriter
R_opt_gap_block
\family default
 function.
 The only difference between function the 
\family typewriter
R_gap_block
\family default
 and the 
\family typewriter
R_opt_gap_block
\family default
 function is that the former returns the singleton (
\family typewriter
NIL_mo
\family default
, 
\family typewriter
true
\family default
) if there was no gap at Sm.
 Thus this function can in fact fail.
\end_layout

\begin_layout Subsection
object_block
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code
object_block  :  '['  object_type_name
\end_layout

\begin_layout LyX-Code
                      object_reference_declaration
\end_layout

\begin_layout LyX-Code
                      retrieval  last  features  
\end_layout

\begin_layout LyX-Code
                      opt_blocks  ']'  ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/* 
\end_layout

\begin_layout LyX-Code
 * R_object_block
\end_layout

\begin_layout LyX-Code
 * Returns: list_of_mo_nr
\end_layout

\begin_layout LyX-Code
 * ON FAIL: < (NIL_mo,true) >
\end_layout

\begin_layout LyX-Code
 * On SUCCESS:  A list of objects starting at Sm.
\end_layout

\begin_layout LyX-Code
 *              Also, there are no (NIL_mo,true) mo_nr's
\end_layout

\begin_layout LyX-Code
 *              in the list.
\end_layout

\begin_layout LyX-Code
 *
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_object_block(U,Su,Sm,object_block) --> 
\end_layout

\begin_layout LyX-Code
         list_of_mo_nr ;
\end_layout

\begin_layout LyX-Code
var
\end_layout

\begin_layout LyX-Code
    O : object;
\end_layout

\begin_layout LyX-Code
    Inner : sheaf;
\end_layout

\begin_layout LyX-Code
    fl : enum_first_last;
\end_layout

\begin_layout LyX-Code
    U' : set_of_monad_ms;
\end_layout

\begin_layout LyX-Code
    inst' : instances;
\end_layout

\begin_layout LyX-Code
    Straw1 : straw;
\end_layout

\begin_layout LyX-Code
    Result : list_of_mo_nr;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- Initialize Result.
 --- */
\end_layout

\begin_layout LyX-Code
    Result := < >;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
    /* --- Get all O's beginning at Sm (Start Monad).
 --- */
\end_layout

\begin_layout LyX-Code
    Straw1 := /* all O of type "type" such that O.first() = Sm */;
\end_layout

\begin_layout LyX-Code
    for (each O in Straw1) do
\end_layout

\begin_layout LyX-Code
    begin
\end_layout

\begin_layout LyX-Code
        /* --- Note that we might not get here, since Straw1 
\end_layout

\begin_layout LyX-Code
           might be empty.
 --- */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        /* --- Calculate last/no_first_last.
  It is deemed better 
\end_layout

\begin_layout LyX-Code
           to have it here rather than outside the "for" loop, 
\end_layout

\begin_layout LyX-Code
           since here it is only executed O(n) times, where n is 
\end_layout

\begin_layout LyX-Code
           the number of O's beginning at Sm.
  If we put it 
\end_layout

\begin_layout LyX-Code
           outside, we will execute it _every_ time we call 
\end_layout

\begin_layout LyX-Code
           R_object_block, which is deemed to be more times than 
\end_layout

\begin_layout LyX-Code
           if we place it here.
  There might not be any objects
\end_layout

\begin_layout LyX-Code
           starting at Sm! --- */
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        fl := R_last(object_block);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
        if (((fl = last) and (O.last() = U.last()))
\end_layout

\begin_layout LyX-Code
             or (fl = no_first_last)
\end_layout

\begin_layout LyX-Code
            and
\end_layout

\begin_layout LyX-Code
            (O part_of Su)
\end_layout

\begin_layout LyX-Code
            and
\end_layout

\begin_layout LyX-Code
            (R_features(O,features)) then
\end_layout

\begin_layout LyX-Code
        begin
\end_layout

\begin_layout LyX-Code
            /* --- Update symbol table with 
\end_layout

\begin_layout LyX-Code
               object reference declaration --- */
\end_layout

\begin_layout LyX-Code
            R_object_reference_declaration(O,
\end_layout

\begin_layout LyX-Code
                object_reference_declaration);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Make new universe as
\end_layout

\begin_layout LyX-Code
               O.first()..O.last().
 --- */
\end_layout

\begin_layout LyX-Code
            U' = Hat(O,U);  /* O^U */
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
            /* --- Calculate new inst --- */
\end_layout

\begin_layout LyX-Code
            inst' := R_inst_opt_blocks(U', opt_blocks);
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
            /* --- Calculate inner.
 --- */
\end_layout

\begin_layout LyX-Code
            Inner := R_opt_blocks(U',O,inst',opt_blocks);
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
            /* --- Only add object if Inner was a 
\end_layout

\begin_layout LyX-Code
               success.
 --- */ 
\end_layout

\begin_layout LyX-Code
            if (Inner <> "// ")
\end_layout

\begin_layout LyX-Code
                Result := Result + 
\end_layout

\begin_layout LyX-Code
                          < ( [ O.id R_focus_retrieval(retrieval) 
\end_layout

\begin_layout LyX-Code
                                Inner ],
\end_layout

\begin_layout LyX-Code
                              R_retrieval_retrieval(retrieval) ) >;
\end_layout

\begin_layout LyX-Code
        end;
\end_layout

\begin_layout LyX-Code
    end;
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
    if (Result = < >)
\end_layout

\begin_layout LyX-Code
        return < (NIL_mo,true) >;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return Result;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
The 
\family typewriter
R_object_block
\family default
 function returns the 
\family typewriter
list_of_mo_nr
\family default
 corresponding to all those objects of type 
\family typewriter
object_type_name
\family default
 which start at 
\family typewriter
Sm
\family default
, and for which a number of constraints hold.
 More than one object may start at Sm, and this is the reason why we return
 a 
\family typewriter
list_of_mo_nr
\family default
 rather than a single 
\family typewriter
mo_nr
\family default
.
\end_layout

\begin_layout Standard
On failure, the function returns the singleton list 
\family typewriter
<\InsetSpace ~
(NIL_mo,true)\InsetSpace ~

\family default
>.
\end_layout

\begin_layout Standard
The 
\family typewriter
Sm
\family default
 parameter is a "Start Monad" parameter.
 It is used to get all those objects of the given type which start at the
 given monad.
 
\emph on
This is why it is handy to store a list of those objects which start at
 a given monad_m in a 
\family typewriter
monad_d
\family default
.
\end_layout

\begin_layout Standard
This function is actually quite simple, despite its cluttered look.
 The steps are as follows:
\end_layout

\begin_layout Enumerate
Initialize 
\family typewriter
Result
\family default
 to be the empty set of 
\family typewriter
matched_objects
\family default
 (a 
\family typewriter
straw
\family default
).
\end_layout

\begin_layout Enumerate
Set 
\family typewriter
Straw1
\family default
 to contain all those objects of type 
\family typewriter
object_type_name
\family default
 which start at 
\family typewriter
Sm
\family default
.
 This is done by inspection of the monad_d corresponding to 
\family typewriter
Sm
\family default
.
\end_layout

\begin_layout Enumerate
For each 
\family typewriter
O
\family default
 in 
\family typewriter
Straw1
\family default
, do the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
IF (the rules about 
\family typewriter
last
\family default
 are obeyed) AND (
\family typewriter
O
\family default
 part_of 
\family typewriter
Su
\family default
) AND (the features all match) THEN
\end_layout

\begin_deeper
\begin_layout Enumerate
Update the symbol table with the object reference declaration if it is there.
\end_layout

\begin_layout Enumerate
Calculate 
\family typewriter
U'
\family default
 = 
\family typewriter
O^U
\family default
 (see section 
\begin_inset LatexCommand \ref{hat}

\end_inset

 on page 
\begin_inset LatexCommand \pageref{hat}

\end_inset

).
\end_layout

\begin_layout Enumerate
Calculate new instances array based on 
\family typewriter
U'
\family default
.
\end_layout

\begin_layout Enumerate
Calculate the result of the inner 
\family typewriter
opt_blocks
\family default
 (call 
\family typewriter
R_opt_blocks
\family default
 with 
\family typewriter
U'
\family default
 as the universe and 
\family typewriter
O
\family default
 as the substrate)
\end_layout

\begin_layout Enumerate
IF (the call to 
\family typewriter
R_opt_blocks
\family default
 was a success) THEN add the matched object 
\begin_inset Quotes eld
\end_inset


\family typewriter
[\InsetSpace ~
O.id focus\InsetSpace ~
Inner\InsetSpace ~
]
\family default

\begin_inset Quotes erd
\end_inset

, paired with the retrieval information in 
\family typewriter
retrieval
\family default
, to 
\family typewriter
Result
\family default
.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
IF 
\family typewriter
Result
\family default
 is empty, return 
\family typewriter
<\InsetSpace ~
(NIL_mo,true)\InsetSpace ~
>
\family default
.
 We did not find anything, so we failed.
\end_layout

\begin_layout Enumerate
ELSE, return 
\family typewriter
Result
\family default
.
\end_layout

\begin_layout Subsection
last
\end_layout

\begin_layout Standard
The 
\family typewriter
last
\family default
 syntactic construct is used in 
\family typewriter
object_block
\family default
.
\end_layout

\begin_layout Subsubsection
syntax
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
last  :  /* empty */ | T_KEY_LAST ;
\end_layout

\begin_layout Subsubsection
semantics
\end_layout

\begin_layout LyX-Code
/*
\end_layout

\begin_layout LyX-Code
 * R_last
\end_layout

\begin_layout LyX-Code
 * Returns: a member of enum_first_last:
\end_layout

\begin_layout LyX-Code
 *          - last if "last"
\end_layout

\begin_layout LyX-Code
 *          - no_first_last otherwise
\end_layout

\begin_layout LyX-Code
 */
\end_layout

\begin_layout LyX-Code
function R_last(last) --> enum_first_last;
\end_layout

\begin_layout LyX-Code
begin
\end_layout

\begin_layout LyX-Code
    /* --- decide which syntactic incarnation to use --- */
\end_layout

\begin_layout LyX-Code
    if (last = T_KEY_LAST) then
\end_layout

\begin_layout LyX-Code
        return last;
\end_layout

\begin_layout LyX-Code
    else
\end_layout

\begin_layout LyX-Code
        return no_first_last;
\end_layout

\begin_layout LyX-Code
end;
\end_layout

\begin_layout Subsubsection
explanation
\end_layout

\begin_layout Standard
See section 
\begin_inset LatexCommand \vref{firstlast_explanation}

\end_inset

 for an explanation.
\end_layout

\end_body
\end_document
